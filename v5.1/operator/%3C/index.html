---
root: "/v5.1"
title: "<"
description: "Swift documentation for '<'"
layout: "default"
keywords: ""
---

<div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (), rhs: ()) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>An arity zero tuple is never strictly before another arity zero tuple in a
lexicographical ordering.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B), rhs: (A, B)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C), rhs: (A, B, C)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (), rhs: ()) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>An arity zero tuple is never strictly before another arity zero tuple in a
lexicographical ordering.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B), rhs: (A, B)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C), rhs: (A, B, C)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the first tuple is ordered
before the second in a lexicographical ordering.
</p>
<p>Given two tuples <code>(a1, a2, ..., aN)</code> and <code>(b1, b2, ..., bN)</code>, the first
tuple is before the second tuple if and only if
<code>a1 &lt; b1</code> or (<code>a1 == b1</code> and
<code>(a2, ..., aN) &lt; (b2, ..., bN)</code>).</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: Int, rhs: Int) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: Int16, rhs: Int16) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: Int32, rhs: Int32) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: Int64, rhs: Int64) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: Int8, rhs: Int8) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: UInt, rhs: UInt) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: UInt16, rhs: UInt16) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: UInt32, rhs: UInt32) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: UInt64, rhs: UInt64) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div><div class="intro-declaration"><code class="language-swift">func &lt;(lhs:rhs:)(lhs: UInt8, rhs: UInt8) -> Bool</code></div><div class="discussion comment"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.
</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
</div>