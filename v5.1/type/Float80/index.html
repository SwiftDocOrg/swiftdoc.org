---
keywords: ""
layout: "default"
description: "Swift documentation for 'Float80'"
root: "/v5.1"
title: "Float80"
---

<div class="intro-declaration"><code class="language-swift">struct Float80</code></div><p>An extended-precision, floating-point value type.</p>
<table class="standard"><tr><th id="inheritance">Inheritance</th><td><code class="inherits">BinaryFloatingPoint, CustomDebugStringConvertible, CustomReflectable, CustomStringConvertible, ExpressibleByIntegerLiteral, Hashable, LosslessStringConvertible, Strideable, TextOutputStreamable</code></td></tr><tr><th id="aliases">Associated Types</th><td><span id="aliasesmark"></span><div class="declaration"><code class="language-swift">public typealias Magnitude = Float80</code><div class="comment"></div></div><div class="declaration"><code class="language-swift">public typealias Exponent = Int</code><div class="comment"></div></div><div class="declaration"><code class="language-swift">public typealias RawSignificand = UInt64</code><div class="comment"></div></div></td></tr></table><div class="discussion comment"></div><h3>Initializers</h3><div id="init-e67906ab4373125a18eb2b5a75f59bd2" class="declaration"><a class="toggle-link" href="#comment-init-e67906ab4373125a18eb2b5a75f59bd2">init init()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-e67906ab4373125a18eb2b5a75f59bd2"><h4>Declaration</h4><code class="language-swift">public init()</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new value, rounded to the closest possible representation.</p>
<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>
<ul>
<li>Parameter value: The integer to convert to a floating-point value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public init(_ v: Int)</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new value, rounded to the closest possible representation.</p>
<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>
<ul>
<li>Parameter value: The integer to convert to a floating-point value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init&lt;Source>(_ value: Source) where Source: BinaryInteger</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new instance that approximates the given value.</p>
<p>The value of <code>other</code> is rounded to a representable value, if necessary.
A NaN passed as <code>other</code> results in another NaN, with a signaling NaN
value converted to quiet NaN.</p>
<pre><code class="language-swift">let x: Float = 21.25
let y = Float80(x)
// y == 21.25

let z = Float80(Float.nan)
// z.isNaN == true
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(_ other: Float)</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new instance that approximates the given value.</p>
<p>The value of <code>other</code> is rounded to a representable value, if necessary.
A NaN passed as <code>other</code> results in another NaN, with a signaling NaN
value converted to quiet NaN.</p>
<pre><code class="language-swift">let x: Double = 21.25
let y = Float80(x)
// y == 21.25

let z = Float80(Double.nan)
// z.isNaN == true
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(_ other: Double)</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new instance initialized to the given value.</p>
<p>The value of <code>other</code> is represented exactly by the new instance. A NaN
passed as <code>other</code> results in another NaN, with a signaling NaN value
converted to quiet NaN.</p>
<pre><code class="language-swift">let x: Float80 = 21.25
let y = Float80(x)
// y == 21.25

let z = Float80(Float80.nan)
// z.isNaN == true
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(_ other: Float80)</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new instance from the given value, rounded to the closest
possible representation.</p>
<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>
<ul>
<li>Parameter value: A floating-point value to be converted.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init&lt;Source>(_ value: Source) where Source: BinaryFloatingPoint</code></div></div><div id="init_floatLiteral-8334e81b87b95183e6b6e49ec7fe203f" class="declaration"><a class="toggle-link" href="#comment-init_floatLiteral-8334e81b87b95183e6b6e49ec7fe203f">init init(floatLiteral:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_floatLiteral-8334e81b87b95183e6b6e49ec7fe203f"><p>Creates an instance initialized to the specified floating-point value.</p>
<p>Do not call this initializer directly. Instead, initialize a variable or
constant using a floating-point literal. For example:</p>
<pre><code class="language-swift">let x = 21.5
</code></pre>
<p>In this example, the assignment to the <code>x</code> constant calls this
floating-point literal initializer behind the scenes.</p>
<ul>
<li>Parameter value: The value to create.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(floatLiteral value: Float80)</code></div></div><div id="init_integerLiteral-82f4c43a2d364fab74b9e9bd1c193e2e" class="declaration"><a class="toggle-link" href="#comment-init_integerLiteral-82f4c43a2d364fab74b9e9bd1c193e2e">init init(integerLiteral:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_integerLiteral-82f4c43a2d364fab74b9e9bd1c193e2e"><p>Creates an instance initialized to the specified integer value.</p>
<p>Do not call this initializer directly. Instead, initialize a variable or
constant using an integer literal. For example:</p>
<pre><code class="language-swift">let x = 23
</code></pre>
<p>In this example, the assignment to the <code>x</code> constant calls this integer
literal initializer behind the scenes.</p>
<ul>
<li>Parameter value: The value to create.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public init(integerLiteral value: Int64)</code></div></div><div id="init_nan_signaling-634b3ae129377456f1c73fafead889fb" class="declaration"><a class="toggle-link" href="#comment-init_nan_signaling-634b3ae129377456f1c73fafead889fb">init init(nan:signaling:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_nan_signaling-634b3ae129377456f1c73fafead889fb"><p>Creates a NaN (&quot;not a number&quot;) value with the specified payload.</p>
<p>NaN values compare not equal to every value, including themselves. Most
operations with a NaN operand produce a NaN result. Don't use the
equal-to operator (<code>==</code>) to test whether a value is NaN. Instead, use
the value's <code>isNaN</code> property.</p>
<pre><code class="language-swift">let x = Float80(nan: 0, signaling: false)
print(x == .nan)
// Prints &quot;false&quot;
print(x.isNaN)
// Prints &quot;true&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(nan payload: Float80.RawSignificand, signaling: Bool)</code></div></div><div id="init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44" class="declaration"><a class="toggle-link" href="#comment-init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44">init init(sign:exponent:significand:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44"><p>Creates a new value from the given sign, exponent, and significand.</p>
<p>The following example uses this initializer to create a new <code>Double</code>
instance. <code>Double</code> is a binary floating-point type that has a radix of
<code>2</code>.</p>
<pre><code class="language-swift">let x = Double(sign: .plus, exponent: -2, significand: 1.5)
// x == 0.375
</code></pre>
<p>This initializer is equivalent to the following calculation, where <code>**</code>
is exponentiation, computed as if by a single, correctly rounded,
floating-point operation:</p>
<pre><code class="language-swift">let sign: FloatingPointSign = .plus
let exponent = -2
let significand = 1.5
let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
// y == 0.375
</code></pre>
<p>As with any basic operation, if this value is outside the representable
range of the type, overflow or underflow occurs, and zero, a subnormal
value, or infinity may result. In addition, there are two other edge
cases:</p>
<p>For any floating-point value <code>x</code> of type <code>F</code>, the result of the following
is equal to <code>x</code>, with the distinction that the result is canonicalized
if <code>x</code> is in a noncanonical encoding:</p>
<pre><code class="language-swift">let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
</code></pre>
<p>This initializer implements the <code>scaleB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(sign: FloatingPointSign, exponent: Int, significand: Float80)</code></div></div><div id="init_sign_exponentBitPattern_significandBitPattern-df70b9cc2df84ba9aa039f122ee4beae" class="declaration"><a class="toggle-link" href="#comment-init_sign_exponentBitPattern_significandBitPattern-df70b9cc2df84ba9aa039f122ee4beae">init init(sign:exponentBitPattern:significandBitPattern:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_sign_exponentBitPattern_significandBitPattern-df70b9cc2df84ba9aa039f122ee4beae"><p>Creates a new instance from the specified sign and bit patterns.</p>
<p>The values passed as <code>exponentBitPattern</code> and <code>significandBitPattern</code> are
interpreted in the binary interchange format defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)</code></div></div><div id="init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37" class="declaration"><a class="toggle-link" href="#comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37">init init(signOf:magnitudeOf:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37"><p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>
<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>
<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;
</code></pre>
<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>
<h4>Declaration</h4><code class="language-swift">public init(signOf sign: Float80, magnitudeOf mag: Float80)</code></div></div><div id="init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37" class="declaration"><a class="toggle-link" href="#comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37">init init(signOf:magnitudeOf:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37"><p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>
<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>
<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;
</code></pre>
<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(signOf: Self, magnitudeOf: Self)</code></div></div><div id="init-48690522e4b66d2b1596ce439b7dd9cd" class="declaration"><a class="toggle-link" href="#comment-init-48690522e4b66d2b1596ce439b7dd9cd">init init?(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-48690522e4b66d2b1596ce439b7dd9cd"><p>Creates a new instance from the given string.</p>
<p>The string passed as <code>text</code> can represent a real number in decimal or
hexadecimal format or special floating-point values for infinity and NaN
(&quot;not a number&quot;).</p>
<p>The given string may begin with a plus or minus sign character (<code>+</code> or
<code>-</code>). The allowed formats for each of these representations is then as
follows:</p>
<p>Passing any other format or any additional characters as <code>text</code> results
in <code>nil</code>. For example, the following conversions result in <code>nil</code>:</p>
<pre><code class="language-swift">Float80(&quot; 5.0&quot;)      // Includes whitespace
Float80(&quot;Â±2.0&quot;)      // Invalid character
Float80(&quot;0x1.25e4&quot;)  // Incorrect exponent format
</code></pre>
<ul>
<li>Parameter text: The input string to convert to a <code>Float80</code> instance. If
<code>text</code> has invalid characters or is in an invalid format, the result
is <code>nil</code>.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init?&lt;S>(_ text: S) where S: StringProtocol</code></div></div><div id="init_exactly-204302d00b556e1a402a579cd2a4f8b6" class="declaration"><a class="toggle-link" href="#comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6">init init?(exactly:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6"><p>Creates a new instance initialized to the given value, if it can be
represented without rounding.</p>
<p>If <code>other</code> can't be represented as an instance of <code>Float80</code> without
rounding, the result of this initializer is <code>nil</code>. In particular,
passing NaN as <code>other</code> always results in <code>nil</code>.</p>
<pre><code class="language-swift">let x: Float = 21.25
let y = Float80(exactly: x)
// y == Optional.some(21.25)

let z = Float80(exactly: Float.nan)
// z == nil
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init?(exactly other: Float)</code></div></div><div id="init_exactly-204302d00b556e1a402a579cd2a4f8b6" class="declaration"><a class="toggle-link" href="#comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6">init init?(exactly:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6"><p>Creates a new instance initialized to the given value, if it can be
represented without rounding.</p>
<p>If <code>other</code> can't be represented as an instance of <code>Float80</code> without
rounding, the result of this initializer is <code>nil</code>. In particular,
passing NaN as <code>other</code> always results in <code>nil</code>.</p>
<pre><code class="language-swift">let x: Double = 21.25
let y = Float80(exactly: x)
// y == Optional.some(21.25)

let z = Float80(exactly: Double.nan)
// z == nil
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init?(exactly other: Double)</code></div></div><div id="init_exactly-204302d00b556e1a402a579cd2a4f8b6" class="declaration"><a class="toggle-link" href="#comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6">init init?(exactly:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6"><p>Creates a new instance initialized to the given value, if it can be
represented without rounding.</p>
<p>If <code>other</code> can't be represented as an instance of <code>Float80</code> without
rounding, the result of this initializer is <code>nil</code>. In particular,
passing NaN as <code>other</code> always results in <code>nil</code>.</p>
<pre><code class="language-swift">let x: Float80 = 21.25
let y = Float80(exactly: x)
// y == Optional.some(21.25)

let z = Float80(exactly: Float80.nan)
// z == nil
</code></pre>
<ul>
<li>Parameter other: The value to use for the new instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init?(exactly other: Float80)</code></div></div><div id="init_exactly-204302d00b556e1a402a579cd2a4f8b6" class="declaration"><a class="toggle-link" href="#comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6">init init?(exactly:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6"><p>Creates a new instance from the given value, if it can be represented
exactly.</p>
<p>If the given floating-point value cannot be represented exactly, the
result is <code>nil</code>.</p>
<ul>
<li>Parameter value: A floating-point value to be converted.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init?&lt;Source>(exactly value: Source) where Source: BinaryFloatingPoint</code></div></div><h3>Instance Variables</h3><div id="binade-101913c61ccad4f2d3df9f767bf14e05" class="declaration"><a class="toggle-link" href="#comment-binade-101913c61ccad4f2d3df9f767bf14e05">var binade</a> <span class="required">Required</span><div class="comment collapse in" id="comment-binade-101913c61ccad4f2d3df9f767bf14e05"><p>The floating-point value with the same sign and exponent as this value,
but with a significand of 1.0.</p>
<p>A <em>binade</em> is a set of binary floating-point values that all have the
same sign and exponent. The <code>binade</code> property is a member of the same
binade as this value, but with a unit significand.</p>
<p>In this example, <code>x</code> has a value of <code>21.5</code>, which is stored as
<code>1.34375 * 2**4</code>, where <code>**</code> is exponentiation. Therefore, <code>x.binade</code> is
equal to <code>1.0 * 2**4</code>, or <code>16.0</code>.</p>
<pre><code class="language-swift">let x = 21.5
// x.significand == 1.34375
// x.exponent == 4

let y = x.binade
// y == 16.0
// y.significand == 1.0
// y.exponent == 4
</code></pre>
<h4>Declaration</h4><code class="language-swift">var binade: Float80</code></div></div><div id="customMirror-c4bea5adb1649887b1a7e9972736e2a9" class="declaration"><a class="toggle-link" href="#comment-customMirror-c4bea5adb1649887b1a7e9972736e2a9">var customMirror</a> <span class="required">Required</span><div class="comment collapse in" id="comment-customMirror-c4bea5adb1649887b1a7e9972736e2a9"><p>A mirror that reflects the Float80 instance.</p>
<h4>Declaration</h4><code class="language-swift">var customMirror: Mirror</code></div></div><div id="debugDescription-15dc1a07010ea28e38b1f4d74663fe11" class="declaration"><a class="toggle-link" href="#comment-debugDescription-15dc1a07010ea28e38b1f4d74663fe11">var debugDescription</a> <span class="required">Required</span><div class="comment collapse in" id="comment-debugDescription-15dc1a07010ea28e38b1f4d74663fe11"><p>A textual representation of the value, suitable for debugging.</p>
<h4>Declaration</h4><code class="language-swift">var debugDescription: String</code></div></div><div id="description-67daf92c833c41c95db874e18fcb2786" class="declaration"><a class="toggle-link" href="#comment-description-67daf92c833c41c95db874e18fcb2786">var description</a> <span class="required">Required</span><div class="comment collapse in" id="comment-description-67daf92c833c41c95db874e18fcb2786"><p>A textual representation of the value.</p>
<h4>Declaration</h4><code class="language-swift">var description: String</code></div></div><div id="exponent-facd4bc86b7f12740c83bcaa4e75ae0a" class="declaration"><a class="toggle-link" href="#comment-exponent-facd4bc86b7f12740c83bcaa4e75ae0a">var exponent</a> <span class="required">Required</span><div class="comment collapse in" id="comment-exponent-facd4bc86b7f12740c83bcaa4e75ae0a"><p>The exponent of the floating-point value.</p>
<p>The <em>exponent</em> of a floating-point value is the integer part of the
logarithm of the value's magnitude. For a value <code>x</code> of a floating-point
type <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>
is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>
<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2
</code></pre>
<p>The <code>exponent</code> property has the following edge cases:</p>
<p>This property implements the <code>logB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">var exponent: Int</code></div></div><div id="exponentBitPattern-5114e0ec4bf24f8198eaf9e0eaed36a4" class="declaration"><a class="toggle-link" href="#comment-exponentBitPattern-5114e0ec4bf24f8198eaf9e0eaed36a4">var exponentBitPattern</a> <span class="required">Required</span><div class="comment collapse in" id="comment-exponentBitPattern-5114e0ec4bf24f8198eaf9e0eaed36a4"><p>The raw encoding of the value's exponent field.</p>
<p>This value is unadjusted by the type's exponent bias.</p>
<h4>Declaration</h4><code class="language-swift">var exponentBitPattern: UInt</code></div></div><div id="isCanonical-496dbf394bd7711e683f14e7a9f59cd3" class="declaration"><a class="toggle-link" href="#comment-isCanonical-496dbf394bd7711e683f14e7a9f59cd3">var isCanonical</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isCanonical-496dbf394bd7711e683f14e7a9f59cd3"><p>A Boolean value indicating whether the instance's representation is in
its canonical form.</p>
<p>The <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a> defines a <em>canonical</em>, or preferred,
encoding of a floating-point value. On platforms that fully support
IEEE 754, every <code>Float</code> or <code>Double</code> value is canonical, but
non-canonical values can exist on other platforms or for other types.
Some examples:</p>
<h4>Declaration</h4><code class="language-swift">var isCanonical: Bool</code></div></div><div id="isFinite-9aede8959ec60dfb48af5f9b7655cf62" class="declaration"><a class="toggle-link" href="#comment-isFinite-9aede8959ec60dfb48af5f9b7655cf62">var isFinite</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isFinite-9aede8959ec60dfb48af5f9b7655cf62"><p>A Boolean value indicating whether this instance is finite.</p>
<p>All values other than NaN and infinity are considered finite, whether
normal or subnormal.</p>
<h4>Declaration</h4><code class="language-swift">var isFinite: Bool</code></div></div><div id="isInfinite-52b5d9d6f19c5b9406bde2b919a1a331" class="declaration"><a class="toggle-link" href="#comment-isInfinite-52b5d9d6f19c5b9406bde2b919a1a331">var isInfinite</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isInfinite-52b5d9d6f19c5b9406bde2b919a1a331"><p>A Boolean value indicating whether the instance is infinite.</p>
<p>Note that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because
they are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.</p>
<h4>Declaration</h4><code class="language-swift">var isInfinite: Bool</code></div></div><div id="isNaN-22f89537344f145d3bff4f753599b846" class="declaration"><a class="toggle-link" href="#comment-isNaN-22f89537344f145d3bff4f753599b846">var isNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isNaN-22f89537344f145d3bff4f753599b846"><p>A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).</p>
<p>Because NaN is not equal to any value, including NaN, use this property
instead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)
to test whether a value is or is not NaN. For example:</p>
<pre><code class="language-swift">let x = 0.0
let y = x * .infinity
// y is a NaN

// Comparing with the equal-to operator never returns 'true'
print(x == Double.nan)
// Prints &quot;false&quot;
print(y == Double.nan)
// Prints &quot;false&quot;

// Test with the 'isNaN' property instead
print(x.isNaN)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;
</code></pre>
<p>This property is <code>true</code> for both quiet and signaling NaNs.</p>
<h4>Declaration</h4><code class="language-swift">var isNaN: Bool</code></div></div><div id="isNormal-55cbe981d89818d253fad00235c2bdbf" class="declaration"><a class="toggle-link" href="#comment-isNormal-55cbe981d89818d253fad00235c2bdbf">var isNormal</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isNormal-55cbe981d89818d253fad00235c2bdbf"><p>A Boolean value indicating whether this instance is normal.</p>
<p>A <em>normal</em> value is a finite number that uses the full precision
available to values of a type. Zero is neither a normal nor a subnormal
number.</p>
<h4>Declaration</h4><code class="language-swift">var isNormal: Bool</code></div></div><div id="isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9" class="declaration"><a class="toggle-link" href="#comment-isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9">var isSignalingNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9"><p>A Boolean value indicating whether the instance is a signaling NaN.</p>
<p>Signaling NaNs typically raise the Invalid flag when used in general
computing operations.</p>
<h4>Declaration</h4><code class="language-swift">var isSignalingNaN: Bool</code></div></div><div id="isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836" class="declaration"><a class="toggle-link" href="#comment-isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836">var isSubnormal</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836"><p>A Boolean value indicating whether the instance is subnormal.</p>
<p>A <em>subnormal</em> value is a nonzero number that has a lesser magnitude than
the smallest normal number. Subnormal values do not use the full
precision available to values of a type.</p>
<p>Zero is neither a normal nor a subnormal number. Subnormal numbers are
often called <em>denormal</em> or <em>denormalized</em>---these are different names
for the same concept.</p>
<h4>Declaration</h4><code class="language-swift">var isSubnormal: Bool</code></div></div><div id="isZero-855b2871ffd10a823656f50f04eab650" class="declaration"><a class="toggle-link" href="#comment-isZero-855b2871ffd10a823656f50f04eab650">var isZero</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isZero-855b2871ffd10a823656f50f04eab650"><p>A Boolean value indicating whether the instance is equal to zero.</p>
<p>The <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either
<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:
<code>x == 0.0</code>.</p>
<pre><code class="language-swift">let x = -0.0
x.isZero        // true
x == 0.0        // true
</code></pre>
<h4>Declaration</h4><code class="language-swift">var isZero: Bool</code></div></div><div id="magnitude-28c3d8f4b7e312af5e0d6b59a50efd1c" class="declaration"><a class="toggle-link" href="#comment-magnitude-28c3d8f4b7e312af5e0d6b59a50efd1c">var magnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-magnitude-28c3d8f4b7e312af5e0d6b59a50efd1c"><p>The magnitude of this value.</p>
<p>For any numeric value <code>x</code>, <code>x.magnitude</code> is the absolute value of <code>x</code>.
You can use the <code>magnitude</code> property in operations that are simpler to
implement in terms of unsigned values, such as printing the value of an
integer, which is just printing a '-' character in front of an absolute
value.</p>
<pre><code class="language-swift">let x = -200
// x.magnitude == 200
</code></pre>
<p>The global <code>abs(_:)</code> function provides more familiar syntax when you need
to find an absolute value. In addition, because <code>abs(_:)</code> always returns
a value of the same type, even in a generic context, using the function
instead of the <code>magnitude</code> property is encouraged.</p>
<h4>Declaration</h4><code class="language-swift">var magnitude: Float80</code></div></div><div id="nextUp-1e8421452662292aabe5179fd6f2b60b" class="declaration"><a class="toggle-link" href="#comment-nextUp-1e8421452662292aabe5179fd6f2b60b">var nextUp</a> <span class="required">Required</span><div class="comment collapse in" id="comment-nextUp-1e8421452662292aabe5179fd6f2b60b"><p>The least representable value that compares greater than this value.</p>
<p>For any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or
<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also
apply:</p>
<h4>Declaration</h4><code class="language-swift">var nextUp: Float80</code></div></div><div id="sign-04b29480233f4def5c875875b6bdc3b1" class="declaration"><a class="toggle-link" href="#comment-sign-04b29480233f4def5c875875b6bdc3b1">var sign</a> <span class="required">Required</span><div class="comment collapse in" id="comment-sign-04b29480233f4def5c875875b6bdc3b1"><p>The sign of the floating-point value.</p>
<p>The <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and
<code>.plus</code> otherwise. For example:</p>
<pre><code class="language-swift">let x = -33.375
// x.sign == .minus
</code></pre>
<p>Do not use this property to check whether a floating point value is
negative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not
necessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if
<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>
could be either <code>.plus</code> or <code>.minus</code>.</p>
<h4>Declaration</h4><code class="language-swift">var sign: FloatingPointSign</code></div></div><div id="significand-a87164f046fa355362627965a390529a" class="declaration"><a class="toggle-link" href="#comment-significand-a87164f046fa355362627965a390529a">var significand</a> <span class="required">Required</span><div class="comment collapse in" id="comment-significand-a87164f046fa355362627965a390529a"><p>The significand of the floating-point value.</p>
<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>
<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2
</code></pre>
<p>If a type's radix is 2, then for finite nonzero numbers, the significand
is in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>
is defined as follows:</p>
<blockquote>
<p>Note:
The significand is frequently also called the <em>mantissa</em>, but significand is the preferred terminology in the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>, to allay confusion with the use of mantissa for the fractional part of a logarithm.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">var significand: Float80</code></div></div><div id="significandBitPattern-b8205ffbbb0d8e16303cc55729557f5e" class="declaration"><a class="toggle-link" href="#comment-significandBitPattern-b8205ffbbb0d8e16303cc55729557f5e">var significandBitPattern</a> <span class="required">Required</span><div class="comment collapse in" id="comment-significandBitPattern-b8205ffbbb0d8e16303cc55729557f5e"><p>The raw encoding of the value's significand field.</p>
<p>The <code>significandBitPattern</code> property does not include the leading
integral bit of the significand, even for types like <code>Float80</code> that
store it explicitly.</p>
<h4>Declaration</h4><code class="language-swift">var significandBitPattern: UInt64</code></div></div><div id="significandWidth-c773978ad788bdc5839de81ee2e8850d" class="declaration"><a class="toggle-link" href="#comment-significandWidth-c773978ad788bdc5839de81ee2e8850d">var significandWidth</a> <span class="required">Required</span><div class="comment collapse in" id="comment-significandWidth-c773978ad788bdc5839de81ee2e8850d"><p>The number of bits required to represent the value's significand.</p>
<p>If this value is a finite nonzero number, <code>significandWidth</code> is the
number of fractional bits required to represent the value of
<code>significand</code>; otherwise, <code>significandWidth</code> is -1. The value of
<code>significandWidth</code> is always -1 or between zero and
<code>significandBitCount</code>. For example:</p>
<h4>Declaration</h4><code class="language-swift">var significandWidth: Int</code></div></div><div id="ulp-728996853f295d0206575099f828878b" class="declaration"><a class="toggle-link" href="#comment-ulp-728996853f295d0206575099f828878b">var ulp</a> <span class="required">Required</span><div class="comment collapse in" id="comment-ulp-728996853f295d0206575099f828878b"><p>The unit in the last place of this value.</p>
<p>This is the unit of the least significant digit in this value's
significand. For most numbers <code>x</code>, this is the difference between <code>x</code>
and the next greater (in magnitude) representable number. There are some
edge cases to be aware of:</p>
<p>See also the <code>ulpOfOne</code> static property.</p>
<h4>Declaration</h4><code class="language-swift">var ulp: Float80</code></div></div><h3>Instance Methods</h3><div id="addProduct-d1e8cd01a46534de278032de1e0a589b" class="declaration"><a class="toggle-link" href="#comment-addProduct-d1e8cd01a46534de278032de1e0a589b">func addProduct(_ lhs: Float80, _ rhs: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-addProduct-d1e8cd01a46534de278032de1e0a589b"><p>Adds the product of the two given values to this value in place, computed
without intermediate rounding.</p>
<h4>Declaration</h4><code class="language-swift">public mutating func addProduct(_ lhs: Float80, _ rhs: Float80)</code></div></div><div id="advanced_by-eca6cfea7368ad69605cb85a19cee2ca" class="declaration"><a class="toggle-link" href="#comment-advanced_by-eca6cfea7368ad69605cb85a19cee2ca">func advanced(by amount: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-advanced_by-eca6cfea7368ad69605cb85a19cee2ca"><p>Returns a value that is offset the specified distance from this value.</p>
<p>Use the <code>advanced(by:)</code> method in generic code to offset a value by a
specified distance. If you're working directly with numeric values, use
the addition operator (<code>+</code>) instead of this method.</p>
<pre><code class="language-swift">func addOne&lt;T: Strideable&gt;(to x: T) -&gt; T
    where T.Stride: ExpressibleByIntegerLiteral
{
    return x.advanced(by: 1)
}

let x = addOne(to: 5)
// x == 6
let y = addOne(to: 3.5)
// y = 4.5
</code></pre>
<p>If this type's <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for a
value <code>x</code>, a distance <code>n</code>, and a value <code>y = x.advanced(by: n)</code>,
<code>x.distance(to: y) == n</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>
<ul>
<li>Parameter n: The distance to advance this value.</li>
</ul>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">public func advanced(by amount: Float80) -> Float80</code></div></div><div id="distance_to-55ea9db2502ccb9247fb4f931340a7ef" class="declaration"><a class="toggle-link" href="#comment-distance_to-55ea9db2502ccb9247fb4f931340a7ef">func distance(to other: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-distance_to-55ea9db2502ccb9247fb4f931340a7ef"><p>Returns the distance from this value to the given value, expressed as a
stride.</p>
<p>If this type's <code>Stride</code> type conforms to <code>BinaryInteger</code>, then for two
values <code>x</code> and <code>y</code>, and a distance <code>n = x.distance(to: y)</code>,
<code>x.advanced(by: n) == y</code>. Using this method with types that have a
noninteger <code>Stride</code> may result in an approximation.</p>
<ul>
<li>Parameter other: The value to calculate the distance to.</li>
</ul>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">public func distance(to other: Float80) -> Float80</code></div></div><div id="formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40" class="declaration"><a class="toggle-link" href="#comment-formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40">func formRemainder(dividingBy other: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40"><p>Replaces this value with the remainder of itself divided by the given
value.</p>
<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>
<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>
<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
x.formRemainder(dividingBy: 0.75)
// x == -0.375

let x1 = 0.75 * q + x
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>formRemainder(dividingBy:)</code> method is always exact.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func formRemainder(dividingBy other: Float80)</code></div></div><div id="formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142" class="declaration"><a class="toggle-link" href="#comment-formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142">func formSquareRoot()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142"><p>Replaces this value with its square root, rounded to a representable
value.</p>
<h4>Declaration</h4><code class="language-swift">public mutating func formSquareRoot()</code></div></div><div id="formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb" class="declaration"><a class="toggle-link" href="#comment-formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb">func formTruncatingRemainder(dividingBy other: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb"><p>Replaces this value with the remainder of itself divided by the given
value using truncating division.</p>
<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>
<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>
<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
x.formTruncatingRemainder(dividingBy: 0.75)
// x == 0.375

let x1 = 0.75 * q + x
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>
method is always exact.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func formTruncatingRemainder(dividingBy other: Float80)</code></div></div><div id="hash_into-6d50cb3daa41162a12fb4542a687b393" class="declaration"><a class="toggle-link" href="#comment-hash_into-6d50cb3daa41162a12fb4542a687b393">func hash(into hasher: inout Hasher)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-hash_into-6d50cb3daa41162a12fb4542a687b393"><p>Hashes the essential components of this value by feeding them into the
given hasher.</p>
<p>Implement this method to conform to the <code>Hashable</code> protocol. The
components used for hashing must be the same as the components compared
in your type's <code>==</code> operator implementation. Call <code>hasher.combine(_:)</code>
with each of these components.</p>
<blockquote>
<p>Important:
Never call <code>finalize()</code> on <code>hasher</code>. Doing so may become a compile-time error in the future.</p>
</blockquote>
<ul>
<li>Parameter hasher: The hasher to use when combining the components
of this instance.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func hash(into hasher: inout Hasher)</code></div></div><div id="isEqual_to-9c853bc759a05cded4f822d60eda686d" class="declaration"><a class="toggle-link" href="#comment-isEqual_to-9c853bc759a05cded4f822d60eda686d">func isEqual(to other: Float80) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isEqual_to-9c853bc759a05cded4f822d60eda686d"><p>Returns a Boolean value indicating whether this instance is equal to the
given value.</p>
<p>This method serves as the basis for the equal-to operator (<code>==</code>) for
floating-point values. When comparing two values with this method, <code>-0</code>
is equal to <code>+0</code>. NaN is not equal to any value, including itself. For
example:</p>
<pre><code class="language-swift">let x = 15.0
x.isEqual(to: 15.0)
// true
x.isEqual(to: .nan)
// false
Double.nan.isEqual(to: .nan)
// false
</code></pre>
<p>The <code>isEqual(to:)</code> method implements the equality predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public func isEqual(to other: Float80) -> Bool</code></div></div><div id="isLess_than-324467f7318bc8547b96c1bbd9e0225e" class="declaration"><a class="toggle-link" href="#comment-isLess_than-324467f7318bc8547b96c1bbd9e0225e">func isLess(than other: Float80) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isLess_than-324467f7318bc8547b96c1bbd9e0225e"><p>Returns a Boolean value indicating whether this instance is less than the
given value.</p>
<p>This method serves as the basis for the less-than operator (<code>&lt;</code>) for
floating-point values. Some special cases apply:</p>
<p>The <code>isLess(than:)</code> method implements the less-than predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public func isLess(than other: Float80) -> Bool</code></div></div><div id="isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402" class="declaration"><a class="toggle-link" href="#comment-isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402">func isLessThanOrEqualTo(_ other: Float80) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402"><p>Returns a Boolean value indicating whether this instance is less than or
equal to the given value.</p>
<p>This method serves as the basis for the less-than-or-equal-to operator
(<code>&lt;=</code>) for floating-point values. Some special cases apply:</p>
<p>The <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal
predicate defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public func isLessThanOrEqualTo(_ other: Float80) -> Bool</code></div></div><div id="isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df" class="declaration"><a class="toggle-link" href="#comment-isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df">func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df"><p>Returns a Boolean value indicating whether this instance should precede
or tie positions with the given value in an ascending sort.</p>
<p>This relation is a refinement of the less-than-or-equal-to operator
(<code>&lt;=</code>) that provides a total order on all values of the type, including
signed zeros and NaNs.</p>
<p>The following example uses <code>isTotallyOrdered(belowOrEqualTo:)</code> to sort an
array of floating-point values, including some that are NaN:</p>
<pre><code class="language-swift">var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
// numbers == [-9.5, 2.5, 3.0, 21.25, NaN]
</code></pre>
<p>The <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order
relation as defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: A floating-point value to compare to this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool</code></div></div><div id="negate-ada771fd0d039b67f84e7cb6b918b531" class="declaration"><a class="toggle-link" href="#comment-negate-ada771fd0d039b67f84e7cb6b918b531">func negate()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-negate-ada771fd0d039b67f84e7cb6b918b531"><p>Replaces this value with its additive inverse.</p>
<p>The result is always exact. This example uses the <code>negate()</code> method to
negate the value of the variable <code>x</code>:</p>
<pre><code class="language-swift">var x = 21.5
x.negate()
// x == -21.5
</code></pre>
<h4>Declaration</h4><code class="language-swift">public mutating func negate()</code></div></div><div id="round-f18d6f018f1e4ca890eaf7d0d66152fd" class="declaration"><a class="toggle-link" href="#comment-round-f18d6f018f1e4ca890eaf7d0d66152fd">func round(_ rule: FloatingPointRoundingRule)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-round-f18d6f018f1e4ca890eaf7d0d66152fd"><p>Rounds the value to an integral value using the specified rounding rule.</p>
<p>The following example rounds a value using four different rounding rules:</p>
<pre><code class="language-swift">// Equivalent to the C 'round' function:
var w = 6.5
w.round(.toNearestOrAwayFromZero)
// w == 7.0

// Equivalent to the C 'trunc' function:
var x = 6.5
x.round(.towardZero)
// x == 6.0

// Equivalent to the C 'ceil' function:
var y = 6.5
y.round(.up)
// y == 7.0

// Equivalent to the C 'floor' function:
var z = 6.5
z.round(.down)
// z == 6.0
</code></pre>
<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method
instead.</p>
<pre><code class="language-swift">var w1 = 6.5
w1.round()
// w1 == 7.0
</code></pre>
<ul>
<li>Parameter rule: The rounding rule to use.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">public mutating func round(_ rule: FloatingPointRoundingRule)</code></div></div><div id="write_to-d457d816b415ff3bee040fb06f595e0f" class="declaration"><a class="toggle-link" href="#comment-write_to-d457d816b415ff3bee040fb06f595e0f">func write(to target: inout Target)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-write_to-d457d816b415ff3bee040fb06f595e0f"><p>Writes a textual representation of this instance into the given output
stream.</p>
<h4>Declaration</h4><code class="language-swift">public func write&lt;Target>(to target: inout Target) where Target: TextOutputStream</code></div></div><h3>Type Variables</h3><div id="exponentBitCount-815cdfd2ce472be44e9d47c04ce83ca1" class="declaration"><a class="toggle-link" href="#comment-exponentBitCount-815cdfd2ce472be44e9d47c04ce83ca1">var exponentBitCount</a> <span class="required">Required</span><div class="comment collapse in" id="comment-exponentBitCount-815cdfd2ce472be44e9d47c04ce83ca1"><p>The number of bits used to represent the type's exponent.</p>
<p>A binary floating-point type's <code>exponentBitCount</code> imposes a limit on the
range of the exponent for normal, finite values. The <em>exponent bias</em> of
a type <code>F</code> can be calculated as the following, where <code>**</code> is
exponentiation:</p>
<pre><code class="language-swift">let bias = 2 ** (F.exponentBitCount - 1) - 1
</code></pre>
<p>The least normal exponent for values of the type <code>F</code> is <code>1 - bias</code>, and
the largest finite exponent is <code>bias</code>. An all-zeros exponent is reserved
for subnormals and zeros, and an all-ones exponent is reserved for
infinity and NaN.</p>
<p>For example, the <code>Float</code> type has an <code>exponentBitCount</code> of 8, which gives
an exponent bias of <code>127</code> by the calculation above.</p>
<pre><code class="language-swift">let bias = 2 ** (Float.exponentBitCount - 1) - 1
// bias == 127
print(Float.greatestFiniteMagnitude.exponent)
// Prints &quot;127&quot;
print(Float.leastNormalMagnitude.exponent)
// Prints &quot;-126&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">var exponentBitCount: Int</code></div></div><div id="greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8" class="declaration"><a class="toggle-link" href="#comment-greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8">var greatestFiniteMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8"><p>The greatest finite number representable by this type.</p>
<p>This value compares greater than or equal to all finite numbers, but less
than <code>infinity</code>.</p>
<p>This value corresponds to type-specific C macros such as <code>FLT_MAX</code> and
<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because
<code>infinity</code> is greater than this value.</p>
<h4>Declaration</h4><code class="language-swift">var greatestFiniteMagnitude: Float80</code></div></div><div id="infinity-f2fdee93271556e428dd9507b3da7235" class="declaration"><a class="toggle-link" href="#comment-infinity-f2fdee93271556e428dd9507b3da7235">var infinity</a> <span class="required">Required</span><div class="comment collapse in" id="comment-infinity-f2fdee93271556e428dd9507b3da7235"><p>Positive infinity.</p>
<p>Infinity compares greater than all finite numbers and equal to other
infinite values.</p>
<pre><code class="language-swift">let x = Double.greatestFiniteMagnitude
let y = x * 2
// y == Double.infinity
// y &gt; x
</code></pre>
<h4>Declaration</h4><code class="language-swift">var infinity: Float80</code></div></div><div id="leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7" class="declaration"><a class="toggle-link" href="#comment-leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7">var leastNonzeroMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7"><p>The least positive number.</p>
<p>This value compares less than or equal to all positive numbers, but
greater than zero. If the type supports subnormal values,
<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;
otherwise they are equal.</p>
<h4>Declaration</h4><code class="language-swift">var leastNonzeroMagnitude: Float80</code></div></div><div id="leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22" class="declaration"><a class="toggle-link" href="#comment-leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22">var leastNormalMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22"><p>The least positive normal number.</p>
<p>This value compares less than or equal to all positive normal numbers.
There may be smaller positive numbers, but they are <em>subnormal</em>, meaning
that they are represented with less precision than normal numbers.</p>
<p>This value corresponds to type-specific C macros such as <code>FLT_MIN</code> and
<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because
subnormals, zeros, and negative numbers are smaller than this value.</p>
<h4>Declaration</h4><code class="language-swift">var leastNormalMagnitude: Float80</code></div></div><div id="nan-a3d2de7675556553a5f08e4c88d2c228" class="declaration"><a class="toggle-link" href="#comment-nan-a3d2de7675556553a5f08e4c88d2c228">var nan</a> <span class="required">Required</span><div class="comment collapse in" id="comment-nan-a3d2de7675556553a5f08e4c88d2c228"><p>A quiet NaN (&quot;not a number&quot;).</p>
<p>A NaN compares not equal, not greater than, and not less than every
value, including itself. Passing a NaN to an operation generally results
in NaN.</p>
<pre><code class="language-swift">let x = 1.21
// x &gt; Double.nan == false
// x &lt; Double.nan == false
// x == Double.nan == false
</code></pre>
<p>Because a NaN always compares not equal to itself, to test whether a
floating-point value is NaN, use its <code>isNaN</code> property instead of the
equal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.</p>
<pre><code class="language-swift">let y = x + Double.nan
print(y == Double.nan)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">var nan: Float80</code></div></div><div id="pi-72ab8af56bddab33b269c5964b26620a" class="declaration"><a class="toggle-link" href="#comment-pi-72ab8af56bddab33b269c5964b26620a">var pi</a> <span class="required">Required</span><div class="comment collapse in" id="comment-pi-72ab8af56bddab33b269c5964b26620a"><p>The mathematical constant pi.</p>
<p>This value should be rounded toward zero to keep user computations with
angles from inadvertently ending up in the wrong quadrant. A type that
conforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at
its best possible precision.</p>
<pre><code class="language-swift">print(Double.pi)
// Prints &quot;3.14159265358979&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">var pi: Float80</code></div></div><div id="radix-be4ecdb8a8ebc5a7a7740d21d2b71462" class="declaration"><a class="toggle-link" href="#comment-radix-be4ecdb8a8ebc5a7a7740d21d2b71462">var radix</a> <span class="required">Required</span><div class="comment collapse in" id="comment-radix-be4ecdb8a8ebc5a7a7740d21d2b71462"><p>The radix, or base of exponentiation, for a floating-point type.</p>
<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>A conforming type may use any integer radix, but values other than 2 (for
binary floating-point types) or 10 (for decimal floating-point types)
are extraordinarily rare in practice.</p>
<h4>Declaration</h4><code class="language-swift">var radix: Int</code></div></div><div id="signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc" class="declaration"><a class="toggle-link" href="#comment-signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc">var signalingNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc"><p>A signaling NaN (&quot;not a number&quot;).</p>
<p>The default IEEE 754 behavior of operations involving a signaling NaN is
to raise the Invalid flag in the floating-point environment and return a
quiet NaN.</p>
<p>Operations on types conforming to the <code>FloatingPoint</code> protocol should
support this behavior, but they might also support other options. For
example, it would be reasonable to implement alternative operations in
which operating on a signaling NaN triggers a runtime error or results
in a diagnostic for debugging purposes. Types that implement alternative
behaviors for a signaling NaN must document the departure.</p>
<p>Other than these signaling operations, a signaling NaN behaves in the
same manner as a quiet NaN.</p>
<h4>Declaration</h4><code class="language-swift">var signalingNaN: Float80</code></div></div><div id="significandBitCount-4031c18da0242aa9e2149c9f09a21d07" class="declaration"><a class="toggle-link" href="#comment-significandBitCount-4031c18da0242aa9e2149c9f09a21d07">var significandBitCount</a> <span class="required">Required</span><div class="comment collapse in" id="comment-significandBitCount-4031c18da0242aa9e2149c9f09a21d07"><p>The available number of fractional significand bits.</p>
<p>For fixed-width floating-point types, this is the actual number of
fractional significand bits.</p>
<p>For extensible floating-point types, <code>significandBitCount</code> should be the
maximum allowed significand width (without counting any leading integral
bit of the significand). If there is no upper limit, then
<code>significandBitCount</code> should be <code>Int.max</code>.</p>
<p>Note that <code>Float80.significandBitCount</code> is 63, even though 64 bits are
used to store the significand in the memory representation of a
<code>Float80</code> (unlike other floating-point types, <code>Float80</code> explicitly
stores the leading integral significand bit, but the
<code>BinaryFloatingPoint</code> APIs provide an abstraction so that users don't
need to be aware of this detail).</p>
<h4>Declaration</h4><code class="language-swift">var significandBitCount: Int</code></div></div><div id="ulpOfOne-c793570339d0de8d802fbd69ee826318" class="declaration"><a class="toggle-link" href="#comment-ulpOfOne-c793570339d0de8d802fbd69ee826318">var ulpOfOne</a> <span class="required">Required</span><div class="comment collapse in" id="comment-ulpOfOne-c793570339d0de8d802fbd69ee826318"><p>The unit in the last place of 1.0.</p>
<p>The positive difference between 1.0 and the next greater representable
number. The <code>ulpOfOne</code> constant corresponds to the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, and others with a similar purpose.</p>
<h4>Declaration</h4><code class="language-swift">var ulpOfOne: Float80</code></div></div><h3>Type Methods</h3><div id="lhs_rhs-471d936295383220ce00ec7c8a571f42" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-471d936295383220ce00ec7c8a571f42">func *(lhs: Float80, rhs: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-471d936295383220ce00ec7c8a571f42"><p>Multiplies two values and produces their product, rounding to a
representable value.</p>
<p>The multiplication operator (<code>*</code>) calculates the product of its two
arguments. For example:</p>
<pre><code class="language-swift">let x = 7.5
let y = x * 2.25
// y == 16.875
</code></pre>
<p>The <code>*</code> operator implements the multiplication operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">public static func *(lhs: Float80, rhs: Float80) -> Float80</code></div></div><div id="lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb">func *=(lhs: inout Float80, rhs: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb"><p>Multiplies two values and stores the result in the left-hand-side
variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">public static func *=(lhs: inout Float80, rhs: Float80)</code></div></div><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: Float80, rhs: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><p>Adds two values and produces their sum, rounded to a
representable value.</p>
<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>
<pre><code class="language-swift">let x = 1.5
let y = x + 2.25
// y == 3.75
</code></pre>
<p>The <code>+</code> operator implements the addition operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">public static func +(lhs: Float80, rhs: Float80) -> Float80</code></div></div><div id="lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb">func +=(lhs: inout Float80, rhs: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb"><p>Adds two values and stores the result in the left-hand-side variable,
rounded to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">public static func +=(lhs: inout Float80, rhs: Float80)</code></div></div><div id="lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde">func -(lhs: Float80, rhs: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde"><p>Subtracts one value from another and produces their difference, rounded
to a representable value.</p>
<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>
<pre><code class="language-swift">let x = 7.5
let y = x - 2.25
// y == 5.25
</code></pre>
<p>The <code>-</code> operator implements the subtraction operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">public static func -(lhs: Float80, rhs: Float80) -> Float80</code></div></div><div id="x-13fa3d2563d82559ba86288fbc2f832f" class="declaration"><a class="toggle-link" href="#comment-x-13fa3d2563d82559ba86288fbc2f832f">func -(x: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-x-13fa3d2563d82559ba86288fbc2f832f"><p>Calculates the additive inverse of a value.</p>
<p>The unary minus operator (prefix <code>-</code>) calculates the negation of its
operand. The result is always exact.</p>
<pre><code class="language-swift">let x = 21.5
let y = -x
// y == -21.5
</code></pre>
<ul>
<li>Parameter operand: The value to negate.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">prefix public static func -(x: Float80) -> Float80</code></div></div><div id="lhs_rhs-265a6353740687d540f523762f8cf760" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-265a6353740687d540f523762f8cf760">func -=(lhs: inout Float80, rhs: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-265a6353740687d540f523762f8cf760"><p>Subtracts the second value from the first and stores the difference in
the left-hand-side variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">public static func -=(lhs: inout Float80, rhs: Float80)</code></div></div><div id="lhs_rhs-8d3e01dd5aadf72b5d7233c057966993" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-8d3e01dd5aadf72b5d7233c057966993">func /(lhs: Float80, rhs: Float80) -> Float80</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-8d3e01dd5aadf72b5d7233c057966993"><p>Returns the quotient of dividing the first value by the second, rounded
to a representable value.</p>
<p>The division operator (<code>/</code>) calculates the quotient of the division if
<code>rhs</code> is nonzero. If <code>rhs</code> is zero, the result of the division is
infinity, with the sign of the result matching the sign of <code>lhs</code>.</p>
<pre><code class="language-swift">let x = 16.875
let y = x / 2.25
// y == 7.5

let z = x / 0
// z.isInfinite == true
</code></pre>
<p>The <code>/</code> operator implements the division operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">public static func /(lhs: Float80, rhs: Float80) -> Float80</code></div></div><div id="lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d">func /=(lhs: inout Float80, rhs: Float80)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d"><p>Divides the first value by the second and stores the quotient in the
left-hand-side variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">public static func /=(lhs: inout Float80, rhs: Float80)</code></div></div><div id="x_y-4804d4748c34357d4373b49c8403cd1d" class="declaration"><a class="toggle-link" href="#comment-x_y-4804d4748c34357d4373b49c8403cd1d">func &lt;(x: Self, y: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-x_y-4804d4748c34357d4373b49c8403cd1d"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func &lt;(x: Self, y: Self) -> Bool</code></div></div><div id="x_y-41595b3223e387ce1a31eb3ce917dcca" class="declaration"><a class="toggle-link" href="#comment-x_y-41595b3223e387ce1a31eb3ce917dcca">func ==(x: Self, y: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-x_y-41595b3223e387ce1a31eb3ce917dcca"><p>Returns a Boolean value indicating whether two values are equal.</p>
<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func ==(x: Self, y: Self) -> Bool</code></div></div>