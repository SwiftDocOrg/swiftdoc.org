---
layout: "default"
title: "Array"
description: "Swift documentation for 'Array'"
root: "/v5.1"
keywords: ""
---

<div class="intro-declaration"><code class="language-swift">struct Array</code></div><p>An ordered, random-access collection.</p>
<table class="standard"><tr><th id="inheritance">Inheritance</th><td><code class="inherits">CustomDebugStringConvertible, CustomReflectable, CustomStringConvertible, ExpressibleByArrayLiteral, MutableCollection, RandomAccessCollection, RangeReplaceableCollection</code></td></tr><tr><th id="aliases">Associated Types</th><td><span id="aliasesmark"></span><div class="declaration"><code class="language-swift">public typealias Index = Int</code><div class="comment"></div></div><div class="declaration"><code class="language-swift">public typealias Indices = Range&lt;Int></code><div class="comment"></div></div><div class="declaration"><code class="language-swift">public typealias Iterator = IndexingIterator&lt;[Element]></code><div class="comment"></div></div></td></tr></table><div class="discussion comment"><p>Arrays are one of the most commonly used data types in an app. You use
arrays to organize your app's data. Specifically, you use the <code>Array</code> type
to hold elements of a single type, the array's <code>Element</code> type. An array
can store any kind of elements---from integers to strings to classes.</p>
<p>Swift makes it easy to create arrays in your code using an array literal:
simply surround a comma-separated list of values with square brackets.
Without any other information, Swift creates an array that includes the
specified values, automatically inferring the array's <code>Element</code> type. For
example:</p>
<pre><code class="language-swift">// An array of 'Int' elements
let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]

// An array of 'String' elements
let streets = [&quot;Albemarle&quot;, &quot;Brandywine&quot;, &quot;Chesapeake&quot;]
</code></pre>
<p>You can create an empty array by specifying the <code>Element</code> type of your
array in the declaration. For example:</p>
<pre><code class="language-swift">// Shortened forms are preferred
var emptyDoubles: [Double] = []

// The full type name is also allowed
var emptyFloats: Array&lt;Float&gt; = Array()
</code></pre>
<p>If you need an array that is preinitialized with a fixed number of default
values, use the <code>Array(repeating:count:)</code> initializer.</p>
<pre><code class="language-swift">var digitCounts = Array(repeating: 0, count: 10)
print(digitCounts)
// Prints &quot;[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]&quot;
</code></pre>
<h3>Accessing Array Values</h3>
<p>When you need to perform an operation on all of an array's elements, use a
<code>for</code>-<code>in</code> loop to iterate through the array's contents.</p>
<pre><code class="language-swift">for street in streets {
    print(&quot;I don't live on \(street).&quot;)
}
// Prints &quot;I don't live on Albemarle.&quot;
// Prints &quot;I don't live on Brandywine.&quot;
// Prints &quot;I don't live on Chesapeake.&quot;
</code></pre>
<p>Use the <code>isEmpty</code> property to check quickly whether an array has any
elements, or use the <code>count</code> property to find the number of elements in
the array.</p>
<pre><code class="language-swift">if oddNumbers.isEmpty {
    print(&quot;I don't know any odd numbers.&quot;)
} else {
    print(&quot;I know \(oddNumbers.count) odd numbers.&quot;)
}
// Prints &quot;I know 8 odd numbers.&quot;
</code></pre>
<p>Use the <code>first</code> and <code>last</code> properties for safe access to the value of the
array's first and last elements. If the array is empty, these properties
are <code>nil</code>.</p>
<pre><code class="language-swift">if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {
    print(firstElement, lastElement, separator: &quot;, &quot;)
}
// Prints &quot;1, 15&quot;

print(emptyDoubles.first, emptyDoubles.last, separator: &quot;, &quot;)
// Prints &quot;nil, nil&quot;
</code></pre>
<p>You can access individual array elements through a subscript. The first
element of a nonempty array is always at index zero. You can subscript an
array with any integer from zero up to, but not including, the count of
the array. Using a negative number or an index equal to or greater than
<code>count</code> triggers a runtime error. For example:</p>
<pre><code class="language-swift">print(oddNumbers[0], oddNumbers[3], separator: &quot;, &quot;)
// Prints &quot;1, 7&quot;

print(emptyDoubles[0])
// Triggers runtime error: Index out of range
</code></pre>
<h3>Adding and Removing Elements</h3>
<p>Suppose you need to store a list of the names of students that are signed
up for a class you're teaching. During the registration period, you need
to add and remove names as students add and drop the class.</p>
<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;]
</code></pre>
<p>To add single elements to the end of an array, use the <code>append(_:)</code> method.
Add multiple elements at the same time by passing another array or a
sequence of any kind to the <code>append(contentsOf:)</code> method.</p>
<pre><code class="language-swift">students.append(&quot;Maxime&quot;)
students.append(contentsOf: [&quot;Shakia&quot;, &quot;William&quot;])
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]
</code></pre>
<p>You can add new elements in the middle of an array by using the
<code>insert(_:at:)</code> method for single elements and by using
<code>insert(contentsOf:at:)</code> to insert multiple elements from another
collection or array literal. The elements at that index and later indices
are shifted back to make room.</p>
<pre><code class="language-swift">students.insert(&quot;Liam&quot;, at: 3)
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]
</code></pre>
<p>To remove elements from an array, use the <code>remove(at:)</code>,
<code>removeSubrange(_:)</code>, and <code>removeLast()</code> methods.</p>
<pre><code class="language-swift">// Ben's family is moving to another state
students.remove(at: 0)
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]

// William is signing up for a different class
students.removeLast()
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;]
</code></pre>
<p>You can replace an existing element with a new value by assigning the new
value to the subscript.</p>
<pre><code class="language-swift">if let i = students.firstIndex(of: &quot;Maxime&quot;) {
    students[i] = &quot;Max&quot;
}
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Max&quot;, &quot;Shakia&quot;]
</code></pre>
<h4>Growing the Size of an Array</h4>
<p>Every array reserves a specific amount of memory to hold its contents. When
you add elements to an array and that array begins to exceed its reserved
capacity, the array allocates a larger region of memory and copies its
elements into the new storage. The new storage is a multiple of the old
storage's size. This exponential growth strategy means that appending an
element happens in constant time, averaging the performance of many append
operations. Append operations that trigger reallocation have a performance
cost, but they occur less and less often as the array grows larger.</p>
<p>If you know approximately how many elements you will need to store, use the
<code>reserveCapacity(_:)</code> method before appending to the array to avoid
intermediate reallocations. Use the <code>capacity</code> and <code>count</code> properties to
determine how many more elements the array can store without allocating
larger storage.</p>
<p>For arrays of most <code>Element</code> types, this storage is a contiguous block of
memory. For arrays with an <code>Element</code> type that is a class or <code>@objc</code>
protocol type, this storage can be a contiguous block of memory or an
instance of <code>NSArray</code>. Because any arbitrary subclass of <code>NSArray</code> can
become an <code>Array</code>, there are no guarantees about representation or
efficiency in this case.</p>
<h3>Modifying Copies of Arrays</h3>
<p>Each array has an independent value that includes the values of all of its
elements. For simple types such as integers and other structures, this
means that when you change a value in one array, the value of that element
does not change in any copies of the array. For example:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var numbersCopy = numbers
numbers[0] = 100
print(numbers)
// Prints &quot;[100, 2, 3, 4, 5]&quot;
print(numbersCopy)
// Prints &quot;[1, 2, 3, 4, 5]&quot;
</code></pre>
<p>If the elements in an array are instances of a class, the semantics are the
same, though they might appear different at first. In this case, the
values stored in the array are references to objects that live outside the
array. If you change a reference to an object in one array, only that
array has a reference to the new object. However, if two arrays contain
references to the same object, you can observe changes to that object's
properties from both arrays. For example:</p>
<pre><code class="language-swift">// An integer type with reference semantics
class IntegerReference {
    var value = 10
}
var firstIntegers = [IntegerReference(), IntegerReference()]
var secondIntegers = firstIntegers

// Modifications to an instance are visible from either array
firstIntegers[0].value = 100
print(secondIntegers[0].value)
// Prints &quot;100&quot;

// Replacements, additions, and removals are still visible
// only in the modified array
firstIntegers[0] = IntegerReference()
print(firstIntegers[0].value)
// Prints &quot;10&quot;
print(secondIntegers[0].value)
// Prints &quot;100&quot;
</code></pre>
<p>Arrays, like all variable-size collections in the standard library, use
copy-on-write optimization. Multiple copies of an array share the same
storage until you modify one of the copies. When that happens, the array
being modified replaces its storage with a uniquely owned copy of itself,
which is then modified in place. Optimizations are sometimes applied that
can reduce the amount of copying.</p>
<p>This means that if an array is sharing storage with other copies, the first
mutating operation on that array incurs the cost of copying the array. An
array that is the sole owner of its storage can perform mutating
operations in place.</p>
<p>In the example below, a <code>numbers</code> array is created along with two copies
that share the same storage. When the original <code>numbers</code> array is
modified, it makes a unique copy of its storage before making the
modification. Further modifications to <code>numbers</code> are made in place, while
the two copies continue to share the original storage.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var firstCopy = numbers
var secondCopy = numbers

// The storage for 'numbers' is copied here
numbers[0] = 100
numbers[1] = 200
numbers[2] = 300
// 'numbers' is [100, 200, 300, 4, 5]
// 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]
</code></pre>
<h3>Bridging Between Array and NSArray</h3>
<p>When you need to access APIs that require data in an <code>NSArray</code> instance
instead of <code>Array</code>, use the type-cast operator (<code>as</code>) to bridge your
instance. For bridging to be possible, the <code>Element</code> type of your array
must be a class, an <code>@objc</code> protocol (a protocol imported from Objective-C
or marked with the <code>@objc</code> attribute), or a type that bridges to a
Foundation type.</p>
<p>The following example shows how you can bridge an <code>Array</code> instance to
<code>NSArray</code> to use the <code>write(to:atomically:)</code> method. In this example, the
<code>colors</code> array can be bridged to <code>NSArray</code> because the <code>colors</code> array's
<code>String</code> elements bridge to <code>NSString</code>. The compiler prevents bridging the
<code>moreColors</code> array, on the other hand, because its <code>Element</code> type is
<code>Optional&lt;String&gt;</code>, which does <em>not</em> bridge to a Foundation type.</p>
<pre><code class="language-swift">let colors = [&quot;periwinkle&quot;, &quot;rose&quot;, &quot;moss&quot;]
let moreColors: [String?] = [&quot;ochre&quot;, &quot;pine&quot;]

let url = NSURL(fileURLWithPath: &quot;names.plist&quot;)
(colors as NSArray).write(to: url, atomically: true)
// true

(moreColors as NSArray).write(to: url, atomically: true)
// error: cannot convert value of type '[String?]' to type 'NSArray'
</code></pre>
<p>Bridging from <code>Array</code> to <code>NSArray</code> takes O(1) time and O(1) space if the
array's elements are already instances of a class or an <code>@objc</code> protocol;
otherwise, it takes O(<em>n</em>) time and space.</p>
<p>When the destination array's element type is a class or an <code>@objc</code>
protocol, bridging from <code>NSArray</code> to <code>Array</code> first calls the <code>copy(with:)</code>
(<code>- copyWithZone:</code> in Objective-C) method on the array to get an immutable
copy and then performs additional Swift bookkeeping work that takes O(1)
time. For instances of <code>NSArray</code> that are already immutable, <code>copy(with:)</code>
usually returns the same array in O(1) time; otherwise, the copying
performance is unspecified. If <code>copy(with:)</code> returns the same array, the
instances of <code>NSArray</code> and <code>Array</code> share storage using the same
copy-on-write optimization that is used when two instances of <code>Array</code>
share storage.</p>
<p>When the destination array's element type is a nonclass type that bridges
to a Foundation type, bridging from <code>NSArray</code> to <code>Array</code> performs a
bridging copy of the elements to contiguous storage in O(<em>n</em>) time. For
example, bridging from <code>NSArray</code> to <code>Array&lt;Int&gt;</code> performs such a copy. No
further bridging is required when accessing elements of the <code>Array</code>
instance.</p>
<blockquote>
<p>Note:
The <code>ContiguousArray</code> and <code>ArraySlice</code> types are not bridged; instances of those types always have a contiguous block of memory as their storage.</p>
</blockquote>
</div><h3>Initializers</h3><div id="init-e67906ab4373125a18eb2b5a75f59bd2" class="declaration"><a class="toggle-link" href="#comment-init-e67906ab4373125a18eb2b5a75f59bd2">init init()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-e67906ab4373125a18eb2b5a75f59bd2"><p>Creates a new, empty array.</p>
<p>This is equivalent to initializing with an empty array literal.
For example:</p>
<pre><code class="language-swift">var emptyArray = Array&lt;Int&gt;()
print(emptyArray.isEmpty)
// Prints &quot;true&quot;

emptyArray = []
print(emptyArray.isEmpty)
// Prints &quot;true&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">@inlinable public init()</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new instance of a collection containing the elements of a
sequence.</p>
<ul>
<li>Parameter elements: The sequence of elements for the new collection.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init&lt;S>(_ elements: S) where S: Sequence, Self.Element == S.Element</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates an array containing the elements of a sequence.</p>
<p>You can use this initializer to create an array from any other type that
conforms to the <code>Sequence</code> protocol. For example, you might want to
create an array with the integers from 1 through 7. Use this initializer
around a range instead of typing all those numbers in an array literal.</p>
<pre><code class="language-swift">let numbers = Array(1...7)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 6, 7]&quot;
</code></pre>
<p>You can also use this initializer to convert a complex sequence or
collection type back to an array. For example, the <code>keys</code> property of
a dictionary isn't an array with its own storage, it's a collection
that maps its elements from the dictionary only when they're
accessed, saving the time and space needed to allocate an array. If
you need to pass those keys to a method that takes an array, however,
use this initializer to convert that list from its type of
<code>LazyMapCollection&lt;Dictionary&lt;String, Int&gt;, Int&gt;</code> to a simple
<code>[String]</code>.</p>
<pre><code class="language-swift">func cacheImagesWithNames(names: [String]) {
    // custom image loading and caching
 }

let namedHues: [String: Int] = [&quot;Vermillion&quot;: 18, &quot;Magenta&quot;: 302,
        &quot;Gold&quot;: 50, &quot;Cerise&quot;: 320]
let colorNames = Array(namedHues.keys)
cacheImagesWithNames(colorNames)

print(colorNames)
// Prints &quot;[&quot;Gold&quot;, &quot;Cerise&quot;, &quot;Magenta&quot;, &quot;Vermillion&quot;]&quot;
</code></pre>
<ul>
<li>Parameter s: The sequence of elements to turn into an array.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init&lt;S>(_ s: S) where Element == S.Element, S: Sequence</code></div></div><div id="init_arrayLiteral-122bf8141cc945de0f292024b4f08315" class="declaration"><a class="toggle-link" href="#comment-init_arrayLiteral-122bf8141cc945de0f292024b4f08315">init init(arrayLiteral:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_arrayLiteral-122bf8141cc945de0f292024b4f08315"><p>Creates an array from the given array literal.</p>
<p>Do not call this initializer directly. It is used by the compiler
when you use an array literal. Instead, create a new array by using an
array literal as its value. To do this, enclose a comma-separated list of
values in square brackets.</p>
<p>Here, an array of strings is created from an array literal holding
only strings.</p>
<pre><code class="language-swift">let ingredients = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]
</code></pre>
<ul>
<li>Parameter elements: A variadic list of elements of the new array.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(arrayLiteral elements: Element)</code></div></div><div id="init_repeating_count-386429a7befa4cc7818e4639b5637091" class="declaration"><a class="toggle-link" href="#comment-init_repeating_count-386429a7befa4cc7818e4639b5637091">init init(repeating:count:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_repeating_count-386429a7befa4cc7818e4639b5637091"><p>Creates a new collection containing the specified number of a single,
repeated value.</p>
<p>Here's an example of creating an array initialized with five strings
containing the letter <em>Z</em>.</p>
<pre><code class="language-swift">let fiveZs = Array(repeating: &quot;Z&quot;, count: 5)
print(fiveZs)
// Prints &quot;[&quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;]&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(repeating repeatedValue: Self.Element, count: Int)</code></div></div><div id="init_repeating_count-386429a7befa4cc7818e4639b5637091" class="declaration"><a class="toggle-link" href="#comment-init_repeating_count-386429a7befa4cc7818e4639b5637091">init init(repeating:count:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_repeating_count-386429a7befa4cc7818e4639b5637091"><p>Creates a new array containing the specified number of a single, repeated
value.</p>
<p>Here's an example of creating an array initialized with five strings
containing the letter <em>Z</em>.</p>
<pre><code class="language-swift">let fiveZs = Array(repeating: &quot;Z&quot;, count: 5)
print(fiveZs)
// Prints &quot;[&quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;]&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(repeating repeatedValue: Element, count: Int)</code></div></div><div id="init_unsafeUninitializedCapacity_initializingWith-9d38b9cf9567303da96da98fd5a69641" class="declaration"><a class="toggle-link" href="#comment-init_unsafeUninitializedCapacity_initializingWith-9d38b9cf9567303da96da98fd5a69641">init init(unsafeUninitializedCapacity:initializingWith:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_unsafeUninitializedCapacity_initializingWith-9d38b9cf9567303da96da98fd5a69641"><p>Creates an array with the specified capacity, then calls the given
closure with a buffer covering the array's uninitialized memory.</p>
<p>Inside the closure, set the <code>initializedCount</code> parameter to the number of
elements that are initialized by the closure. The memory in the range
<code>buffer[0..&lt;initializedCount]</code> must be initialized at the end of the
closure's execution, and the memory in the range
<code>buffer[initializedCount...]</code> must be uninitialized. This postcondition
must hold even if the <code>initializer</code> closure throws an error.</p>
<blockquote>
<p>Note:
While the resulting array may have a capacity larger than the requested amount, the buffer passed to the closure will cover exactly the requested number of elements.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public init(unsafeUninitializedCapacity: Int, initializingWith initializer: (inout UnsafeMutableBufferPointer&lt;Element>, inout Int) throws -> Void) rethrows</code></div></div><h3>Instance Variables</h3><div id="capacity-7bd14a231864e618e1840c7e117e59c1" class="declaration"><a class="toggle-link" href="#comment-capacity-7bd14a231864e618e1840c7e117e59c1">var capacity</a> <span class="required">Required</span><div class="comment collapse in" id="comment-capacity-7bd14a231864e618e1840c7e117e59c1"><p>The total number of elements that the array can contain without
allocating new storage.</p>
<p>Every array reserves a specific amount of memory to hold its contents.
When you add elements to an array and that array begins to exceed its
reserved capacity, the array allocates a larger region of memory and
copies its elements into the new storage. The new storage is a multiple
of the old storage's size. This exponential growth strategy means that
appending an element happens in constant time, averaging the performance
of many append operations. Append operations that trigger reallocation
have a performance cost, but they occur less and less often as the array
grows larger.</p>
<p>The following example creates an array of integers from an array literal,
then appends the elements of another collection. Before appending, the
array allocates new storage that is large enough store the resulting
elements.</p>
<pre><code class="language-swift">var numbers = [10, 20, 30, 40, 50]
// numbers.count == 5
// numbers.capacity == 5

numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
// numbers.count == 10
// numbers.capacity == 12
</code></pre>
<h4>Declaration</h4><code class="language-swift">var capacity: Int</code></div></div><div id="count-e2942a04780e223b215eb8b663cf5353" class="declaration"><a class="toggle-link" href="#comment-count-e2942a04780e223b215eb8b663cf5353">var count</a> <span class="required">Required</span><div class="comment collapse in" id="comment-count-e2942a04780e223b215eb8b663cf5353"><p>The number of elements in the array.</p>
<h4>Declaration</h4><code class="language-swift">var count: Int</code></div></div><div id="customMirror-c4bea5adb1649887b1a7e9972736e2a9" class="declaration"><a class="toggle-link" href="#comment-customMirror-c4bea5adb1649887b1a7e9972736e2a9">var customMirror</a> <span class="required">Required</span><div class="comment collapse in" id="comment-customMirror-c4bea5adb1649887b1a7e9972736e2a9"><p>A mirror that reflects the array.</p>
<h4>Declaration</h4><code class="language-swift">var customMirror: Mirror</code></div></div><div id="debugDescription-15dc1a07010ea28e38b1f4d74663fe11" class="declaration"><a class="toggle-link" href="#comment-debugDescription-15dc1a07010ea28e38b1f4d74663fe11">var debugDescription</a> <span class="required">Required</span><div class="comment collapse in" id="comment-debugDescription-15dc1a07010ea28e38b1f4d74663fe11"><p>A textual representation of the array and its elements, suitable for
debugging.</p>
<h4>Declaration</h4><code class="language-swift">var debugDescription: String</code></div></div><div id="description-67daf92c833c41c95db874e18fcb2786" class="declaration"><a class="toggle-link" href="#comment-description-67daf92c833c41c95db874e18fcb2786">var description</a> <span class="required">Required</span><div class="comment collapse in" id="comment-description-67daf92c833c41c95db874e18fcb2786"><p>A textual representation of the array and its elements.</p>
<h4>Declaration</h4><code class="language-swift">var description: String</code></div></div><div id="endIndex-6c7c6ecf23a364eb2ec70b77c92e7a4e" class="declaration"><a class="toggle-link" href="#comment-endIndex-6c7c6ecf23a364eb2ec70b77c92e7a4e">var endIndex</a> <span class="required">Required</span><div class="comment collapse in" id="comment-endIndex-6c7c6ecf23a364eb2ec70b77c92e7a4e"><p>The array's &quot;past the end&quot; position---that is, the position one greater
than the last valid subscript argument.</p>
<p>When you need a range that includes the last element of an array, use the
half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator
creates a range that doesn't include the upper bound, so it's always
safe to use with <code>endIndex</code>. For example:</p>
<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let i = numbers.firstIndex(of: 30) {
    print(numbers[i ..&lt; numbers.endIndex])
}
// Prints &quot;[30, 40, 50]&quot;
</code></pre>
<p>If the array is empty, <code>endIndex</code> is equal to <code>startIndex</code>.</p>
<h4>Declaration</h4><code class="language-swift">var endIndex: Int</code></div></div><div id="startIndex-04d77ddd9c9389cc56939726d3da8089" class="declaration"><a class="toggle-link" href="#comment-startIndex-04d77ddd9c9389cc56939726d3da8089">var startIndex</a> <span class="required">Required</span><div class="comment collapse in" id="comment-startIndex-04d77ddd9c9389cc56939726d3da8089"><p>The position of the first element in a nonempty array.</p>
<p>For an instance of <code>Array</code>, <code>startIndex</code> is always zero. If the array
is empty, <code>startIndex</code> is equal to <code>endIndex</code>.</p>
<h4>Declaration</h4><code class="language-swift">var startIndex: Int</code></div></div><h3>Subscripts</h3><div id="subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493" class="declaration"><a class="toggle-link" href="#comment-subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493">subscript subscript(bounds:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493"><p>Accesses a contiguous subrange of the collection's elements.</p>
<p>The accessed slice uses the same indices for the same elements as the
original collection. Always use the slice's <code>startIndex</code> property
instead of assuming that its indices start at a particular value.</p>
<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>
<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let index = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
streets[index!] = &quot;Eustace&quot;
print(streets[index!])
// Prints &quot;Eustace&quot;
</code></pre>
<ul>
<li>Parameter bounds: A range of the collection's indices. The bounds of
the range must be valid indices of the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public subscript(bounds: Range&lt;Self.Index>) -> Slice&lt;Self></code></div></div><div id="subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493" class="declaration"><a class="toggle-link" href="#comment-subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493">subscript subscript(bounds:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-subscript_bounds-788086fb8ff4edc0aa2bd3c41f362493"><p>Accesses a contiguous subrange of the array's elements.</p>
<p>The returned <code>ArraySlice</code> instance uses the same indices for the same
elements as the original array. In particular, that slice, unlike an
array, may have a nonzero <code>startIndex</code> and an <code>endIndex</code> that is not
equal to <code>count</code>. Always use the slice's <code>startIndex</code> and <code>endIndex</code>
properties instead of assuming that its indices start or end at a
particular value.</p>
<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>
<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let i = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
print(streets[i!])
// Prints &quot;Evarts&quot;
</code></pre>
<ul>
<li>Parameter bounds: A range of integers. The bounds of the range must be
valid indices of the array.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public subscript(bounds: Range&lt;Int>) -> ArraySlice&lt;Element></code></div></div><div id="subscript_index-293ad0a56dee4ecca71b95ccc73897e9" class="declaration"><a class="toggle-link" href="#comment-subscript_index-293ad0a56dee4ecca71b95ccc73897e9">subscript subscript(index:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-subscript_index-293ad0a56dee4ecca71b95ccc73897e9"><p>Accesses the element at the specified position.</p>
<p>The following example uses indexed subscripting to update an array's
second element. After assigning the new value (<code>&quot;Butler&quot;</code>) at a specific
position, that value is immediately available at that same position.</p>
<pre><code class="language-swift">var streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
streets[1] = &quot;Butler&quot;
print(streets[1])
// Prints &quot;Butler&quot;
</code></pre>
<ul>
<li>Parameter index: The position of the element to access. <code>index</code> must be
greater than or equal to <code>startIndex</code> and less than <code>endIndex</code>.</li>
</ul>
<blockquote>
<p>Complexity:
Reading an element from an array is O(1). Writing is O(1) unless the array's storage is shared with another array or uses a bridged <code>NSArray</code> instance as its storage, in which case writing is O(<em>n</em>), where <em>n</em> is the length of the array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public subscript(index: Int) -> Element</code></div></div><div id="subscript_r-466c73e996c8d896f1c6a25f9add8052" class="declaration"><a class="toggle-link" href="#comment-subscript_r-466c73e996c8d896f1c6a25f9add8052">subscript subscript(r:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-subscript_r-466c73e996c8d896f1c6a25f9add8052"><h4>Declaration</h4><code class="language-swift">@inlinable public subscript&lt;R>(r: R) where R: RangeExpression, Self.Index == R.Bound -> Self.SubSequence</code></div></div><div id="subscript_x-1b251887405ca8ce324c4bcc9f09a96e" class="declaration"><a class="toggle-link" href="#comment-subscript_x-1b251887405ca8ce324c4bcc9f09a96e">subscript subscript(x:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-subscript_x-1b251887405ca8ce324c4bcc9f09a96e"><h4>Declaration</h4><code class="language-swift">@inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence</code></div></div><h3>Instance Methods</h3><div id="append-1fd0af8599f8632e7a2669725979f22c" class="declaration"><a class="toggle-link" href="#comment-append-1fd0af8599f8632e7a2669725979f22c">func append(_ newElement: Self.Element)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-append-1fd0af8599f8632e7a2669725979f22c"><p>Adds an element to the end of the collection.</p>
<p>If the collection does not have sufficient capacity for another element,
additional storage is allocated before appending <code>newElement</code>. The
following example adds a new number to an array of integers:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(100)

print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 100]&quot;
</code></pre>
<ul>
<li>Parameter newElement: The element to append to the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(1) on average, over many calls to <code>append(_:)</code> on the same collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func append(_ newElement: Self.Element)</code></div></div><div id="append-1fd0af8599f8632e7a2669725979f22c" class="declaration"><a class="toggle-link" href="#comment-append-1fd0af8599f8632e7a2669725979f22c">func append(_ newElement: Element)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-append-1fd0af8599f8632e7a2669725979f22c"><p>Adds a new element at the end of the array.</p>
<p>Use this method to append a single element to the end of a mutable array.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(100)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 100]&quot;
</code></pre>
<p>Because arrays increase their allocated capacity using an exponential
strategy, appending a single element to an array is an O(1) operation
when averaged over many calls to the <code>append(_:)</code> method. When an array
has additional capacity and is not sharing its storage with another
instance, appending an element is O(1). When an array needs to
reallocate storage before appending or its storage is shared with
another copy, appending is O(<em>n</em>), where <em>n</em> is the length of the array.</p>
<ul>
<li>Parameter newElement: The element to append to the array.</li>
</ul>
<blockquote>
<p>Complexity:
O(1) on average, over many calls to <code>append(_:)</code> on the same array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func append(_ newElement: Element)</code></div></div><div id="append_contentsOf-ac3371fb120478d23360c9cd8a715233" class="declaration"><a class="toggle-link" href="#comment-append_contentsOf-ac3371fb120478d23360c9cd8a715233">func append(contentsOf newElements: S)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-append_contentsOf-ac3371fb120478d23360c9cd8a715233"><p>Adds the elements of a sequence or collection to the end of this
collection.</p>
<p>The collection being appended to allocates any additional necessary
storage to hold the new elements.</p>
<p>The following example appends the elements of a <code>Range&lt;Int&gt;</code> instance to
an array of integers:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(contentsOf: 10...15)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot;
</code></pre>
<ul>
<li>Parameter newElements: The elements to append to the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>m</em>), where <em>m</em> is the length of <code>newElements</code>.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func append&lt;S>(contentsOf newElements: S) where S: Sequence, Self.Element == S.Element</code></div></div><div id="append_contentsOf-ac3371fb120478d23360c9cd8a715233" class="declaration"><a class="toggle-link" href="#comment-append_contentsOf-ac3371fb120478d23360c9cd8a715233">func append(contentsOf newElements: S)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-append_contentsOf-ac3371fb120478d23360c9cd8a715233"><p>Adds the elements of a sequence to the end of the array.</p>
<p>Use this method to append the elements of a sequence to the end of this
array. This example appends the elements of a <code>Range&lt;Int&gt;</code> instance
to an array of integers.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(contentsOf: 10...15)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot;
</code></pre>
<ul>
<li>Parameter newElements: The elements to append to the array.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>m</em>) on average, where <em>m</em> is the length of <code>newElements</code>, over many calls to <code>append(contentsOf:)</code> on the same array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func append&lt;S>(contentsOf newElements: S) where Element == S.Element, S: Sequence</code></div></div><div id="applying-4859fa95d24831da77250741f009e926" class="declaration"><a class="toggle-link" href="#comment-applying-4859fa95d24831da77250741f009e926">func applying(_ difference: CollectionDifference&lt;Self.Element>) -> Self?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-applying-4859fa95d24831da77250741f009e926"><p>Applies the given difference to this collection.</p>
<ul>
<li>Parameter difference: The difference to be applied.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em> + <em>c</em>), where <em>n</em> is <code>self.count</code> and <em>c</em> is the number of changes contained by the parameter.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@available(OSX 10.15, iOS 13, tvOS 13, watchOS 6, *) public func applying(_ difference: CollectionDifference&lt;Self.Element>) -> Self?</code></div></div><div id="distance_from_to-a4fda42879a53b11f7add335ae2b09e2" class="declaration"><a class="toggle-link" href="#comment-distance_from_to-a4fda42879a53b11f7add335ae2b09e2">func distance(from start: Int, to end: Int) -> Int</a> <span class="required">Required</span><div class="comment collapse in" id="comment-distance_from_to-a4fda42879a53b11f7add335ae2b09e2"><p>Returns the distance between two indices.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public func distance(from start: Int, to end: Int) -> Int</code></div></div><div id="filter-1c174b73935eda6461cafaf0555f7dfd" class="declaration"><a class="toggle-link" href="#comment-filter-1c174b73935eda6461cafaf0555f7dfd">func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-filter-1c174b73935eda6461cafaf0555f7dfd"><p>Returns a new collection of the same type containing, in order, the
elements of the original collection that satisfy the given predicate.</p>
<p>In this example, <code>filter(_:)</code> is used to include only names shorter than
five characters.</p>
<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let shortNames = cast.filter { $0.count &lt; 5 }
print(shortNames)
// Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot;
</code></pre>
<ul>
<li>Parameter isIncluded: A closure that takes an element of the
sequence as its argument and returns a Boolean value indicating
whether the element should be included in the returned collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@available(swift 4.0) @inlinable public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self</code></div></div><div id="formIndex_after-13e63bf648e45549081b5214c49499ce" class="declaration"><a class="toggle-link" href="#comment-formIndex_after-13e63bf648e45549081b5214c49499ce">func formIndex(after i: inout Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formIndex_after-13e63bf648e45549081b5214c49499ce"><p>Replaces the given index with its successor.</p>
<ul>
<li>Parameter i: A valid index of the collection. <code>i</code> must be less than
<code>endIndex</code>.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func formIndex(after i: inout Int)</code></div></div><div id="formIndex_before-a737e88621c75c8fd2b2c70af6a4f220" class="declaration"><a class="toggle-link" href="#comment-formIndex_before-a737e88621c75c8fd2b2c70af6a4f220">func formIndex(before i: inout Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formIndex_before-a737e88621c75c8fd2b2c70af6a4f220"><p>Replaces the given index with its predecessor.</p>
<ul>
<li>Parameter i: A valid index of the collection. <code>i</code> must be greater than
<code>startIndex</code>.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func formIndex(before i: inout Int)</code></div></div><div id="index_offsetBy-41a458d51308012c8383ec58b39fc85a" class="declaration"><a class="toggle-link" href="#comment-index_offsetBy-41a458d51308012c8383ec58b39fc85a">func index(_ i: Int, offsetBy distance: Int) -> Int</a> <span class="required">Required</span><div class="comment collapse in" id="comment-index_offsetBy-41a458d51308012c8383ec58b39fc85a"><p>Returns an index that is the specified distance from the given index.</p>
<p>The following example obtains an index advanced four positions from an
array's starting index and then prints the element at that position.</p>
<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
let i = numbers.index(numbers.startIndex, offsetBy: 4)
print(numbers[i])
// Prints &quot;50&quot;
</code></pre>
<p>The value passed as <code>distance</code> must not offset <code>i</code> beyond the bounds of
the collection.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public func index(_ i: Int, offsetBy distance: Int) -> Int</code></div></div><div id="index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130" class="declaration"><a class="toggle-link" href="#comment-index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130">func index(_ i: Self.Index, offsetBy distance: Int, limitedBy limit: Self.Index) -> Self.Index?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130"><p>Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.</p>
<p>The following example obtains an index advanced four positions from an
array's starting index and then prints the element at that position. The
operation doesn't require going beyond the limiting <code>numbers.endIndex</code>
value, so it succeeds.</p>
<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
let i = numbers.index(numbers.startIndex, offsetBy: 4)
print(numbers[i])
// Prints &quot;50&quot;
</code></pre>
<p>The next example attempts to retrieve an index ten positions from
<code>numbers.startIndex</code>, but fails, because that distance is beyond the
index passed as <code>limit</code>.</p>
<pre><code class="language-swift">let j = numbers.index(numbers.startIndex,
                      offsetBy: 10,
                      limitedBy: numbers.endIndex)
print(j)
// Prints &quot;nil&quot;
</code></pre>
<p>The value passed as <code>distance</code> must not offset <code>i</code> beyond the bounds of
the collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public func index(_ i: Self.Index, offsetBy distance: Int, limitedBy limit: Self.Index) -> Self.Index?</code></div></div><div id="index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130" class="declaration"><a class="toggle-link" href="#comment-index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130">func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-index_offsetBy_limitedBy-c29af88d32684042c610f5da0fa07130"><p>Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.</p>
<p>The following example obtains an index advanced four positions from an
array's starting index and then prints the element at that position. The
operation doesn't require going beyond the limiting <code>numbers.endIndex</code>
value, so it succeeds.</p>
<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let i = numbers.index(numbers.startIndex,
                         offsetBy: 4,
                         limitedBy: numbers.endIndex) {
    print(numbers[i])
}
// Prints &quot;50&quot;
</code></pre>
<p>The next example attempts to retrieve an index ten positions from
<code>numbers.startIndex</code>, but fails, because that distance is beyond the
index passed as <code>limit</code>.</p>
<pre><code class="language-swift">let j = numbers.index(numbers.startIndex,
                      offsetBy: 10,
                      limitedBy: numbers.endIndex)
print(j)
// Prints &quot;nil&quot;
</code></pre>
<p>The value passed as <code>distance</code> must not offset <code>i</code> beyond the bounds of
the collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?</code></div></div><div id="index_after-976478ce790c064a72519919a525cb29" class="declaration"><a class="toggle-link" href="#comment-index_after-976478ce790c064a72519919a525cb29">func index(after i: Int) -> Int</a> <span class="required">Required</span><div class="comment collapse in" id="comment-index_after-976478ce790c064a72519919a525cb29"><p>Returns the position immediately after the given index.</p>
<ul>
<li>Parameter i: A valid index of the collection. <code>i</code> must be less than
<code>endIndex</code>.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func index(after i: Int) -> Int</code></div></div><div id="index_before-ee7e993bbd939c71d46566c977277662" class="declaration"><a class="toggle-link" href="#comment-index_before-ee7e993bbd939c71d46566c977277662">func index(before i: Int) -> Int</a> <span class="required">Required</span><div class="comment collapse in" id="comment-index_before-ee7e993bbd939c71d46566c977277662"><p>Returns the position immediately before the given index.</p>
<ul>
<li>Parameter i: A valid index of the collection. <code>i</code> must be greater than
<code>startIndex</code>.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func index(before i: Int) -> Int</code></div></div><div id="insert_at-2422c5a8ae5e7107d8c851b9681eb071" class="declaration"><a class="toggle-link" href="#comment-insert_at-2422c5a8ae5e7107d8c851b9681eb071">func insert(_ newElement: Self.Element, at i: Self.Index)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-insert_at-2422c5a8ae5e7107d8c851b9681eb071"><p>Inserts a new element into the collection at the specified position.</p>
<p>The new element is inserted before the element currently at the
specified index. If you pass the collection's <code>endIndex</code> property as
the <code>index</code> parameter, the new element is appended to the
collection.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.insert(100, at: 3)
numbers.insert(200, at: numbers.endIndex)

print(numbers)
// Prints &quot;[1, 2, 3, 100, 4, 5, 200]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter newElement: The new element to insert into the collection.</li>
</ul>
<ul>
<li>Parameter i: The position at which to insert the new element.
<code>index</code> must be a valid index into the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection. If <code>i == endIndex</code>, this method is equivalent to <code>append(_:)</code>.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func insert(_ newElement: Self.Element, at i: Self.Index)</code></div></div><div id="insert_at-2422c5a8ae5e7107d8c851b9681eb071" class="declaration"><a class="toggle-link" href="#comment-insert_at-2422c5a8ae5e7107d8c851b9681eb071">func insert(_ newElement: Element, at i: Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-insert_at-2422c5a8ae5e7107d8c851b9681eb071"><p>Inserts a new element at the specified position.</p>
<p>The new element is inserted before the element currently at the specified
index. If you pass the array's <code>endIndex</code> property as the <code>index</code>
parameter, the new element is appended to the array.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.insert(100, at: 3)
numbers.insert(200, at: numbers.endIndex)

print(numbers)
// Prints &quot;[1, 2, 3, 100, 4, 5, 200]&quot;
</code></pre>
<ul>
<li>Parameter newElement: The new element to insert into the array.</li>
</ul>
<ul>
<li>Parameter i: The position at which to insert the new element.
<code>index</code> must be a valid index of the array or equal to its <code>endIndex</code>
property.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the array. If <code>i == endIndex</code>, this method is equivalent to <code>append(_:)</code>.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func insert(_ newElement: Element, at i: Int)</code></div></div><div id="insert_contentsOf_at-c903317351c7d5642de7c18c61788233" class="declaration"><a class="toggle-link" href="#comment-insert_contentsOf_at-c903317351c7d5642de7c18c61788233">func insert(contentsOf newElements: C, at i: Self.Index)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-insert_contentsOf_at-c903317351c7d5642de7c18c61788233"><p>Inserts the elements of a sequence into the collection at the specified
position.</p>
<p>The new elements are inserted before the element currently at the
specified index. If you pass the collection's <code>endIndex</code> property as the
<code>index</code> parameter, the new elements are appended to the collection.</p>
<p>Here's an example of inserting a range of integers into an array of the
same type:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.insert(contentsOf: 100...103, at: 3)
print(numbers)
// Prints &quot;[1, 2, 3, 100, 101, 102, 103, 4, 5]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter newElements: The new elements to insert into the collection.</li>
</ul>
<ul>
<li>Parameter i: The position at which to insert the new elements. <code>index</code>
must be a valid index of the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em> + <em>m</em>), where <em>n</em> is length of this collection and <em>m</em> is the length of <code>newElements</code>. If <code>i == endIndex</code>, this method is equivalent to <code>append(contentsOf:)</code>.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func insert&lt;C>(contentsOf newElements: C, at i: Self.Index) where C: Collection, Self.Element == C.Element</code></div></div><div id="partition_by-b2383dcbf1e2c7892fd6c675a92ca9e2" class="declaration"><a class="toggle-link" href="#comment-partition_by-b2383dcbf1e2c7892fd6c675a92ca9e2">func partition(by belongsInSecondPartition: (Self.Element) throws -> Bool) rethrows -> Self.Index</a> <span class="required">Required</span><div class="comment collapse in" id="comment-partition_by-b2383dcbf1e2c7892fd6c675a92ca9e2"><p>Reorders the elements of the collection such that all the elements
that match the given predicate are after all the elements that don't
match.</p>
<p>After partitioning a collection, there is a pivot index <code>p</code> where
no element before <code>p</code> satisfies the <code>belongsInSecondPartition</code>
predicate and every element at or after <code>p</code> satisfies
<code>belongsInSecondPartition</code>.</p>
<p>In the following example, an array of numbers is partitioned by a
predicate that matches elements greater than 30.</p>
<pre><code class="language-swift">var numbers = [30, 40, 20, 30, 30, 60, 10]
let p = numbers.partition(by: { $0 &gt; 30 })
// p == 5
// numbers == [30, 10, 20, 30, 30, 60, 40]
</code></pre>
<p>The <code>numbers</code> array is now arranged in two partitions. The first
partition, <code>numbers[..&lt;p]</code>, is made up of the elements that
are not greater than 30. The second partition, <code>numbers[p...]</code>,
is made up of the elements that <em>are</em> greater than 30.</p>
<pre><code class="language-swift">let first = numbers[..&lt;p]
// first == [30, 10, 20, 30, 30]
let second = numbers[p...]
// second == [60, 40]
</code></pre>
<ul>
<li>Parameter belongsInSecondPartition: A predicate used to partition
the collection. All elements satisfying this predicate are ordered
after all elements not satisfying it.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Bool) rethrows -> Self.Index</code></div></div><div id="remove_at-3e0c9900dc44c20e5d46b7cd3b677435" class="declaration"><a class="toggle-link" href="#comment-remove_at-3e0c9900dc44c20e5d46b7cd3b677435">func remove(at position: Self.Index) -> Self.Element</a> <span class="required">Required</span><div class="comment collapse in" id="comment-remove_at-3e0c9900dc44c20e5d46b7cd3b677435"><p>Removes and returns the element at the specified position.</p>
<p>All the elements following the specified position are moved to close the
gap. This example removes the middle element from an array of
measurements.</p>
<pre><code class="language-swift">var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
let removed = measurements.remove(at: 2)
print(measurements)
// Prints &quot;[1.2, 1.5, 1.2, 1.6]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter position: The position of the element to remove. <code>position</code>
must be a valid index of the collection that is not equal to the
collection's end index.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func remove(at position: Self.Index) -> Self.Element</code></div></div><div id="remove_at-3e0c9900dc44c20e5d46b7cd3b677435" class="declaration"><a class="toggle-link" href="#comment-remove_at-3e0c9900dc44c20e5d46b7cd3b677435">func remove(at index: Int) -> Element</a> <span class="required">Required</span><div class="comment collapse in" id="comment-remove_at-3e0c9900dc44c20e5d46b7cd3b677435"><p>Removes and returns the element at the specified position.</p>
<p>All the elements following the specified position are moved up to
close the gap.</p>
<pre><code class="language-swift">var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
let removed = measurements.remove(at: 2)
print(measurements)
// Prints &quot;[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]&quot;
</code></pre>
<ul>
<li>Parameter index: The position of the element to remove. <code>index</code> must
be a valid index of the array.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func remove(at index: Int) -> Element</code></div></div><div id="removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010" class="declaration"><a class="toggle-link" href="#comment-removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010">func removeAll(keepingCapacity keepCapacity: Bool = false)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010"><p>Removes all elements from the collection.</p>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter keepCapacity: Pass <code>true</code> to request that the collection
avoid releasing its storage. Retaining the collection's storage can
be a useful optimization when you're planning to grow the collection
again. The default value is <code>false</code>.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)</code></div></div><div id="removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010" class="declaration"><a class="toggle-link" href="#comment-removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010">func removeAll(keepingCapacity keepCapacity: Bool = false)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeAll_keepingCapacity-258ecaf1c68e3810fad8df6f24bcd010"><p>Removes all elements from the array.</p>
<ul>
<li>Parameter keepCapacity: Pass <code>true</code> to keep the existing capacity of
the array after removing its elements. The default value is
<code>false</code>.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)</code></div></div><div id="removeAll_where-78f1ec47693ca0c39027cef2bf1c64be" class="declaration"><a class="toggle-link" href="#comment-removeAll_where-78f1ec47693ca0c39027cef2bf1c64be">func removeAll(where shouldBeRemoved: (Self.Element) throws -> Bool) rethrows</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeAll_where-78f1ec47693ca0c39027cef2bf1c64be"><p>Removes all the elements that satisfy the given predicate.</p>
<p>Use this method to remove every element in a collection that meets
particular criteria. The order of the remaining elements is preserved.
This example removes all the vowels from a string:</p>
<pre><code class="language-swift">var phrase = &quot;The rain in Spain stays mainly in the plain.&quot;

let vowels: Set&lt;Character&gt; = [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;]
phrase.removeAll(where: { vowels.contains($0) })
// phrase == &quot;Th rn n Spn stys mnly n th pln.&quot;
</code></pre>
<ul>
<li>Parameter shouldBeRemoved: A closure that takes an element of the
sequence as its argument and returns a Boolean value indicating
whether the element should be removed from the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Bool) rethrows</code></div></div><div id="removeFirst-90bb9af594748b627d638a3b28d286c7" class="declaration"><a class="toggle-link" href="#comment-removeFirst-90bb9af594748b627d638a3b28d286c7">func removeFirst() -> Self.Element</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeFirst-90bb9af594748b627d638a3b28d286c7"><p>Removes and returns the first element of the collection.</p>
<p>The collection must not be empty.</p>
<pre><code class="language-swift">var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]
bugs.removeFirst()
print(bugs)
// Prints &quot;[&quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeFirst() -> Self.Element</code></div></div><div id="removeFirst-38c26d3d2ce7e1284c4720b69bb07b0c" class="declaration"><a class="toggle-link" href="#comment-removeFirst-38c26d3d2ce7e1284c4720b69bb07b0c">func removeFirst(_ k: Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeFirst-38c26d3d2ce7e1284c4720b69bb07b0c"><p>Removes the specified number of elements from the beginning of the
collection.</p>
<pre><code class="language-swift">var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]
bugs.removeFirst(3)
print(bugs)
// Prints &quot;[&quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter k: The number of elements to remove from the collection.
<code>k</code> must be greater than or equal to zero and must not exceed the
number of elements in the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeFirst(_ k: Int)</code></div></div><div id="removeSubrange-879999614b8060026a48a1f66c30ac8f" class="declaration"><a class="toggle-link" href="#comment-removeSubrange-879999614b8060026a48a1f66c30ac8f">func removeSubrange(_ bounds: Range&lt;Self.Index>)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeSubrange-879999614b8060026a48a1f66c30ac8f"><p>Removes the elements in the specified subrange from the collection.</p>
<p>All the elements following the specified position are moved to close the
gap. This example removes three elements from the middle of an array of
measurements.</p>
<pre><code class="language-swift">var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
measurements.removeSubrange(1..&lt;4)
print(measurements)
// Prints &quot;[1.2, 1.5]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter bounds: The range of the collection to be removed. The
bounds of the range must be valid indices of the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeSubrange(_ bounds: Range&lt;Self.Index>)</code></div></div><div id="removeSubrange-879999614b8060026a48a1f66c30ac8f" class="declaration"><a class="toggle-link" href="#comment-removeSubrange-879999614b8060026a48a1f66c30ac8f">func removeSubrange(_ bounds: R)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-removeSubrange-879999614b8060026a48a1f66c30ac8f"><p>Removes the elements in the specified subrange from the collection.</p>
<p>All the elements following the specified position are moved to close the
gap. This example removes three elements from the middle of an array of
measurements.</p>
<pre><code class="language-swift">var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
measurements.removeSubrange(1..&lt;4)
print(measurements)
// Prints &quot;[1.2, 1.5]&quot;
</code></pre>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<ul>
<li>Parameter bounds: The range of the collection to be removed. The
bounds of the range must be valid indices of the collection.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the length of the collection.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func removeSubrange&lt;R>(_ bounds: R) where R: RangeExpression, Self.Index == R.Bound</code></div></div><div id="replaceSubrange_with-37f24f980773f1736abe2f2109e3c177" class="declaration"><a class="toggle-link" href="#comment-replaceSubrange_with-37f24f980773f1736abe2f2109e3c177">func replaceSubrange(_ subrange: R, with newElements: C)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-replaceSubrange_with-37f24f980773f1736abe2f2109e3c177"><p>Replaces the specified subrange of elements with the given collection.</p>
<p>This method has the effect of removing the specified range of elements
from the collection and inserting the new elements at the same location.
The number of new elements need not match the number of elements being
removed.</p>
<p>In this example, three elements in the middle of an array of integers are
replaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.</p>
<pre><code class="language-swift"> var nums = [10, 20, 30, 40, 50]
 nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
 print(nums)
 // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;
</code></pre>
<p>If you pass a zero-length range as the <code>subrange</code> parameter, this method
inserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling
the <code>insert(contentsOf:at:)</code> method instead is preferred.</p>
<p>Likewise, if you pass a zero-length collection as the <code>newElements</code>
parameter, this method removes the elements in the given subrange
without replacement. Calling the <code>removeSubrange(_:)</code> method instead is
preferred.</p>
<p>Calling this method may invalidate any existing indices for use with this
collection.</p>
<blockquote>
<p>Complexity:
O(<em>n</em> + <em>m</em>), where <em>n</em> is length of this collection and <em>m</em> is the length of <code>newElements</code>. If the call to this method simply appends the contents of <code>newElements</code> to the collection, the complexity is O(<em>m</em>).</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func replaceSubrange&lt;C, R>(_ subrange: R, with newElements: C) where C: Collection, R: RangeExpression, Self.Element == C.Element, Self.Index == R.Bound</code></div></div><div id="replaceSubrange_with-37f24f980773f1736abe2f2109e3c177" class="declaration"><a class="toggle-link" href="#comment-replaceSubrange_with-37f24f980773f1736abe2f2109e3c177">func replaceSubrange(_ subrange: Range&lt;Int>, with newElements: C)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-replaceSubrange_with-37f24f980773f1736abe2f2109e3c177"><p>Replaces a range of elements with the elements in the specified
collection.</p>
<p>This method has the effect of removing the specified range of elements
from the array and inserting the new elements at the same location. The
number of new elements need not match the number of elements being
removed.</p>
<p>In this example, three elements in the middle of an array of integers are
replaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.</p>
<pre><code class="language-swift"> var nums = [10, 20, 30, 40, 50]
 nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
 print(nums)
 // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;
</code></pre>
<p>If you pass a zero-length range as the <code>subrange</code> parameter, this method
inserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling
the <code>insert(contentsOf:at:)</code> method instead is preferred.</p>
<p>Likewise, if you pass a zero-length collection as the <code>newElements</code>
parameter, this method removes the elements in the given subrange
without replacement. Calling the <code>removeSubrange(_:)</code> method instead is
preferred.</p>
<blockquote>
<p>Complexity:
O(<em>n</em> + <em>m</em>), where <em>n</em> is length of the array and <em>m</em> is the length of <code>newElements</code>. If the call to this method simply appends the contents of <code>newElements</code> to the array, this method is equivalent to <code>append(contentsOf:)</code>.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func replaceSubrange&lt;C>(_ subrange: Range&lt;Int>, with newElements: C) where Element == C.Element, C: Collection</code></div></div><div id="reserveCapacity-f5185bdad5243d37ae23c866665e584b" class="declaration"><a class="toggle-link" href="#comment-reserveCapacity-f5185bdad5243d37ae23c866665e584b">func reserveCapacity(_ n: Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-reserveCapacity-f5185bdad5243d37ae23c866665e584b"><p>Prepares the collection to store the specified number of elements, when
doing so is appropriate for the underlying type.</p>
<p>If you will be adding a known number of elements to a collection, use
this method to avoid multiple reallocations. A type that conforms to
<code>RangeReplaceableCollection</code> can choose how to respond when this method
is called. Depending on the type, it may make sense to allocate more or
less storage than requested or to take no action at all.</p>
<ul>
<li>Parameter n: The requested number of elements to store.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func reserveCapacity(_ n: Int)</code></div></div><div id="reserveCapacity-f5185bdad5243d37ae23c866665e584b" class="declaration"><a class="toggle-link" href="#comment-reserveCapacity-f5185bdad5243d37ae23c866665e584b">func reserveCapacity(_ minimumCapacity: Int)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-reserveCapacity-f5185bdad5243d37ae23c866665e584b"><p>Reserves enough space to store the specified number of elements.</p>
<p>If you are adding a known number of elements to an array, use this method
to avoid multiple reallocations. This method ensures that the array has
unique, mutable, contiguous storage, with space allocated for at least
the requested number of elements.</p>
<p>Calling the <code>reserveCapacity(_:)</code> method on an array with bridged storage
triggers a copy to contiguous storage even if the existing storage
has room to store <code>minimumCapacity</code> elements.</p>
<p>For performance reasons, the size of the newly allocated storage might be
greater than the requested capacity. Use the array's <code>capacity</code> property
to determine the size of the new storage.</p>
<h1>Preserving an Array's Geometric Growth Strategy</h1>
<p>If you implement a custom data structure backed by an array that grows
dynamically, naively calling the <code>reserveCapacity(_:)</code> method can lead
to worse than expected performance. Arrays need to follow a geometric
allocation pattern for appending elements to achieve amortized
constant-time performance. The <code>Array</code> type's <code>append(_:)</code> and
<code>append(contentsOf:)</code> methods take care of this detail for you, but
<code>reserveCapacity(_:)</code> allocates only as much space as you tell it to
(padded to a round value), and no more. This avoids over-allocation, but
can result in insertion not having amortized constant-time performance.</p>
<p>The following code declares <code>values</code>, an array of integers, and the
<code>addTenQuadratic()</code> function, which adds ten more values to the <code>values</code>
array on each call.</p>
<pre><code class="language-swift">  var values: [Int] = [0, 1, 2, 3]

  // Don't use 'reserveCapacity(_:)' like this
  func addTenQuadratic() {
      let newCount = values.count + 10
      values.reserveCapacity(newCount)
      for n in values.count..&lt;newCount {
          values.append(n)
      }
  }
</code></pre>
<p>The call to <code>reserveCapacity(_:)</code> increases the <code>values</code> array's capacity
by exactly 10 elements on each pass through <code>addTenQuadratic()</code>, which
is linear growth. Instead of having constant time when averaged over
many calls, the function may decay to performance that is linear in
<code>values.count</code>. This is almost certainly not what you want.</p>
<p>In cases like this, the simplest fix is often to simply remove the call
to <code>reserveCapacity(_:)</code>, and let the <code>append(_:)</code> method grow the array
for you.</p>
<pre><code class="language-swift">  func addTen() {
      let newCount = values.count + 10
      for n in values.count..&lt;newCount {
          values.append(n)
      }
  }
</code></pre>
<p>If you need more control over the capacity of your array, implement your
own geometric growth strategy, passing the size you compute to
<code>reserveCapacity(_:)</code>.</p>
<ul>
<li>Parameter minimumCapacity: The requested number of elements to store.</li>
</ul>
<blockquote>
<p>Complexity:
O(<em>n</em>), where <em>n</em> is the number of elements in the array.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func reserveCapacity(_ minimumCapacity: Int)</code></div></div><div id="swapAt-4f1c6f78bf62e718b43e8eae7cd088ea" class="declaration"><a class="toggle-link" href="#comment-swapAt-4f1c6f78bf62e718b43e8eae7cd088ea">func swapAt(_ i: Self.Index, _ j: Self.Index)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-swapAt-4f1c6f78bf62e718b43e8eae7cd088ea"><p>Exchanges the values at the specified indices of the collection.</p>
<p>Both parameters must be valid indices of the collection that are not
equal to <code>endIndex</code>. Calling <code>swapAt(_:_:)</code> with the same index as both
<code>i</code> and <code>j</code> has no effect.</p>
<blockquote>
<p>Complexity:
O(1)</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func swapAt(_ i: Self.Index, _ j: Self.Index)</code></div></div><div id="withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9" class="declaration"><a class="toggle-link" href="#comment-withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9">func withContiguousMutableStorageIfAvailable(_ body: (inout UnsafeMutableBufferPointer&lt;Element>) throws -> R) rethrows -> R?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9"><p>Call <code>body(p)</code>, where <code>p</code> is a pointer to the collection's
mutable contiguous storage.  If no such storage exists, it is
first created.  If the collection does not support an internal
representation in a form of mutable contiguous storage, <code>body</code> is not
called and <code>nil</code> is returned.</p>
<p>Often, the optimizer can eliminate bounds- and uniqueness-checks
within an algorithm, but when that fails, invoking the
same algorithm on <code>body</code>\ 's argument lets you trade safety for
speed.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func withContiguousMutableStorageIfAvailable&lt;R>(_ body: (inout UnsafeMutableBufferPointer&lt;Element>) throws -> R) rethrows -> R?</code></div></div><div id="withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9" class="declaration"><a class="toggle-link" href="#comment-withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9">func withContiguousMutableStorageIfAvailable(_ body: (inout UnsafeMutableBufferPointer&lt;Self.Element>) throws -> R) rethrows -> R?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withContiguousMutableStorageIfAvailable-d1d5932d982e6a4ccdceabb496bf78e9"><p>Call <code>body(p)</code>, where <code>p</code> is a pointer to the collection's
mutable contiguous storage.  If no such storage exists, it is
first created.  If the collection does not support an internal
representation in a form of mutable contiguous storage, <code>body</code> is not
called and <code>nil</code> is returned.</p>
<p>Often, the optimizer can eliminate bounds- and uniqueness-checks
within an algorithm, but when that fails, invoking the
same algorithm on <code>body</code>\ 's argument lets you trade safety for
speed.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func withContiguousMutableStorageIfAvailable&lt;R>(_ body: (inout UnsafeMutableBufferPointer&lt;Self.Element>) throws -> R) rethrows -> R?</code></div></div><div id="withContiguousStorageIfAvailable-a498ae9a2038e195b24a1bcdf0aa982e" class="declaration"><a class="toggle-link" href="#comment-withContiguousStorageIfAvailable-a498ae9a2038e195b24a1bcdf0aa982e">func withContiguousStorageIfAvailable(_ body: (UnsafeBufferPointer&lt;Element>) throws -> R) rethrows -> R?</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withContiguousStorageIfAvailable-a498ae9a2038e195b24a1bcdf0aa982e"><p>Call <code>body(p)</code>, where <code>p</code> is a pointer to the collection's
contiguous storage.  If no such storage exists, it is
first created.  If the collection does not support an internal
representation in a form of contiguous storage, <code>body</code> is not
called and <code>nil</code> is returned.</p>
<p>A <code>Collection</code> that provides its own implementation of this method
must also guarantee that an equivalent buffer of its <code>SubSequence</code>
can be generated by advancing the pointer by the distance to the
slice's <code>startIndex</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public func withContiguousStorageIfAvailable&lt;R>(_ body: (UnsafeBufferPointer&lt;Element>) throws -> R) rethrows -> R?</code></div></div><div id="withUnsafeBufferPointer-ab27317c2016a7d858bda22d61109e73" class="declaration"><a class="toggle-link" href="#comment-withUnsafeBufferPointer-ab27317c2016a7d858bda22d61109e73">func withUnsafeBufferPointer(_ body: (UnsafeBufferPointer&lt;Element>) throws -> R) rethrows -> R</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withUnsafeBufferPointer-ab27317c2016a7d858bda22d61109e73"><p>Calls a closure with a pointer to the array's contiguous storage.</p>
<p>Often, the optimizer can eliminate bounds checks within an array
algorithm, but when that fails, invoking the same algorithm on the
buffer pointer passed into your closure lets you trade safety for speed.</p>
<p>The following example shows how you can iterate over the contents of the
buffer pointer:</p>
<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
let sum = numbers.withUnsafeBufferPointer { buffer -&gt; Int in
    var result = 0
    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
        result += buffer[i]
    }
    return result
}
// 'sum' == 9
</code></pre>
<p>The pointer passed as an argument to <code>body</code> is valid only during the
execution of <code>withUnsafeBufferPointer(_:)</code>. Do not store or return the
pointer for later use.</p>
<ul>
<li>Parameter body: A closure with an <code>UnsafeBufferPointer</code> parameter that
points to the contiguous storage for the array.  If no such storage exists, it is created. If
<code>body</code> has a return value, that value is also used as the return value
for the <code>withUnsafeBufferPointer(_:)</code> method. The pointer argument is
valid only for the duration of the method's execution.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func withUnsafeBufferPointer&lt;R>(_ body: (UnsafeBufferPointer&lt;Element>) throws -> R) rethrows -> R</code></div></div><div id="withUnsafeBytes-7280bd2bfb31b924555aae00d62412c7" class="declaration"><a class="toggle-link" href="#comment-withUnsafeBytes-7280bd2bfb31b924555aae00d62412c7">func withUnsafeBytes(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withUnsafeBytes-7280bd2bfb31b924555aae00d62412c7"><p>Calls the given closure with a pointer to the underlying bytes of the
array's contiguous storage.</p>
<p>The array's <code>Element</code> type must be a <em>trivial type</em>, which can be copied
with just a bit-for-bit copy without any indirection or
reference-counting operations. Generally, native Swift types that do not
contain strong or weak references are trivial, as are imported C structs
and enums.</p>
<p>The following example copies the bytes of the <code>numbers</code> array into a
buffer of <code>UInt8</code>:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3]
var byteBuffer: [UInt8] = []
numbers.withUnsafeBytes {
    byteBuffer.append(contentsOf: $0)
}
// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]
</code></pre>
<ul>
<li>Parameter body: A closure with an <code>UnsafeRawBufferPointer</code> parameter
that points to the contiguous storage for the array.
If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
used as the return value for the <code>withUnsafeBytes(_:)</code> method. The
argument is valid only for the duration of the closure's execution.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public func withUnsafeBytes&lt;R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R</code></div></div><div id="withUnsafeMutableBufferPointer-b83088a124567dc075dd950807f2ece0" class="declaration"><a class="toggle-link" href="#comment-withUnsafeMutableBufferPointer-b83088a124567dc075dd950807f2ece0">func withUnsafeMutableBufferPointer(_ body: (inout UnsafeMutableBufferPointer&lt;Element>) throws -> R) rethrows -> R</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withUnsafeMutableBufferPointer-b83088a124567dc075dd950807f2ece0"><p>Calls the given closure with a pointer to the array's mutable contiguous
storage.</p>
<p>Often, the optimizer can eliminate bounds checks within an array
algorithm, but when that fails, invoking the same algorithm on the
buffer pointer passed into your closure lets you trade safety for speed.</p>
<p>The following example shows how modifying the contents of the
<code>UnsafeMutableBufferPointer</code> argument to <code>body</code> alters the contents of
the array:</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.withUnsafeMutableBufferPointer { buffer in
    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
        buffer.swapAt(i, i + 1)
    }
}
print(numbers)
// Prints &quot;[2, 1, 4, 3, 5]&quot;
</code></pre>
<p>The pointer passed as an argument to <code>body</code> is valid only during the
execution of <code>withUnsafeMutableBufferPointer(_:)</code>. Do not store or
return the pointer for later use.</p>
<blockquote>
<p>Warning:
Do not rely on anything about the array that is the target of this method during execution of the <code>body</code> closure; it might not appear to have its correct value. Instead, use only the <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.</p>
</blockquote>
<ul>
<li>Parameter body: A closure with an <code>UnsafeMutableBufferPointer</code>
parameter that points to the contiguous storage for the array.
If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
used as the return value for the <code>withUnsafeMutableBufferPointer(_:)</code>
method. The pointer argument is valid only for the duration of the
method's execution.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func withUnsafeMutableBufferPointer&lt;R>(_ body: (inout UnsafeMutableBufferPointer&lt;Element>) throws -> R) rethrows -> R</code></div></div><div id="withUnsafeMutableBytes-2dfda9c32690df06a9a0031f94b39a6d" class="declaration"><a class="toggle-link" href="#comment-withUnsafeMutableBytes-2dfda9c32690df06a9a0031f94b39a6d">func withUnsafeMutableBytes(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R</a> <span class="required">Required</span><div class="comment collapse in" id="comment-withUnsafeMutableBytes-2dfda9c32690df06a9a0031f94b39a6d"><p>Calls the given closure with a pointer to the underlying bytes of the
array's mutable contiguous storage.</p>
<p>The array's <code>Element</code> type must be a <em>trivial type</em>, which can be copied
with just a bit-for-bit copy without any indirection or
reference-counting operations. Generally, native Swift types that do not
contain strong or weak references are trivial, as are imported C structs
and enums.</p>
<p>The following example copies bytes from the <code>byteValues</code> array into
<code>numbers</code>, an array of <code>Int</code>:</p>
<pre><code class="language-swift">var numbers: [Int32] = [0, 0]
var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]

numbers.withUnsafeMutableBytes { destBytes in
    byteValues.withUnsafeBytes { srcBytes in
        destBytes.copyBytes(from: srcBytes)
    }
}
// numbers == [1, 2]
</code></pre>
<p>The pointer passed as an argument to <code>body</code> is valid only for the
lifetime of the closure. Do not escape it from the closure for later
use.</p>
<blockquote>
<p>Warning:
Do not rely on anything about the array that is the target of this method during execution of the <code>body</code> closure; it might not appear to have its correct value. Instead, use only the <code>UnsafeMutableRawBufferPointer</code> argument to <code>body</code>.</p>
</blockquote>
<ul>
<li>Parameter body: A closure with an <code>UnsafeMutableRawBufferPointer</code>
parameter that points to the contiguous storage for the array.
If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
used as the return value for the <code>withUnsafeMutableBytes(_:)</code> method.
The argument is valid only for the duration of the closure's
execution.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">@inlinable public mutating func withUnsafeMutableBytes&lt;R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R</code></div></div><h3>Type Methods</h3><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: Self, rhs: Other) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><p>Creates a new collection by concatenating the elements of a collection and
a sequence.</p>
<p>The two arguments must have the same <code>Element</code> type. For example, you can
concatenate the elements of an integer array and a <code>Range&lt;Int&gt;</code> instance.</p>
<pre><code class="language-swift">let numbers = [1, 2, 3, 4]
let moreNumbers = numbers + 5...10
print(moreNumbers)
// Prints &quot;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&quot;
</code></pre>
<p>The resulting collection has the type of the argument on the left-hand
side. In the example above, <code>moreNumbers</code> has the same type as <code>numbers</code>,
which is <code>[Int]</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func +&lt;Other>(lhs: Self, rhs: Other) -> Self where Other: Sequence, Self.Element == Other.Element</code></div></div><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: Other, rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><p>Creates a new collection by concatenating the elements of a sequence and a
collection.</p>
<p>The two arguments must have the same <code>Element</code> type. For example, you can
concatenate the elements of a <code>Range&lt;Int&gt;</code> instance and an integer array.</p>
<pre><code class="language-swift">let numbers = [7, 8, 9, 10]
let moreNumbers = 1...6 + numbers
print(moreNumbers)
// Prints &quot;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&quot;
</code></pre>
<p>The resulting collection has the type of argument on the right-hand side.
In the example above, <code>moreNumbers</code> has the same type as <code>numbers</code>, which
is <code>[Int]</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func +&lt;Other>(lhs: Other, rhs: Self) -> Self where Other: Sequence, Self.Element == Other.Element</code></div></div><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: Self, rhs: Other) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><p>Creates a new collection by concatenating the elements of two collections.</p>
<p>The two arguments must have the same <code>Element</code> type. For example, you can
concatenate the elements of two integer arrays.</p>
<pre><code class="language-swift">let lowerNumbers = [1, 2, 3, 4]
let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
let allNumbers = lowerNumbers + higherNumbers
print(allNumbers)
// Prints &quot;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&quot;
</code></pre>
<p>The resulting collection has the type of the argument on the left-hand
side. In the example above, <code>moreNumbers</code> has the same type as <code>numbers</code>,
which is <code>[Int]</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func +&lt;Other>(lhs: Self, rhs: Other) -> Self where Other: RangeReplaceableCollection, Self.Element == Other.Element</code></div></div><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: [Element], rhs: [Element]) -> [Element]</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><h4>Declaration</h4><code class="language-swift">@inlinable public static func +(lhs: [Element], rhs: [Element]) -> [Element]</code></div></div><div id="lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb">func +=(lhs: inout Self, rhs: Other)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb"><p>Appends the elements of a sequence to a range-replaceable collection.</p>
<p>Use this operator to append the elements of a sequence to the end of
range-replaceable collection with same <code>Element</code> type. This example
appends the elements of a <code>Range&lt;Int&gt;</code> instance to an array of integers.</p>
<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers += 10...15
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot;
</code></pre>
<blockquote>
<p>Complexity:
O(<em>m</em>), where <em>m</em> is the length of the right-hand-side argument.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func +=&lt;Other>(lhs: inout Self, rhs: Other) where Other: Sequence, Self.Element == Other.Element</code></div></div><div id="lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb">func +=(lhs: inout [Element], rhs: [Element])</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb"><h4>Declaration</h4><code class="language-swift">@inlinable public static func +=(lhs: inout [Element], rhs: [Element])</code></div></div>