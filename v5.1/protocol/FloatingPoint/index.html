---
root: "/v5.1"
layout: "default"
keywords: ""
title: "FloatingPoint"
description: "Swift documentation for 'FloatingPoint'"
---

<div class="intro-declaration"><code class="language-swift">protocol FloatingPoint</code></div><p>A floating-point numeric type.</p>
<table class="standard"><tr><th id="inheritance">Inheritance</th><td><code class="inherits">Hashable, SignedNumeric, Strideable</code></td></tr><tr><th id="conforming-types">Conforming Types</th><td><code class="inherits">BinaryFloatingPoint</code></td></tr><tr><th id="associatedtypes">Associated Types</th><td><span id="aliasesmark"></span><div class="declaration"><code class="language-swift">associatedtype Exponent</code><div class="comment"></div></div></td></tr></table><div class="discussion comment"><p>Floating-point types are used to represent fractional numbers, like 5.5,
100.0, or 3.14159274. Each floating-point type has its own possible range
and precision. The floating-point types in the standard library are
<code>Float</code>, <code>Double</code>, and <code>Float80</code> where available.</p>
<p>Create new instances of floating-point types using integer or
floating-point literals. For example:</p>
<pre><code class="language-swift">let temperature = 33.2
let recordHigh = 37.5
</code></pre>
<p>The <code>FloatingPoint</code> protocol declares common arithmetic operations, so you
can write functions and algorithms that work on any floating-point type.
The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.
Because the <code>hypotenuse(_:_:)</code> function uses a generic parameter
constrained to the <code>FloatingPoint</code> protocol, you can call it using any
floating-point type.</p>
<pre><code class="language-swift">func hypotenuse&lt;T: FloatingPoint&gt;(_ a: T, _ b: T) -&gt; T {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0
</code></pre>
<p>Floating-point values are represented as a <em>sign</em> and a <em>magnitude</em>, where
the magnitude is calculated using the type's <em>radix</em> and the instance's
<em>significand</em> and <em>exponent</em>. This magnitude calculation takes the
following form for a floating-point value <code>x</code> of type <code>F</code>, where <code>**</code> is
exponentiation:</p>
<pre><code class="language-swift">x.significand * F.radix ** x.exponent
</code></pre>
<p>Here's an example of the number -8.5 represented as an instance of the
<code>Double</code> type, which defines a radix of 2.</p>
<pre><code class="language-swift">let y = -8.5
// y.sign == .minus
// y.significand == 1.0625
// y.exponent == 3

let magnitude = 1.0625 * Double(2 ** 3)
// magnitude == 8.5
</code></pre>
<p>Types that conform to the <code>FloatingPoint</code> protocol provide most basic
(clause 5) operations of the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>. The base,
precision, and exponent range are not fixed in any way by this protocol,
but it enforces the basic requirements of any IEEE 754 floating-point
type.</p>
<h3>Additional Considerations</h3>
<p>In addition to representing specific numbers, floating-point types also
have special values for working with overflow and nonnumeric results of
calculation.</p>
<h4>Infinity</h4>
<p>Any value whose magnitude is so great that it would round to a value
outside the range of representable numbers is rounded to <em>infinity</em>. For a
type <code>F</code>, positive and negative infinity are represented as <code>F.infinity</code>
and <code>-F.infinity</code>, respectively. Positive infinity compares greater than
every finite value and negative infinity, while negative infinity compares
less than every finite value and positive infinity. Infinite values with
the same sign are equal to each other.</p>
<pre><code class="language-swift">let values: [Double] = [10.0, 25.0, -10.0, .infinity, -.infinity]
print(values.sorted())
// Prints &quot;[-inf, -10.0, 10.0, 25.0, inf]&quot;
</code></pre>
<p>Operations with infinite values follow real arithmetic as much as possible:
Adding or subtracting a finite value, or multiplying or dividing infinity
by a nonzero finite value, results in infinity.</p>
<h4>NaN (&quot;not a number&quot;)</h4>
<p>Floating-point types represent values that are neither finite numbers nor
infinity as NaN, an abbreviation for &quot;not a number.&quot; Comparing a NaN with
any value, including another NaN, results in <code>false</code>.</p>
<pre><code class="language-swift">let myNaN = Double.nan
print(myNaN &gt; 0)
// Prints &quot;false&quot;
print(myNaN &lt; 0)
// Prints &quot;false&quot;
print(myNaN == .nan)
// Prints &quot;false&quot;
</code></pre>
<p>Because testing whether one NaN is equal to another NaN results in <code>false</code>,
use the <code>isNaN</code> property to test whether a value is NaN.</p>
<pre><code class="language-swift">print(myNaN.isNaN)
// Prints &quot;true&quot;
</code></pre>
<p>NaN propagates through many arithmetic operations. When you are operating
on many values, this behavior is valuable because operations on NaN simply
forward the value and don't cause runtime errors. The following example
shows how NaN values operate in different contexts.</p>
<p>Imagine you have a set of temperature data for which you need to report
some general statistics: the total number of observations, the number of
valid observations, and the average temperature. First, a set of
observations in Celsius is parsed from strings to <code>Double</code> values:</p>
<pre><code class="language-swift">let temperatureData = [&quot;21.5&quot;, &quot;19.25&quot;, &quot;27&quot;, &quot;no data&quot;, &quot;28.25&quot;, &quot;no data&quot;, &quot;23&quot;]
let tempsCelsius = temperatureData.map { Double($0) ?? .nan }
// tempsCelsius == [21.5, 19.25, 27, nan, 28.25, nan, 23.0]
</code></pre>
<p>Note that some elements in the <code>temperatureData </code> array are not valid
numbers. When these invalid strings are parsed by the <code>Double</code> failable
initializer, the example uses the nil-coalescing operator (<code>??</code>) to
provide NaN as a fallback value.</p>
<p>Next, the observations in Celsius are converted to Fahrenheit:</p>
<pre><code class="language-swift">let tempsFahrenheit = tempsCelsius.map { $0 * 1.8 + 32 }
// tempsFahrenheit == [70.7, 66.65, 80.6, nan, 82.85, nan, 73.4]
</code></pre>
<p>The NaN values in the <code>tempsCelsius</code> array are propagated through the
conversion and remain NaN in <code>tempsFahrenheit</code>.</p>
<p>Because calculating the average of the observations involves combining
every value of the <code>tempsFahrenheit</code> array, any NaN values cause the
result to also be NaN, as seen in this example:</p>
<pre><code class="language-swift">let badAverage = tempsFahrenheit.reduce(0.0, combine: +) / Double(tempsFahrenheit.count)
// badAverage.isNaN == true
</code></pre>
<p>Instead, when you need an operation to have a specific numeric result,
filter out any NaN values using the <code>isNaN</code> property.</p>
<pre><code class="language-swift">let validTemps = tempsFahrenheit.filter { !$0.isNaN }
let average = validTemps.reduce(0.0, combine: +) / Double(validTemps.count)
</code></pre>
<p>Finally, report the average temperature and observation counts:</p>
<pre><code class="language-swift">print(&quot;Average: \(average)°F in \(validTemps.count) &quot; +
      &quot;out of \(tempsFahrenheit.count) observations.&quot;)
// Prints &quot;Average: 74.84°F in 5 out of 7 observations.&quot;
</code></pre>
</div><h3>Initializers</h3><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new value, rounded to the closest possible representation.</p>
<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>
<ul>
<li>Parameter value: The integer to convert to a floating-point value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">init(_ value: Int)</code></div></div><div id="init-00a2b987552997ee43208aca83ac6ae6" class="declaration"><a class="toggle-link" href="#comment-init-00a2b987552997ee43208aca83ac6ae6">init init(_:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init-00a2b987552997ee43208aca83ac6ae6"><p>Creates a new value, rounded to the closest possible representation.</p>
<p>If two representable values are equally close, the result is the value
with more trailing zeros in its significand bit pattern.</p>
<ul>
<li>Parameter value: The integer to convert to a floating-point value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">init&lt;Source>(_ value: Source) where Source: BinaryInteger</code></div></div><div id="init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44" class="declaration"><a class="toggle-link" href="#comment-init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44">init init(sign:exponent:significand:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_sign_exponent_significand-8a996c6f36a522fbd7ec9e6a920cef44"><p>Creates a new value from the given sign, exponent, and significand.</p>
<p>The following example uses this initializer to create a new <code>Double</code>
instance. <code>Double</code> is a binary floating-point type that has a radix of
<code>2</code>.</p>
<pre><code class="language-swift">let x = Double(sign: .plus, exponent: -2, significand: 1.5)
// x == 0.375
</code></pre>
<p>This initializer is equivalent to the following calculation, where <code>**</code>
is exponentiation, computed as if by a single, correctly rounded,
floating-point operation:</p>
<pre><code class="language-swift">let sign: FloatingPointSign = .plus
let exponent = -2
let significand = 1.5
let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
// y == 0.375
</code></pre>
<p>As with any basic operation, if this value is outside the representable
range of the type, overflow or underflow occurs, and zero, a subnormal
value, or infinity may result. In addition, there are two other edge
cases:</p>
<p>For any floating-point value <code>x</code> of type <code>F</code>, the result of the following
is equal to <code>x</code>, with the distinction that the result is canonicalized
if <code>x</code> is in a noncanonical encoding:</p>
<pre><code class="language-swift">let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
</code></pre>
<p>This initializer implements the <code>scaleB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">init(sign: FloatingPointSign, exponent: Self.Exponent, significand: Self)</code></div></div><div id="init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37" class="declaration"><a class="toggle-link" href="#comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37">init init(signOf:magnitudeOf:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_signOf_magnitudeOf-24fb2bbabd0abbb63469f0324b0d3e37"><p>Creates a new floating-point value using the sign of one value and the
magnitude of another.</p>
<p>The following example uses this initializer to create a new <code>Double</code>
instance with the sign of <code>a</code> and the magnitude of <code>b</code>:</p>
<pre><code class="language-swift">let a = -21.5
let b = 305.15
let c = Double(signOf: a, magnitudeOf: b)
print(c)
// Prints &quot;-305.15&quot;
</code></pre>
<p>This initializer implements the IEEE 754 <code>copysign</code> operation.</p>
<h4>Declaration</h4><code class="language-swift">init(signOf: Self, magnitudeOf: Self)</code></div></div><div id="init_exactly-204302d00b556e1a402a579cd2a4f8b6" class="declaration"><a class="toggle-link" href="#comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6">init init?(exactly:)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-init_exactly-204302d00b556e1a402a579cd2a4f8b6"><p>Creates a new value, if the given integer can be represented exactly.</p>
<p>If the given integer cannot be represented exactly, the result is <code>nil</code>.</p>
<ul>
<li>Parameter value: The integer to convert to a floating-point value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">init?&lt;Source>(exactly value: Source) where Source: BinaryInteger</code></div></div><h3>Instance Variables</h3><div id="exponent-facd4bc86b7f12740c83bcaa4e75ae0a" class="declaration"><a class="toggle-link" href="#comment-exponent-facd4bc86b7f12740c83bcaa4e75ae0a">var exponent</a> <span class="required">Required</span><div class="comment collapse in" id="comment-exponent-facd4bc86b7f12740c83bcaa4e75ae0a"><p>The exponent of the floating-point value.</p>
<p>The <em>exponent</em> of a floating-point value is the integer part of the
logarithm of the value's magnitude. For a value <code>x</code> of a floating-point
type <code>F</code>, the magnitude can be calculated as the following, where <code>**</code>
is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>
<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2
</code></pre>
<p>The <code>exponent</code> property has the following edge cases:</p>
<p>This property implements the <code>logB</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">var exponent: Self.Exponent</code></div></div><div id="floatingPointClass-00230a995c32af0fa0504c789d9611a8" class="declaration"><a class="toggle-link" href="#comment-floatingPointClass-00230a995c32af0fa0504c789d9611a8">var floatingPointClass</a> <span class="required">Required</span><div class="comment collapse in" id="comment-floatingPointClass-00230a995c32af0fa0504c789d9611a8"><p>The classification of this value.</p>
<p>A value's <code>floatingPointClass</code> property describes its &quot;class&quot; as
described by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">var floatingPointClass: FloatingPointClassification</code></div></div><div id="isCanonical-496dbf394bd7711e683f14e7a9f59cd3" class="declaration"><a class="toggle-link" href="#comment-isCanonical-496dbf394bd7711e683f14e7a9f59cd3">var isCanonical</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isCanonical-496dbf394bd7711e683f14e7a9f59cd3"><p>A Boolean value indicating whether the instance's representation is in
its canonical form.</p>
<p>The <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a> defines a <em>canonical</em>, or preferred,
encoding of a floating-point value. On platforms that fully support
IEEE 754, every <code>Float</code> or <code>Double</code> value is canonical, but
non-canonical values can exist on other platforms or for other types.
Some examples:</p>
<h4>Declaration</h4><code class="language-swift">var isCanonical: Bool</code></div></div><div id="isFinite-9aede8959ec60dfb48af5f9b7655cf62" class="declaration"><a class="toggle-link" href="#comment-isFinite-9aede8959ec60dfb48af5f9b7655cf62">var isFinite</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isFinite-9aede8959ec60dfb48af5f9b7655cf62"><p>A Boolean value indicating whether this instance is finite.</p>
<p>All values other than NaN and infinity are considered finite, whether
normal or subnormal.</p>
<h4>Declaration</h4><code class="language-swift">var isFinite: Bool</code></div></div><div id="isInfinite-52b5d9d6f19c5b9406bde2b919a1a331" class="declaration"><a class="toggle-link" href="#comment-isInfinite-52b5d9d6f19c5b9406bde2b919a1a331">var isInfinite</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isInfinite-52b5d9d6f19c5b9406bde2b919a1a331"><p>A Boolean value indicating whether the instance is infinite.</p>
<p>Note that <code>isFinite</code> and <code>isInfinite</code> do not form a dichotomy, because
they are not total: If <code>x</code> is <code>NaN</code>, then both properties are <code>false</code>.</p>
<h4>Declaration</h4><code class="language-swift">var isInfinite: Bool</code></div></div><div id="isNaN-22f89537344f145d3bff4f753599b846" class="declaration"><a class="toggle-link" href="#comment-isNaN-22f89537344f145d3bff4f753599b846">var isNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isNaN-22f89537344f145d3bff4f753599b846"><p>A Boolean value indicating whether the instance is NaN (&quot;not a number&quot;).</p>
<p>Because NaN is not equal to any value, including NaN, use this property
instead of the equal-to operator (<code>==</code>) or not-equal-to operator (<code>!=</code>)
to test whether a value is or is not NaN. For example:</p>
<pre><code class="language-swift">let x = 0.0
let y = x * .infinity
// y is a NaN

// Comparing with the equal-to operator never returns 'true'
print(x == Double.nan)
// Prints &quot;false&quot;
print(y == Double.nan)
// Prints &quot;false&quot;

// Test with the 'isNaN' property instead
print(x.isNaN)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;
</code></pre>
<p>This property is <code>true</code> for both quiet and signaling NaNs.</p>
<h4>Declaration</h4><code class="language-swift">var isNaN: Bool</code></div></div><div id="isNormal-55cbe981d89818d253fad00235c2bdbf" class="declaration"><a class="toggle-link" href="#comment-isNormal-55cbe981d89818d253fad00235c2bdbf">var isNormal</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isNormal-55cbe981d89818d253fad00235c2bdbf"><p>A Boolean value indicating whether this instance is normal.</p>
<p>A <em>normal</em> value is a finite number that uses the full precision
available to values of a type. Zero is neither a normal nor a subnormal
number.</p>
<h4>Declaration</h4><code class="language-swift">var isNormal: Bool</code></div></div><div id="isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9" class="declaration"><a class="toggle-link" href="#comment-isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9">var isSignalingNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isSignalingNaN-ba18f9be9b2247d30b5f7a8cd0cbd1c9"><p>A Boolean value indicating whether the instance is a signaling NaN.</p>
<p>Signaling NaNs typically raise the Invalid flag when used in general
computing operations.</p>
<h4>Declaration</h4><code class="language-swift">var isSignalingNaN: Bool</code></div></div><div id="isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836" class="declaration"><a class="toggle-link" href="#comment-isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836">var isSubnormal</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isSubnormal-4216ad0c84ddd8dfa1b137a5163c3836"><p>A Boolean value indicating whether the instance is subnormal.</p>
<p>A <em>subnormal</em> value is a nonzero number that has a lesser magnitude than
the smallest normal number. Subnormal values do not use the full
precision available to values of a type.</p>
<p>Zero is neither a normal nor a subnormal number. Subnormal numbers are
often called <em>denormal</em> or <em>denormalized</em>---these are different names
for the same concept.</p>
<h4>Declaration</h4><code class="language-swift">var isSubnormal: Bool</code></div></div><div id="isZero-855b2871ffd10a823656f50f04eab650" class="declaration"><a class="toggle-link" href="#comment-isZero-855b2871ffd10a823656f50f04eab650">var isZero</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isZero-855b2871ffd10a823656f50f04eab650"><p>A Boolean value indicating whether the instance is equal to zero.</p>
<p>The <code>isZero</code> property of a value <code>x</code> is <code>true</code> when <code>x</code> represents either
<code>-0.0</code> or <code>+0.0</code>. <code>x.isZero</code> is equivalent to the following comparison:
<code>x == 0.0</code>.</p>
<pre><code class="language-swift">let x = -0.0
x.isZero        // true
x == 0.0        // true
</code></pre>
<h4>Declaration</h4><code class="language-swift">var isZero: Bool</code></div></div><div id="nextDown-b451116f6d7f3aa5e5b36f360f232ce0" class="declaration"><a class="toggle-link" href="#comment-nextDown-b451116f6d7f3aa5e5b36f360f232ce0">var nextDown</a> <span class="required">Required</span><div class="comment collapse in" id="comment-nextDown-b451116f6d7f3aa5e5b36f360f232ce0"><p>The greatest representable value that compares less than this value.</p>
<p>For any finite value <code>x</code>, <code>x.nextDown</code> is less than <code>x</code>. For <code>nan</code> or
<code>-infinity</code>, <code>x.nextDown</code> is <code>x</code> itself. The following special cases
also apply:</p>
<h4>Declaration</h4><code class="language-swift">var nextDown: Self</code></div></div><div id="nextUp-1e8421452662292aabe5179fd6f2b60b" class="declaration"><a class="toggle-link" href="#comment-nextUp-1e8421452662292aabe5179fd6f2b60b">var nextUp</a> <span class="required">Required</span><div class="comment collapse in" id="comment-nextUp-1e8421452662292aabe5179fd6f2b60b"><p>The least representable value that compares greater than this value.</p>
<p>For any finite value <code>x</code>, <code>x.nextUp</code> is greater than <code>x</code>. For <code>nan</code> or
<code>infinity</code>, <code>x.nextUp</code> is <code>x</code> itself. The following special cases also
apply:</p>
<h4>Declaration</h4><code class="language-swift">var nextUp: Self</code></div></div><div id="sign-04b29480233f4def5c875875b6bdc3b1" class="declaration"><a class="toggle-link" href="#comment-sign-04b29480233f4def5c875875b6bdc3b1">var sign</a> <span class="required">Required</span><div class="comment collapse in" id="comment-sign-04b29480233f4def5c875875b6bdc3b1"><p>The sign of the floating-point value.</p>
<p>The <code>sign</code> property is <code>.minus</code> if the value's signbit is set, and
<code>.plus</code> otherwise. For example:</p>
<pre><code class="language-swift">let x = -33.375
// x.sign == .minus
</code></pre>
<p>Do not use this property to check whether a floating point value is
negative. For a value <code>x</code>, the comparison <code>x.sign == .minus</code> is not
necessarily the same as <code>x &lt; 0</code>. In particular, <code>x.sign == .minus</code> if
<code>x</code> is -0, and while <code>x &lt; 0</code> is always <code>false</code> if <code>x</code> is NaN, <code>x.sign</code>
could be either <code>.plus</code> or <code>.minus</code>.</p>
<h4>Declaration</h4><code class="language-swift">var sign: FloatingPointSign</code></div></div><div id="significand-a87164f046fa355362627965a390529a" class="declaration"><a class="toggle-link" href="#comment-significand-a87164f046fa355362627965a390529a">var significand</a> <span class="required">Required</span><div class="comment collapse in" id="comment-significand-a87164f046fa355362627965a390529a"><p>The significand of the floating-point value.</p>
<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>In the next example, <code>y</code> has a value of <code>21.5</code>, which is encoded as
<code>1.34375 * 2 ** 4</code>. The significand of <code>y</code> is therefore 1.34375.</p>
<pre><code class="language-swift">let y: Double = 21.5
// y.significand == 1.34375
// y.exponent == 4
// Double.radix == 2
</code></pre>
<p>If a type's radix is 2, then for finite nonzero numbers, the significand
is in the range <code>1.0 ..&lt; 2.0</code>. For other values of <code>x</code>, <code>x.significand</code>
is defined as follows:</p>
<blockquote>
<p>Note:
The significand is frequently also called the <em>mantissa</em>, but significand is the preferred terminology in the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>, to allay confusion with the use of mantissa for the fractional part of a logarithm.</p>
</blockquote>
<h4>Declaration</h4><code class="language-swift">var significand: Self</code></div></div><div id="ulp-728996853f295d0206575099f828878b" class="declaration"><a class="toggle-link" href="#comment-ulp-728996853f295d0206575099f828878b">var ulp</a> <span class="required">Required</span><div class="comment collapse in" id="comment-ulp-728996853f295d0206575099f828878b"><p>The unit in the last place of this value.</p>
<p>This is the unit of the least significant digit in this value's
significand. For most numbers <code>x</code>, this is the difference between <code>x</code>
and the next greater (in magnitude) representable number. There are some
edge cases to be aware of:</p>
<p>See also the <code>ulpOfOne</code> static property.</p>
<h4>Declaration</h4><code class="language-swift">var ulp: Self</code></div></div><h3>Instance Methods</h3><div id="addProduct-d1e8cd01a46534de278032de1e0a589b" class="declaration"><a class="toggle-link" href="#comment-addProduct-d1e8cd01a46534de278032de1e0a589b">func addProduct(_ lhs: Self, _ rhs: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-addProduct-d1e8cd01a46534de278032de1e0a589b"><p>Adds the product of the two given values to this value in place, computed
without intermediate rounding.</p>
<h4>Declaration</h4><code class="language-swift">mutating func addProduct(_ lhs: Self, _ rhs: Self)</code></div></div><div id="addingProduct-22e9b1c2a16b17dde82231b945d038e7" class="declaration"><a class="toggle-link" href="#comment-addingProduct-22e9b1c2a16b17dde82231b945d038e7">func addingProduct(_ lhs: Self, _ rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-addingProduct-22e9b1c2a16b17dde82231b945d038e7"><p>Returns the result of adding the product of the two given values to this
value, computed without intermediate rounding.</p>
<p>This method is equivalent to the C <code>fma</code> function and implements the
<code>fusedMultiplyAdd</code> operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754
specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">func addingProduct(_ lhs: Self, _ rhs: Self) -> Self</code></div></div><div id="formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40" class="declaration"><a class="toggle-link" href="#comment-formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40">func formRemainder(dividingBy other: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formRemainder_dividingBy-084516b868a4ae24b5d185ff3349ff40"><p>Replaces this value with the remainder of itself divided by the given
value.</p>
<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>
<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>
<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
x.formRemainder(dividingBy: 0.75)
// x == -0.375

let x1 = 0.75 * q + x
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>formRemainder(dividingBy:)</code> method is always exact.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">mutating func formRemainder(dividingBy other: Self)</code></div></div><div id="formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142" class="declaration"><a class="toggle-link" href="#comment-formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142">func formSquareRoot()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formSquareRoot-5df96f5f4c7605a45e7391bf95fe1142"><p>Replaces this value with its square root, rounded to a representable
value.</p>
<h4>Declaration</h4><code class="language-swift">mutating func formSquareRoot()</code></div></div><div id="formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb" class="declaration"><a class="toggle-link" href="#comment-formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb">func formTruncatingRemainder(dividingBy other: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-formTruncatingRemainder_dividingBy-9dbc4e396209372a377f458bed5b97fb"><p>Replaces this value with the remainder of itself divided by the given
value using truncating division.</p>
<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>
<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>
<pre><code class="language-swift">var x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
x.formTruncatingRemainder(dividingBy: 0.75)
// x == 0.375

let x1 = 0.75 * q + x
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>formTruncatingRemainder(dividingBy:)</code>
method is always exact.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">mutating func formTruncatingRemainder(dividingBy other: Self)</code></div></div><div id="isEqual_to-9c853bc759a05cded4f822d60eda686d" class="declaration"><a class="toggle-link" href="#comment-isEqual_to-9c853bc759a05cded4f822d60eda686d">func isEqual(to other: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isEqual_to-9c853bc759a05cded4f822d60eda686d"><p>Returns a Boolean value indicating whether this instance is equal to the
given value.</p>
<p>This method serves as the basis for the equal-to operator (<code>==</code>) for
floating-point values. When comparing two values with this method, <code>-0</code>
is equal to <code>+0</code>. NaN is not equal to any value, including itself. For
example:</p>
<pre><code class="language-swift">let x = 15.0
x.isEqual(to: 15.0)
// true
x.isEqual(to: .nan)
// false
Double.nan.isEqual(to: .nan)
// false
</code></pre>
<p>The <code>isEqual(to:)</code> method implements the equality predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func isEqual(to other: Self) -> Bool</code></div></div><div id="isLess_than-324467f7318bc8547b96c1bbd9e0225e" class="declaration"><a class="toggle-link" href="#comment-isLess_than-324467f7318bc8547b96c1bbd9e0225e">func isLess(than other: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isLess_than-324467f7318bc8547b96c1bbd9e0225e"><p>Returns a Boolean value indicating whether this instance is less than the
given value.</p>
<p>This method serves as the basis for the less-than operator (<code>&lt;</code>) for
floating-point values. Some special cases apply:</p>
<p>The <code>isLess(than:)</code> method implements the less-than predicate defined by
the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func isLess(than other: Self) -> Bool</code></div></div><div id="isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402" class="declaration"><a class="toggle-link" href="#comment-isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402">func isLessThanOrEqualTo(_ other: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isLessThanOrEqualTo-fceb3062507b90f02d1fdab02bcec402"><p>Returns a Boolean value indicating whether this instance is less than or
equal to the given value.</p>
<p>This method serves as the basis for the less-than-or-equal-to operator
(<code>&lt;=</code>) for floating-point values. Some special cases apply:</p>
<p>The <code>isLessThanOrEqualTo(_:)</code> method implements the less-than-or-equal
predicate defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to compare with this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func isLessThanOrEqualTo(_ other: Self) -> Bool</code></div></div><div id="isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df" class="declaration"><a class="toggle-link" href="#comment-isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df">func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool</a> <span class="required">Required</span><div class="comment collapse in" id="comment-isTotallyOrdered_belowOrEqualTo-dc04731cb290ca0bf4c11837c82855df"><p>Returns a Boolean value indicating whether this instance should precede
or tie positions with the given value in an ascending sort.</p>
<p>This relation is a refinement of the less-than-or-equal-to operator
(<code>&lt;=</code>) that provides a total order on all values of the type, including
signed zeros and NaNs.</p>
<p>The following example uses <code>isTotallyOrdered(belowOrEqualTo:)</code> to sort an
array of floating-point values, including some that are NaN:</p>
<pre><code class="language-swift">var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
// numbers == [-9.5, 2.5, 3.0, 21.25, NaN]
</code></pre>
<p>The <code>isTotallyOrdered(belowOrEqualTo:)</code> method implements the total order
relation as defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: A floating-point value to compare to this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool</code></div></div><div id="negate-ada771fd0d039b67f84e7cb6b918b531" class="declaration"><a class="toggle-link" href="#comment-negate-ada771fd0d039b67f84e7cb6b918b531">func negate()</a> <span class="required">Required</span><div class="comment collapse in" id="comment-negate-ada771fd0d039b67f84e7cb6b918b531"><p>Replaces this value with its additive inverse.</p>
<p>The result is always exact. This example uses the <code>negate()</code> method to
negate the value of the variable <code>x</code>:</p>
<pre><code class="language-swift">var x = 21.5
x.negate()
// x == -21.5
</code></pre>
<h4>Declaration</h4><code class="language-swift">override mutating func negate()</code></div></div><div id="remainder_dividingBy-32ec22de2ecb5168b3833a5049c12148" class="declaration"><a class="toggle-link" href="#comment-remainder_dividingBy-32ec22de2ecb5168b3833a5049c12148">func remainder(dividingBy other: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-remainder_dividingBy-32ec22de2ecb5168b3833a5049c12148"><p>Returns the remainder of this value divided by the given value.</p>
<p>For two finite values <code>x</code> and <code>y</code>, the remainder <code>r</code> of dividing <code>x</code> by
<code>y</code> satisfies <code>x == y * q + r</code>, where <code>q</code> is the integer nearest to
<code>x / y</code>. If <code>x / y</code> is exactly halfway between two integers, <code>q</code> is
chosen to be even. Note that <code>q</code> is <em>not</em> <code>x / y</code> computed in
floating-point arithmetic, and that <code>q</code> may not be representable in any
available integer type.</p>
<p>The following example calculates the remainder of dividing 8.625 by 0.75:</p>
<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.toNearestOrEven)
// q == 12.0
let r = x.remainder(dividingBy: 0.75)
// r == -0.375

let x1 = 0.75 * q + r
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are finite numbers, the remainder is in the
closed range <code>-abs(other / 2)...abs(other / 2)</code>. The
<code>remainder(dividingBy:)</code> method is always exact. This method implements
the remainder operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func remainder(dividingBy other: Self) -> Self</code></div></div><div id="round-f18d6f018f1e4ca890eaf7d0d66152fd" class="declaration"><a class="toggle-link" href="#comment-round-f18d6f018f1e4ca890eaf7d0d66152fd">func round(_ rule: FloatingPointRoundingRule)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-round-f18d6f018f1e4ca890eaf7d0d66152fd"><p>Rounds the value to an integral value using the specified rounding rule.</p>
<p>The following example rounds a value using four different rounding rules:</p>
<pre><code class="language-swift">// Equivalent to the C 'round' function:
var w = 6.5
w.round(.toNearestOrAwayFromZero)
// w == 7.0

// Equivalent to the C 'trunc' function:
var x = 6.5
x.round(.towardZero)
// x == 6.0

// Equivalent to the C 'ceil' function:
var y = 6.5
y.round(.up)
// y == 7.0

// Equivalent to the C 'floor' function:
var z = 6.5
z.round(.down)
// z == 6.0
</code></pre>
<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>round()</code> method
instead.</p>
<pre><code class="language-swift">var w1 = 6.5
w1.round()
// w1 == 7.0
</code></pre>
<ul>
<li>Parameter rule: The rounding rule to use.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">mutating func round(_ rule: FloatingPointRoundingRule)</code></div></div><div id="rounded-8d9d441602090fca798b337a34709bc0" class="declaration"><a class="toggle-link" href="#comment-rounded-8d9d441602090fca798b337a34709bc0">func rounded(_ rule: FloatingPointRoundingRule) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-rounded-8d9d441602090fca798b337a34709bc0"><p>Returns this value rounded to an integral value using the specified
rounding rule.</p>
<p>The following example rounds a value using four different rounding rules:</p>
<pre><code class="language-swift">let x = 6.5

// Equivalent to the C 'round' function:
print(x.rounded(.toNearestOrAwayFromZero))
// Prints &quot;7.0&quot;

// Equivalent to the C 'trunc' function:
print(x.rounded(.towardZero))
// Prints &quot;6.0&quot;

// Equivalent to the C 'ceil' function:
print(x.rounded(.up))
// Prints &quot;7.0&quot;

// Equivalent to the C 'floor' function:
print(x.rounded(.down))
// Prints &quot;6.0&quot;
</code></pre>
<p>For more information about the available rounding rules, see the
<code>FloatingPointRoundingRule</code> enumeration. To round a value using the
default &quot;schoolbook rounding&quot;, you can use the shorter <code>rounded()</code>
method instead.</p>
<pre><code class="language-swift">print(x.rounded())
// Prints &quot;7.0&quot;
</code></pre>
<ul>
<li>Parameter rule: The rounding rule to use.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func rounded(_ rule: FloatingPointRoundingRule) -> Self</code></div></div><div id="squareRoot-758e5499d843284d75609b85efd0257c" class="declaration"><a class="toggle-link" href="#comment-squareRoot-758e5499d843284d75609b85efd0257c">func squareRoot() -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-squareRoot-758e5499d843284d75609b85efd0257c"><p>Returns the square root of the value, rounded to a representable value.</p>
<p>The following example declares a function that calculates the length of
the hypotenuse of a right triangle given its two perpendicular sides.</p>
<pre><code class="language-swift">func hypotenuse(_ a: Double, _ b: Double) -&gt; Double {
    return (a * a + b * b).squareRoot()
}

let (dx, dy) = (3.0, 4.0)
let distance = hypotenuse(dx, dy)
// distance == 5.0
</code></pre>
<h4>Declaration</h4><code class="language-swift">func squareRoot() -> Self</code></div></div><div id="truncatingRemainder_dividingBy-0357251679c8e5993478aa833e95150a" class="declaration"><a class="toggle-link" href="#comment-truncatingRemainder_dividingBy-0357251679c8e5993478aa833e95150a">func truncatingRemainder(dividingBy other: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-truncatingRemainder_dividingBy-0357251679c8e5993478aa833e95150a"><p>Returns the remainder of this value divided by the given value using
truncating division.</p>
<p>Performing truncating division with floating-point values results in a
truncated integer quotient and a remainder. For values <code>x</code> and <code>y</code> and
their truncated integer quotient <code>q</code>, the remainder <code>r</code> satisfies
<code>x == y * q + r</code>.</p>
<p>The following example calculates the truncating remainder of dividing
8.625 by 0.75:</p>
<pre><code class="language-swift">let x = 8.625
print(x / 0.75)
// Prints &quot;11.5&quot;

let q = (x / 0.75).rounded(.towardZero)
// q == 11.0
let r = x.truncatingRemainder(dividingBy: 0.75)
// r == 0.375

let x1 = 0.75 * q + r
// x1 == 8.625
</code></pre>
<p>If this value and <code>other</code> are both finite numbers, the truncating
remainder has the same sign as this value and is strictly smaller in
magnitude than <code>other</code>. The <code>truncatingRemainder(dividingBy:)</code> method
is always exact.</p>
<ul>
<li>Parameter other: The value to use when dividing this value.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">func truncatingRemainder(dividingBy other: Self) -> Self</code></div></div><h3>Type Variables</h3><div id="greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8" class="declaration"><a class="toggle-link" href="#comment-greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8">var greatestFiniteMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-greatestFiniteMagnitude-a5611015cd7140602cac6e5a9dae2df8"><p>The greatest finite number representable by this type.</p>
<p>This value compares greater than or equal to all finite numbers, but less
than <code>infinity</code>.</p>
<p>This value corresponds to type-specific C macros such as <code>FLT_MAX</code> and
<code>DBL_MAX</code>. The naming of those macros is slightly misleading, because
<code>infinity</code> is greater than this value.</p>
<h4>Declaration</h4><code class="language-swift">var greatestFiniteMagnitude: Self</code></div></div><div id="infinity-f2fdee93271556e428dd9507b3da7235" class="declaration"><a class="toggle-link" href="#comment-infinity-f2fdee93271556e428dd9507b3da7235">var infinity</a> <span class="required">Required</span><div class="comment collapse in" id="comment-infinity-f2fdee93271556e428dd9507b3da7235"><p>Positive infinity.</p>
<p>Infinity compares greater than all finite numbers and equal to other
infinite values.</p>
<pre><code class="language-swift">let x = Double.greatestFiniteMagnitude
let y = x * 2
// y == Double.infinity
// y &gt; x
</code></pre>
<h4>Declaration</h4><code class="language-swift">var infinity: Self</code></div></div><div id="leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7" class="declaration"><a class="toggle-link" href="#comment-leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7">var leastNonzeroMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-leastNonzeroMagnitude-6df11d9257efa1a9b95f4f642eff59f7"><p>The least positive number.</p>
<p>This value compares less than or equal to all positive numbers, but
greater than zero. If the type supports subnormal values,
<code>leastNonzeroMagnitude</code> is smaller than <code>leastNormalMagnitude</code>;
otherwise they are equal.</p>
<h4>Declaration</h4><code class="language-swift">var leastNonzeroMagnitude: Self</code></div></div><div id="leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22" class="declaration"><a class="toggle-link" href="#comment-leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22">var leastNormalMagnitude</a> <span class="required">Required</span><div class="comment collapse in" id="comment-leastNormalMagnitude-cd8056bb382626d023f1b51eedc73e22"><p>The least positive normal number.</p>
<p>This value compares less than or equal to all positive normal numbers.
There may be smaller positive numbers, but they are <em>subnormal</em>, meaning
that they are represented with less precision than normal numbers.</p>
<p>This value corresponds to type-specific C macros such as <code>FLT_MIN</code> and
<code>DBL_MIN</code>. The naming of those macros is slightly misleading, because
subnormals, zeros, and negative numbers are smaller than this value.</p>
<h4>Declaration</h4><code class="language-swift">var leastNormalMagnitude: Self</code></div></div><div id="nan-a3d2de7675556553a5f08e4c88d2c228" class="declaration"><a class="toggle-link" href="#comment-nan-a3d2de7675556553a5f08e4c88d2c228">var nan</a> <span class="required">Required</span><div class="comment collapse in" id="comment-nan-a3d2de7675556553a5f08e4c88d2c228"><p>A quiet NaN (&quot;not a number&quot;).</p>
<p>A NaN compares not equal, not greater than, and not less than every
value, including itself. Passing a NaN to an operation generally results
in NaN.</p>
<pre><code class="language-swift">let x = 1.21
// x &gt; Double.nan == false
// x &lt; Double.nan == false
// x == Double.nan == false
</code></pre>
<p>Because a NaN always compares not equal to itself, to test whether a
floating-point value is NaN, use its <code>isNaN</code> property instead of the
equal-to operator (<code>==</code>). In the following example, <code>y</code> is NaN.</p>
<pre><code class="language-swift">let y = x + Double.nan
print(y == Double.nan)
// Prints &quot;false&quot;
print(y.isNaN)
// Prints &quot;true&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">var nan: Self</code></div></div><div id="pi-72ab8af56bddab33b269c5964b26620a" class="declaration"><a class="toggle-link" href="#comment-pi-72ab8af56bddab33b269c5964b26620a">var pi</a> <span class="required">Required</span><div class="comment collapse in" id="comment-pi-72ab8af56bddab33b269c5964b26620a"><p>The mathematical constant pi.</p>
<p>This value should be rounded toward zero to keep user computations with
angles from inadvertently ending up in the wrong quadrant. A type that
conforms to the <code>FloatingPoint</code> protocol provides the value for <code>pi</code> at
its best possible precision.</p>
<pre><code class="language-swift">print(Double.pi)
// Prints &quot;3.14159265358979&quot;
</code></pre>
<h4>Declaration</h4><code class="language-swift">var pi: Self</code></div></div><div id="radix-be4ecdb8a8ebc5a7a7740d21d2b71462" class="declaration"><a class="toggle-link" href="#comment-radix-be4ecdb8a8ebc5a7a7740d21d2b71462">var radix</a> <span class="required">Required</span><div class="comment collapse in" id="comment-radix-be4ecdb8a8ebc5a7a7740d21d2b71462"><p>The radix, or base of exponentiation, for a floating-point type.</p>
<p>The magnitude of a floating-point value <code>x</code> of type <code>F</code> can be calculated
by using the following formula, where <code>**</code> is exponentiation:</p>
<pre><code class="language-swift">let magnitude = x.significand * F.radix ** x.exponent
</code></pre>
<p>A conforming type may use any integer radix, but values other than 2 (for
binary floating-point types) or 10 (for decimal floating-point types)
are extraordinarily rare in practice.</p>
<h4>Declaration</h4><code class="language-swift">var radix: Int</code></div></div><div id="signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc" class="declaration"><a class="toggle-link" href="#comment-signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc">var signalingNaN</a> <span class="required">Required</span><div class="comment collapse in" id="comment-signalingNaN-fd9e20341e8ac5e2f963ae8d4a8a0fbc"><p>A signaling NaN (&quot;not a number&quot;).</p>
<p>The default IEEE 754 behavior of operations involving a signaling NaN is
to raise the Invalid flag in the floating-point environment and return a
quiet NaN.</p>
<p>Operations on types conforming to the <code>FloatingPoint</code> protocol should
support this behavior, but they might also support other options. For
example, it would be reasonable to implement alternative operations in
which operating on a signaling NaN triggers a runtime error or results
in a diagnostic for debugging purposes. Types that implement alternative
behaviors for a signaling NaN must document the departure.</p>
<p>Other than these signaling operations, a signaling NaN behaves in the
same manner as a quiet NaN.</p>
<h4>Declaration</h4><code class="language-swift">var signalingNaN: Self</code></div></div><div id="ulpOfOne-c793570339d0de8d802fbd69ee826318" class="declaration"><a class="toggle-link" href="#comment-ulpOfOne-c793570339d0de8d802fbd69ee826318">var ulpOfOne</a> <span class="required">Required</span><div class="comment collapse in" id="comment-ulpOfOne-c793570339d0de8d802fbd69ee826318"><p>The unit in the last place of 1.0.</p>
<p>The positive difference between 1.0 and the next greater representable
number. <code>ulpOfOne</code> corresponds to the value represented by the C macros
<code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, etc, and is sometimes called <em>epsilon</em> or
<em>machine epsilon</em>. Swift deliberately avoids using the term &quot;epsilon&quot;
because:</p>
<p>See also the <code>ulp</code> member property.</p>
<h4>Declaration</h4><code class="language-swift">var ulpOfOne: Self</code></div></div><h3>Type Methods</h3><div id="lhs_rhs-471d936295383220ce00ec7c8a571f42" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-471d936295383220ce00ec7c8a571f42">func *(lhs: Self, rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-471d936295383220ce00ec7c8a571f42"><p>Multiplies two values and produces their product, rounding to a
representable value.</p>
<p>The multiplication operator (<code>*</code>) calculates the product of its two
arguments. For example:</p>
<pre><code class="language-swift">let x = 7.5
let y = x * 2.25
// y == 16.875
</code></pre>
<p>The <code>*</code> operator implements the multiplication operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">override static func *(lhs: Self, rhs: Self) -> Self</code></div></div><div id="lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb">func *=(lhs: inout Self, rhs: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-8a5fdcc6ae3e13bcb603f4e5929012eb"><p>Multiplies two values and stores the result in the left-hand-side
variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">override static func *=(lhs: inout Self, rhs: Self)</code></div></div><div id="lhs_rhs-1ace6c0ccceecc18799beae40fae2402" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402">func +(lhs: Self, rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-1ace6c0ccceecc18799beae40fae2402"><p>Adds two values and produces their sum, rounded to a
representable value.</p>
<p>The addition operator (<code>+</code>) calculates the sum of its two arguments. For
example:</p>
<pre><code class="language-swift">let x = 1.5
let y = x + 2.25
// y == 3.75
</code></pre>
<p>The <code>+</code> operator implements the addition operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">override static func +(lhs: Self, rhs: Self) -> Self</code></div></div><div id="lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb">func +=(lhs: inout Self, rhs: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-7b743b7b721afe0b0efa21dcf331e0fb"><p>Adds two values and stores the result in the left-hand-side variable,
rounded to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">override static func +=(lhs: inout Self, rhs: Self)</code></div></div><div id="lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde">func -(lhs: Self, rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-d3d9eeb5284a9f8a3101d48d6c5f5dde"><p>Subtracts one value from another and produces their difference, rounded
to a representable value.</p>
<p>The subtraction operator (<code>-</code>) calculates the difference of its two
arguments. For example:</p>
<pre><code class="language-swift">let x = 7.5
let y = x - 2.25
// y == 5.25
</code></pre>
<p>The <code>-</code> operator implements the subtraction operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">override static func -(lhs: Self, rhs: Self) -> Self</code></div></div><div id="operand-8bde332541948a47038eb83ee7a0fde5" class="declaration"><a class="toggle-link" href="#comment-operand-8bde332541948a47038eb83ee7a0fde5">func -(operand: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-operand-8bde332541948a47038eb83ee7a0fde5"><p>Calculates the additive inverse of a value.</p>
<p>The unary minus operator (prefix <code>-</code>) calculates the negation of its
operand. The result is always exact.</p>
<pre><code class="language-swift">let x = 21.5
let y = -x
// y == -21.5
</code></pre>
<ul>
<li>Parameter operand: The value to negate.</li>
</ul>
<h4>Declaration</h4><code class="language-swift">override prefix static func -(operand: Self) -> Self</code></div></div><div id="lhs_rhs-265a6353740687d540f523762f8cf760" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-265a6353740687d540f523762f8cf760">func -=(lhs: inout Self, rhs: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-265a6353740687d540f523762f8cf760"><p>Subtracts the second value from the first and stores the difference in
the left-hand-side variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">override static func -=(lhs: inout Self, rhs: Self)</code></div></div><div id="lhs_rhs-8d3e01dd5aadf72b5d7233c057966993" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-8d3e01dd5aadf72b5d7233c057966993">func /(lhs: Self, rhs: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-8d3e01dd5aadf72b5d7233c057966993"><p>Returns the quotient of dividing the first value by the second, rounded
to a representable value.</p>
<p>The division operator (<code>/</code>) calculates the quotient of the division if
<code>rhs</code> is nonzero. If <code>rhs</code> is zero, the result of the division is
infinity, with the sign of the result matching the sign of <code>lhs</code>.</p>
<pre><code class="language-swift">let x = 16.875
let y = x / 2.25
// y == 7.5

let z = x / 0
// z.isInfinite == true
</code></pre>
<p>The <code>/</code> operator implements the division operation defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE
754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">static func /(lhs: Self, rhs: Self) -> Self</code></div></div><div id="lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d" class="declaration"><a class="toggle-link" href="#comment-lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d">func /=(lhs: inout Self, rhs: Self)</a> <span class="required">Required</span><div class="comment collapse in" id="comment-lhs_rhs-17bbf440b6b9ae5c2d374738ec64963d"><p>Divides the first value by the second and stores the quotient in the
left-hand-side variable, rounding to a representable value.</p>
<h4>Declaration</h4><code class="language-swift">static func /=(lhs: inout Self, rhs: Self)</code></div></div><div id="maximum-cf2a7e4bda8846b626f4ff4877c3eb87" class="declaration"><a class="toggle-link" href="#comment-maximum-cf2a7e4bda8846b626f4ff4877c3eb87">func maximum(_ x: Self, _ y: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-maximum-cf2a7e4bda8846b626f4ff4877c3eb87"><p>Returns the greater of the two given values.</p>
<p>This method returns the maximum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>maximum(x, y)</code> is <code>x</code> if <code>x &gt; y</code>, <code>y</code> if <code>x &lt;= y</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>
<pre><code class="language-swift">Double.maximum(10.0, -25.0)
// 10.0
Double.maximum(10.0, .nan)
// 10.0
Double.maximum(.nan, -25.0)
// -25.0
Double.maximum(.nan, .nan)
// nan
</code></pre>
<p>The <code>maximum</code> method implements the <code>maxNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">static func maximum(_ x: Self, _ y: Self) -> Self</code></div></div><div id="maximumMagnitude-44d17abc5af0293aec39a1980777f27f" class="declaration"><a class="toggle-link" href="#comment-maximumMagnitude-44d17abc5af0293aec39a1980777f27f">func maximumMagnitude(_ x: Self, _ y: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-maximumMagnitude-44d17abc5af0293aec39a1980777f27f"><p>Returns the value with greater magnitude.</p>
<p>This method returns the value with greater magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>maximumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &gt; y.magnitude</code>, <code>y</code> if <code>x.magnitude &lt;= y.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>
<pre><code class="language-swift">Double.maximumMagnitude(10.0, -25.0)
// -25.0
Double.maximumMagnitude(10.0, .nan)
// 10.0
Double.maximumMagnitude(.nan, -25.0)
// -25.0
Double.maximumMagnitude(.nan, .nan)
// nan
</code></pre>
<p>The <code>maximumMagnitude</code> method implements the <code>maxNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">static func maximumMagnitude(_ x: Self, _ y: Self) -> Self</code></div></div><div id="minimum-229aac545847e9beab3607876bd6fd7a" class="declaration"><a class="toggle-link" href="#comment-minimum-229aac545847e9beab3607876bd6fd7a">func minimum(_ x: Self, _ y: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-minimum-229aac545847e9beab3607876bd6fd7a"><p>Returns the lesser of the two given values.</p>
<p>This method returns the minimum of two values, preserving order and
eliminating NaN when possible. For two values <code>x</code> and <code>y</code>, the result of
<code>minimum(x, y)</code> is <code>x</code> if <code>x &lt;= y</code>, <code>y</code> if <code>y &lt; x</code>, or whichever of <code>x</code>
or <code>y</code> is a number if the other is a quiet NaN. If both <code>x</code> and <code>y</code> are
NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result is NaN.</p>
<pre><code class="language-swift">Double.minimum(10.0, -25.0)
// -25.0
Double.minimum(10.0, .nan)
// 10.0
Double.minimum(.nan, -25.0)
// -25.0
Double.minimum(.nan, .nan)
// nan
</code></pre>
<p>The <code>minimum</code> method implements the <code>minNum</code> operation defined by the
<a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">static func minimum(_ x: Self, _ y: Self) -> Self</code></div></div><div id="minimumMagnitude-810a69fa1618c5f5811221aa0d24a839" class="declaration"><a class="toggle-link" href="#comment-minimumMagnitude-810a69fa1618c5f5811221aa0d24a839">func minimumMagnitude(_ x: Self, _ y: Self) -> Self</a> <span class="required">Required</span><div class="comment collapse in" id="comment-minimumMagnitude-810a69fa1618c5f5811221aa0d24a839"><p>Returns the value with lesser magnitude.</p>
<p>This method returns the value with lesser magnitude of the two given
values, preserving order and eliminating NaN when possible. For two
values <code>x</code> and <code>y</code>, the result of <code>minimumMagnitude(x, y)</code> is <code>x</code> if
<code>x.magnitude &lt;= y.magnitude</code>, <code>y</code> if <code>y.magnitude &lt; x.magnitude</code>, or
whichever of <code>x</code> or <code>y</code> is a number if the other is a quiet NaN. If both
<code>x</code> and <code>y</code> are NaN, or either <code>x</code> or <code>y</code> is a signaling NaN, the result
is NaN.</p>
<pre><code class="language-swift">Double.minimumMagnitude(10.0, -25.0)
// 10.0
Double.minimumMagnitude(10.0, .nan)
// 10.0
Double.minimumMagnitude(.nan, -25.0)
// -25.0
Double.minimumMagnitude(.nan, .nan)
// nan
</code></pre>
<p>The <code>minimumMagnitude</code> method implements the <code>minNumMag</code> operation
defined by the <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754 specification</a>.</p>
<h4>Declaration</h4><code class="language-swift">static func minimumMagnitude(_ x: Self, _ y: Self) -> Self</code></div></div><h3>Default Implementations</h3><div id="operand-8bde332541948a47038eb83ee7a0fde5" class="declaration"><a class="toggle-link" href="#comment-operand-8bde332541948a47038eb83ee7a0fde5">func -(operand: Self) -> Self</a> <div class="comment collapse in" id="comment-operand-8bde332541948a47038eb83ee7a0fde5"><p>Returns the additive inverse of the specified value.</p>
<p>The negation operator (prefix <code>-</code>) returns the additive inverse of its
argument.</p>
<pre><code class="language-swift">let x = 21
let y = -x
// y == -21
</code></pre>
<p>The resulting value must be representable in the same type as the
argument. In particular, negating a signed, fixed-width integer type's
minimum results in a value that cannot be represented.</p>
<pre><code class="language-swift">let z = -Int8.min
// Overflow error
</code></pre>
<h4>Declaration</h4><code class="language-swift">prefix public static func -(operand: Self) -> Self</code></div></div><div id="x_y-4804d4748c34357d4373b49c8403cd1d" class="declaration"><a class="toggle-link" href="#comment-x_y-4804d4748c34357d4373b49c8403cd1d">func &lt;(x: Self, y: Self) -> Bool</a> <div class="comment collapse in" id="comment-x_y-4804d4748c34357d4373b49c8403cd1d"><p>Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.</p>
<p>This function is the only requirement of the <code>Comparable</code> protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to <code>Comparable</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func &lt;(x: Self, y: Self) -> Bool</code></div></div><div id="x_y-41595b3223e387ce1a31eb3ce917dcca" class="declaration"><a class="toggle-link" href="#comment-x_y-41595b3223e387ce1a31eb3ce917dcca">func ==(x: Self, y: Self) -> Bool</a> <div class="comment collapse in" id="comment-x_y-41595b3223e387ce1a31eb3ce917dcca"><p>Returns a Boolean value indicating whether two values are equal.</p>
<p>Equality is the inverse of inequality. For any values <code>a</code> and <code>b</code>,
<code>a == b</code> implies that <code>a != b</code> is <code>false</code>.</p>
<h4>Declaration</h4><code class="language-swift">@inlinable public static func ==(x: Self, y: Self) -> Bool</code></div></div><div id="negate-ada771fd0d039b67f84e7cb6b918b531" class="declaration"><a class="toggle-link" href="#comment-negate-ada771fd0d039b67f84e7cb6b918b531">func negate()</a> <div class="comment collapse in" id="comment-negate-ada771fd0d039b67f84e7cb6b918b531"><p>Replaces this value with its additive inverse.</p>
<p>The following example uses the <code>negate()</code> method to negate the value of
an integer <code>x</code>:</p>
<pre><code class="language-swift">var x = 21
x.negate()
// x == -21
</code></pre>
<p>The resulting value must be representable within the value's type. In
particular, negating a signed, fixed-width integer type's minimum
results in a value that cannot be represented.</p>
<pre><code class="language-swift">var y = Int8.min
y.negate()
// Overflow error
</code></pre>
<h4>Declaration</h4><code class="language-swift">public mutating func negate()</code></div></div>