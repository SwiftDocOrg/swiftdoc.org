---
layout: "default"
title: "Set"
description: "Swift documentation for 'Set': An unordered collection of unique elements."
keywords: "Set,struct,swift,documentation,allSatisfy,compactMap,contains,contains,distance,distance,drop,dropFirst,dropFirst,dropLast,dropLast,elementsEqual,encode,enumerated,filter,first,firstIndex,firstIndex,flatMap,flatMap,flatMap,forEach,formIndex,formIndex,formIndex,formIndex,formIndex,formIntersection,formSymmetricDifference,formSymmetricDifference,formUnion,hash,index,index,index,index,index,insert,insert,intersection,intersection,isDisjoint,isDisjoint,isDisjoint,isStrictSubset,isStrictSubset,isStrictSubset,isStrictSuperset,isStrictSuperset,isStrictSuperset,isSubset,isSubset,isSubset,isSuperset,isSuperset,isSuperset,lexicographicallyPrecedes,makeIterator,map,max,min,popFirst,prefix,prefix,prefix,prefix,randomElement,randomElement,reduce,reduce,remove,remove,remove,removeAll,removeFirst,reserveCapacity,reversed,shuffled,shuffled,sorted,split,starts,subtract,subtract,subtract,subtracting,subtracting,subtracting,suffix,suffix,symmetricDifference,union,update,update,capacity,count,customMirror,debugDescription,description,endIndex,first,hashValue,isEmpty,lazy,startIndex,underestimatedCount"
root: "/v4.2"
---

<div class="intro-declaration"><code class="language-swift">struct Set&lt;Element&gt;</code></div>

<div class="discussion comment">
    <p>An unordered collection of unique elements.</p>

<p>You use a set instead of an array when you need to test efficiently for
membership and you aren&#39;t concerned with the order of the elements in the
collection, or when you need to ensure that each element appears only once
in a collection.</p>

<p>You can create a set with any element type that conforms to the <code>Hashable</code>
protocol. By default, most types in the standard library are hashable,
including strings, numeric and Boolean types, enumeration cases without
associated values, and even sets themselves.</p>

<p>Swift makes it as easy to create a new set as to create a new array. Simply
assign an array literal to a variable or constant with the <code>Set</code> type
specified.</p>

<pre><code class="language-swift">let ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]
if ingredients.contains(&quot;sugar&quot;) {
    print(&quot;No thanks, too sweet.&quot;)
}
// Prints &quot;No thanks, too sweet.&quot;</code></pre>

<h1>Set Operations</h1>

<p>Sets provide a suite of mathematical set operations. For example, you can
efficiently test a set for membership of an element or check its
intersection with another set:</p>

<ul><li>Use the <code>contains(_:)</code> method to test whether a set contains a specific
element.</li><li>Use the &quot;equal to&quot; operator (<code>==</code>) to test whether two sets contain the
same elements.</li><li>Use the <code>isSubset(of:)</code> method to test whether a set contains all the
elements of another set or sequence.</li><li>Use the <code>isSuperset(of:)</code> method to test whether all elements of a set
are contained in another set or sequence.</li><li>Use the <code>isStrictSubset(of:)</code> and <code>isStrictSuperset(of:)</code> methods to test
whether a set is a subset or superset of, but not equal to, another set.</li><li>Use the <code>isDisjoint(with:)</code> method to test whether a set has any elements
in common with another set.</li></ul>

<p>You can also combine, exclude, or subtract the elements of two sets:</p>

<ul><li>Use the <code>union(_:)</code> method to create a new set with the elements of a set
and another set or sequence.</li><li>Use the <code>intersection(_:)</code> method to create a new set with only the
elements common to a set and another set or sequence.</li><li>Use the <code>symmetricDifference(_:)</code> method to create a new set with the
elements that are in either a set or another set or sequence, but not in
both.</li><li>Use the <code>subtracting(_:)</code> method to create a new set with the elements of
a set that are not also in another set or sequence.</li></ul>

<p>You can modify a set in place by using these methods&#39; mutating
counterparts: <code>formUnion(_:)</code>, <code>formIntersection(_:)</code>,
<code>formSymmetricDifference(_:)</code>, and <code>subtract(_:)</code>.</p>

<p>Set operations are not limited to use with other sets. Instead, you can
perform set operations with another set, an array, or any other sequence
type.</p>

<pre><code class="language-swift">var primes: Set = [2, 3, 5, 7]

// Tests whether primes is a subset of a Range&lt;Int&gt;
print(primes.isSubset(of: 0..&lt;10))
// Prints &quot;true&quot;

// Performs an intersection with an Array&lt;Int&gt;
let favoriteNumbers = [5, 7, 15, 21]
print(primes.intersection(favoriteNumbers))
// Prints &quot;[5, 7]&quot;</code></pre>

<h1>Sequence and Collection Operations</h1>

<p>In addition to the <code>Set</code> type&#39;s set operations, you can use any nonmutating
sequence or collection methods with a set.</p>

<pre><code class="language-swift">if primes.isEmpty {
    print(&quot;No primes!&quot;)
} else {
    print(&quot;We have \(primes.count) primes.&quot;)
}
// Prints &quot;We have 4 primes.&quot;

let primesSum = primes.reduce(0, +)
// &#39;primesSum&#39; == 17

let primeStrings = primes.sorted().map(String.init)
// &#39;primeStrings&#39; == [&quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;]</code></pre>

<p>You can iterate through a set&#39;s unordered elements with a <code>for</code>-<code>in</code> loop.</p>

<pre><code class="language-swift">for number in primes {
    print(number)
}
// Prints &quot;5&quot;
// Prints &quot;7&quot;
// Prints &quot;2&quot;
// Prints &quot;3&quot;</code></pre>

<p>Many sequence and collection operations return an array or a type-erasing
collection wrapper instead of a set. To restore efficient set operations,
create a new set from the result.</p>

<pre><code class="language-swift">let morePrimes = primes.union([11, 13, 17, 19])

let laterPrimes = morePrimes.filter { $0 &gt; 10 }
// &#39;laterPrimes&#39; is of type Array&lt;Int&gt;

let laterPrimesSet = Set(morePrimes.filter { $0 &gt; 10 })
// &#39;laterPrimesSet&#39; is of type Set&lt;Int&gt;</code></pre>

<h1>Bridging Between Set and NSSet</h1>

<p>You can bridge between <code>Set</code> and <code>NSSet</code> using the <code>as</code> operator. For
bridging to be possible, the <code>Element</code> type of a set must be a class, an
<code>@objc</code> protocol (a protocol imported from Objective-C or marked with the
<code>@objc</code> attribute), or a type that bridges to a Foundation type.</p>

<p>Bridging from <code>Set</code> to <code>NSSet</code> always takes O(1) time and space. When the
set&#39;s <code>Element</code> type is neither a class nor an <code>@objc</code> protocol, any
required bridging of elements occurs at the first access of each element,
so the first operation that uses the contents of the set (for example, a
membership test) can take O(<em>n</em>).</p>

<p>Bridging from <code>NSSet</code> to <code>Set</code> first calls the <code>copy(with:)</code> method
(<code>**copyWithZone:**</code> in Objective-C) on the set to get an immutable copy and
then performs additional Swift bookkeeping work that takes O(1) time. For
instances of <code>NSSet</code> that are already immutable, <code>copy(with:)</code> returns the
same set in constant time; otherwise, the copying performance is
unspecified. The instances of <code>NSSet</code> and <code>Set</code> share buffer using the
same copy-on-write optimization that is used when two instances of <code>Set</code>
share buffer.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">Collection, CustomDebugStringConvertible, CustomReflectable, CustomStringConvertible, Decodable, Encodable, Equatable, ExpressibleByArrayLiteral, Hashable, Sequence, SetAlgebra</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>


<tr>
<th>Nested Types</th>
<td><code class="nested">Set.Index</code></td>
</tr>

<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init">
<a class="toggle-link" data-toggle="collapse" href="#comment-init">init()</a><div class="comment collapse" id="comment-init"><div class="p">
    <p>Creates an empty set.</p>

<p>This is equivalent to initializing with an empty array literal. For
example:</p>

<pre><code class="language-swift">var emptySet = Set&lt;Int&gt;()
print(emptySet.isEmpty)
// Prints &quot;true&quot;

emptySet = []
print(emptySet.isEmpty)
// Prints &quot;true&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">init()</code>

    </div></div>
</div>
<div class="declaration" id="init_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_">init(<wbr>_:)</a><div class="comment collapse" id="comment-init_"><div class="p">
    <p>Creates a new set from a finite sequence of items.</p>

<p>Use this initializer to create a new set from an existing sequence, for
example, an array or a range.</p>

<pre><code class="language-swift">let validIndices = Set(0..&lt;7).subtracting([2, 4, 5])
print(validIndices)
// Prints &quot;[6, 0, 1, 3]&quot;</code></pre>

<p>This initializer can also be used to restore set methods after performing
sequence operations such as <code>filter(_:)</code> or <code>map(_:)</code> on a set. For
example, after filtering a set of prime numbers to remove any below 10,
you can create a new set by using this initializer.</p>

<pre><code class="language-swift">let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23]
let laterPrimes = Set(primes.lazy.filter { $0 &gt; 10 })
print(laterPrimes)
// Prints &quot;[17, 19, 23, 11, 13]&quot;</code></pre>

<p><strong><code>sequence</code>:</strong>  The elements to use as members of the new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;Source&gt;(_ sequence: Source)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Set/"><code>Set</code></a>
        ,    <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>
        </div></div>
</div>
<div class="declaration" id="init-arrayliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-arrayliteral_">init(<wbr>arrayLiteral:)</a><div class="comment collapse" id="comment-init-arrayliteral_"><div class="p">
    <p>Creates a set containing the elements of the given array literal.</p>

<p>Do not call this initializer directly. It is used by the compiler when
you use an array literal. Instead, create a new set using an array
literal as its value by enclosing a comma-separated list of values in
square brackets. You can use an array literal anywhere a set is expected
by the type context.</p>

<p>Here, a set of strings is created from an array literal holding only
strings.</p>

<pre><code class="language-swift">let ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]
if ingredients.isSuperset(of: [&quot;sugar&quot;, &quot;salt&quot;]) {
    print(&quot;Whatever it is, it&#39;s bound to be delicious!&quot;)
}
// Prints &quot;Whatever it is, it&#39;s bound to be delicious!&quot;</code></pre>

<p><strong><code>elements</code>:</strong>  A variadic list of elements of the new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(arrayLiteral elements: Set&lt;Element&gt;.Element...)</code>

    </div></div>
</div>
<div class="declaration" id="init-from_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-from_">init(<wbr>from:)</a><div class="comment collapse" id="comment-init-from_"><div class="p">
    <p>Creates a new set by decoding from the given decoder.</p>

<p>This initializer throws an error if reading from the decoder fails, or
if the data read is corrupted or otherwise invalid.</p>

<p><strong><code>decoder</code>:</strong>  The decoder to read data from.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(from decoder: Decoder)</code>

    </div></div>
</div>
<div class="declaration" id="init-minimumcapacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-minimumcapacity_">init(<wbr>minimumCapacity:)</a><div class="comment collapse" id="comment-init-minimumcapacity_"><div class="p">
    <p>Creates an empty set with preallocated space for at least the specified
number of elements.</p>

<p>Use this initializer to avoid intermediate reallocations of a set&#39;s
storage buffer when you know how many elements you&#39;ll insert into the set
after creation.</p>

<p><strong><code>minimumCapacity</code>:</strong>  The minimum number of elements that the
  newly created set should be able to store without reallocating its
  storage buffer.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(minimumCapacity: Int)</code>

    </div></div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="var-capacity_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-capacity_-int">var capacity: Int</a><div class="comment collapse" id="comment-var-capacity_-int"><div class="p">
    <p>The total number of elements that the set can contain without
allocating new storage.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var capacity: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-count_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-count_-int">var count: Int</a><div class="comment collapse" id="comment-var-count_-int"><div class="p">
    <p>The number of elements in the set.</p>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var count: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Set/"><code>Set</code></a>
        ,    <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration" id="var-custommirror_-mirror">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-custommirror_-mirror">var customMirror: Mirror</a><div class="comment collapse" id="comment-var-custommirror_-mirror"><div class="p">
    <p>A mirror that reflects the set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customMirror: Mirror { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-debugdescription_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-debugdescription_-string">var debugDescription: String</a><div class="comment collapse" id="comment-var-debugdescription_-string"><div class="p">
    <p>A string that represents the contents of the set, suitable for debugging.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var debugDescription: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-description_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-description_-string">var description: String</a><div class="comment collapse" id="comment-var-description_-string"><div class="p">
    <p>A string that represents the contents of the set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var description: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-endindex_-set-element-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-endindex_-set-element-index">var endIndex: Set&lt;Element&gt;.Index</a><div class="comment collapse" id="comment-var-endindex_-set-element-index"><div class="p">
    <p>The &quot;past the end&quot; position for the set---that is, the position one
greater than the last valid subscript argument.</p>

<p>If the set is empty, <code>endIndex</code> is equal to <code>startIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var endIndex: Set&lt;Element&gt;.Index { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-first_-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-first_-element">var first: Element?</a><div class="comment collapse" id="comment-var-first_-element"><div class="p">
    <p>The first element of the set.</p>

<p>The first element of the set is not necessarily the first element added
to the set. Don&#39;t expect any particular ordering of set elements.</p>

<p>If the set is empty, the value of this property is <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var first: Element? { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>The hash value for the set.</p>

<p>Two sets that are equal will always have equal hash values.</p>

<p>Hash values are not guaranteed to be equal across different executions of
your program. Do not save hash values to use during a future execution.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-isempty_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isempty_-bool">var isEmpty: Bool</a><div class="comment collapse" id="comment-var-isempty_-bool"><div class="p">
    <p>A Boolean value that indicates whether the set is empty.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isEmpty: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Set/"><code>Set</code></a>
        ,    <a href="../../protocol/Collection/"><code>Collection</code></a>
        ,    <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-lazy_-lazycollection-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-lazy_-lazycollection-self">var lazy: LazyCollection&lt;Set&lt;Element&gt;&gt;</a><div class="comment collapse" id="comment-var-lazy_-lazycollection-self"><div class="p">
    <p>A view onto this collection that provides lazy implementations of
normally eager operations, such as <code>map</code> and <code>filter</code>.</p>

<p>Use the <code>lazy</code> property when chaining operations to prevent
intermediate operations from allocating storage, or when you only
need a part of the final collection to avoid unnecessary computation.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var lazy: LazyCollection&lt;Set&lt;Element&gt;&gt; { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration" id="var-startindex_-set-element-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-startindex_-set-element-index">var startIndex: Set&lt;Element&gt;.Index</a><div class="comment collapse" id="comment-var-startindex_-set-element-index"><div class="p">
    <p>The starting position for iterating members of the set.</p>

<p>If the set is empty, <code>startIndex</code> is equal to <code>endIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var startIndex: Set&lt;Element&gt;.Index { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-underestimatedcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-underestimatedcount_-int">var underestimatedCount: Int</a><div class="comment collapse" id="comment-var-underestimatedcount_-int"><div class="p">
    <p>A value less than or equal to the number of elements in the collection.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the length
  of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var underestimatedCount: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        ,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>
        </div></div>
</div>

<h3>Subscripts</h3>
<div class="declaration inherited" id="subscript-subscript_-unboundedrange">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-unboundedrange">subscript(_: (UnboundedRange_)</a>
<div class="comment collapse" id="comment-subscript-subscript_-unboundedrange"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(x: (UnboundedRange_) -&gt; ()) -&gt; Set&lt;Element&gt;.SubSequence { get }</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="subscript-subscript_-set-element-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-set-element-index">subscript(_: Set&lt;Element&gt;.Index)</a>
<div class="comment collapse" id="comment-subscript-subscript_-set-element-index"><div class="p">
    <p>Accesses the member at the given position.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(position: Set&lt;Element&gt;.Index) -&gt; Element { get }</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="subscript-subscript-r_-r">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript-r_-r">subscript&lt;R&gt;(_: R)</a>
<div class="comment collapse" id="comment-subscript-subscript-r_-r"><div class="p">
    <p>Accesses the contiguous subrange of the collection&#39;s elements specified
by a range expression.</p>

<p>The range expression is converted to a concrete subrange relative to this
collection. For example, using a <code>PartialRangeFrom</code> range expression
with an array accesses the subrange from the start of the range
expression until the end of the array.</p>

<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2...]
print(streetsSlice)
// [&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]</code></pre>

<p>The accessed slice uses the same indices for the same elements as the
original collection uses. This example searches <code>streetsSlice</code> for one
of the strings in the slice, and then uses that index in the original
array.</p>

<pre><code class="language-swift">let index = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
print(streets[index!])
// &quot;Evarts&quot;</code></pre>

<p>Always use the slice&#39;s <code>startIndex</code> property instead of assuming that its
indices start at a particular value. Attempting to access an element by
using an index outside the bounds of the slice&#39;s indices may result in a
runtime error, even if that index is valid for the original collection.</p>

<pre><code class="language-swift">print(streetsSlice.startIndex)
// 2
print(streetsSlice[2])
// &quot;Channing&quot;

print(streetsSlice[0])
// error: Index out of bounds</code></pre>

<p><strong><code>bounds</code>:</strong>  A range of the collection&#39;s indices. The bounds of
  the range must be valid indices of the collection.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript&lt;R&gt;(r: R) -&gt; Set&lt;Element&gt;.SubSequence where R : RangeExpression, Set&lt;Element&gt;.Index == R.Bound { get }</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>


<h3>Instance Methods</h3>
<div class="declaration inherited" id="func-allsatisfy_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-allsatisfy_">func allSatisfy(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-allsatisfy_"><div class="p">
    <p>Returns a Boolean value indicating whether every element of a sequence
satisfies a given predicate.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element satisfies a condition.
<strong>Returns:</strong> <code>true</code> if the sequence contains only elements that satisfy
  <code>predicate</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func allSatisfy(_ predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-compactmap_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-compactmap_">func compactMap(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-compactmap_"><div class="p">
    <p>Returns an array containing the non-<code>nil</code> results of calling the given
transformation with each element of this sequence.</p>

<p>Use this method to receive an array of nonoptional values when your
transformation produces an optional value.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>compactMap</code> with a transformation that returns an optional <code>Int</code> value.</p>

<pre><code class="language-swift">let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]

let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
// [1, 2, nil, nil, 5]

let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
// [1, 2, 5]</code></pre>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns an optional value.
<strong>Returns:</strong> An array of the non-<code>nil</code> results of calling <code>transform</code>
  with each element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func compactMap&lt;ElementOfResult&gt;(_ transform: (Set&lt;Element&gt;.Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-contains_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-contains_">func contains(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-contains_"><div class="p">
    <p>Returns a Boolean value that indicates whether the given element exists
in the set.</p>

<p>This example uses the <code>contains(_:)</code> method to test whether an integer is
a member of a set of prime numbers.</p>

<pre><code class="language-swift">let primes: Set = [2, 3, 5, 7]
let x = 5
if primes.contains(x) {
    print(&quot;\(x) is prime!&quot;)
} else {
    print(&quot;\(x). Not prime.&quot;)
}
// Prints &quot;5 is prime!&quot;</code></pre>

<p><strong><code>member</code>:</strong>  An element to look for in the set.
<strong>Returns:</strong> <code>true</code> if <code>member</code> exists in the set; otherwise, <code>false</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func contains(_ member: Set&lt;Element&gt;.Element) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-contains-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-contains-where_">func contains(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-contains-where_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence contains an
element that satisfies the given predicate.</p>

<p>You can use the predicate to check for an element of a type that
doesn&#39;t conform to the <code>Equatable</code> protocol, such as the
<code>HTTPResponse</code> enumeration in this example.</p>

<pre><code class="language-swift">enum HTTPResponse {
    case ok
    case error(Int)
}

let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
let hadError = lastThreeResponses.contains { element in
    if case .error = element {
        return true
    } else {
        return false
    }
}
// &#39;hadError&#39; == true</code></pre>

<p>Alternatively, a predicate can be satisfied by a range of <code>Equatable</code>
elements or a general condition. This example shows how you can check an
array for an expense greater than $100.</p>

<pre><code class="language-swift">let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
let hasBigPurchase = expenses.contains { $0 &gt; 100 }
// &#39;hasBigPurchase&#39; == true</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element represents a match.
<strong>Returns:</strong> <code>true</code> if the sequence contains an element that satisfies
  <code>predicate</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func contains(where predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-from_-self-index-to_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-from_-self-index-to_-self-index">func distance(<wbr>from:<wbr> Set&lt;Element&gt;.Index, to: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-distance-from_-self-index-to_-self-index"><div class="p">
    <p>Returns the distance between two indices.</p>

<p>Unless the collection conforms to the <code>BidirectionalCollection</code> protocol,
<code>start</code> must be less than or equal to <code>end</code>.</p>

<p><strong>Parameters:</strong>
  <strong>start:</strong> A valid index of the collection.
  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to
    <code>start</code>, the result is zero.
<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be
  negative only if the collection conforms to the
  <code>BidirectionalCollection</code> protocol.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the
  resulting distance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(from start: Set&lt;Element&gt;.Index, to end: Set&lt;Element&gt;.Index) -&gt; Int</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-t-from_-self-index-to_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-t-from_-self-index-to_-self-index">func distance&lt;T&gt;(<wbr>from:<wbr> Set&lt;Element&gt;.Index, to: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-distance-t-from_-self-index-to_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance&lt;T&gt;(from start: Set&lt;Element&gt;.Index, to end: Set&lt;Element&gt;.Index) -&gt; T where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-drop-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-drop-while_">func drop(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-drop-while_"><div class="p">
    <p>Returns a subsequence by skipping elements while <code>predicate</code> returns
<code>true</code> and returning the remaining elements.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns <code>true</code> if the element should
  be skipped or <code>false</code> if it should be included. Once the predicate
  returns <code>false</code> it will not be called again.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func drop(while predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-dropfirst">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dropfirst">func dropFirst()</a>
        
<div class="comment collapse" id="comment-func-dropfirst"><div class="p">
    <p>Returns a subsequence containing all but the first element of the
sequence.</p>

<p>The following example drops the first element from an array of integers.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst())
// Prints &quot;[2, 3, 4, 5]&quot;</code></pre>

<p>If the sequence has no elements, the result is an empty subsequence.</p>

<pre><code class="language-swift">let empty: [Int] = []
print(empty.dropFirst())
// Prints &quot;[]&quot;</code></pre>

<p><strong>Returns:</strong> A subsequence starting after the first element of the
  sequence.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst() -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-dropfirst_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dropfirst_">func dropFirst(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-dropfirst_"><div class="p">
    <p>Returns a subsequence containing all but the given number of initial
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in
the collection, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst(2))
// Prints &quot;[3, 4, 5]&quot;
print(numbers.dropFirst(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop from the beginning of
  the collection. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting after the specified number of
  elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the number of elements to drop from
  the beginning of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst(_ n: Int) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-droplast">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-droplast">func dropLast()</a>
        
<div class="comment collapse" id="comment-func-droplast"><div class="p">
    <p>Returns a subsequence containing all but the last element of the
sequence.</p>

<p>The sequence must be finite.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast())
// Prints &quot;[1, 2, 3, 4]&quot;</code></pre>

<p>If the sequence has no elements, the result is an empty subsequence.</p>

<pre><code class="language-swift">let empty: [Int] = []
print(empty.dropLast())
// Prints &quot;[]&quot;</code></pre>

<p><strong>Returns:</strong> A subsequence leaving off the last element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast() -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-droplast_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-droplast_">func dropLast(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-droplast_"><div class="p">
    <p>Returns a subsequence containing all but the specified number of final
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in the
collection, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast(2))
// Prints &quot;[1, 2, 3]&quot;
print(numbers.dropLast(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop off the end of the
  collection. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence that leaves off the specified number of elements
  at the end.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast(_ n: Int) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-elementsequal_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-elementsequal_by_">func elementsEqual(<wbr>_:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-elementsequal_by_"><div class="p">
    <p>Returns a Boolean value indicating whether this sequence and another
sequence contain equivalent elements in the same order, using the given
predicate as the equivalence test.</p>

<p>At least one of the sequences must be finite.</p>

<p>The predicate must be a <em>equivalence relation</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)</li><li><code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)</li><li>If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then
<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)</li></ul>

<p><strong>Parameters:</strong>
  <strong>other:</strong> A sequence to compare to this sequence.
  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments
    are equivalent; otherwise, <code>false</code>.
<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain equivalent items,
  using <code>areEquivalent</code> as the equivalence test; otherwise, <code>false.</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func elementsEqual&lt;OtherSequence&gt;(_ other: OtherSequence, by areEquivalent: (Set&lt;Element&gt;.Element, OtherSequence.Element) throws -&gt; Bool) rethrows -&gt; Bool where OtherSequence : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-encode-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-encode-to_">func encode(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-encode-to_"><div class="p">
    <p>Encodes the elements of this set into the given encoder in an unkeyed
container.</p>

<p>This function throws an error if any values are invalid for the given
encoder&#39;s format.</p>

<p><strong><code>encoder</code>:</strong>  The encoder to write data to.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func encode(to encoder: Encoder) throws</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-enumerated">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-enumerated">func enumerated()</a>
        
<div class="comment collapse" id="comment-func-enumerated"><div class="p">
    <p>Returns a sequence of pairs (<em>n</em>, <em>x</em>), where <em>n</em> represents a
consecutive integer starting at zero and <em>x</em> represents an element of
the sequence.</p>

<p>This example enumerates the characters of the string &quot;Swift&quot; and prints
each character along with its place in the string.</p>

<pre><code class="language-swift">for (n, c) in &quot;Swift&quot;.enumerated() {
    print(&quot;\(n): &#39;\(c)&#39;&quot;)
}
// Prints &quot;0: &#39;S&#39;&quot;
// Prints &quot;1: &#39;w&#39;&quot;
// Prints &quot;2: &#39;i&#39;&quot;
// Prints &quot;3: &#39;f&#39;&quot;
// Prints &quot;4: &#39;t&#39;&quot;</code></pre>

<p>When you enumerate a collection, the integer part of each pair is a counter
for the enumeration, but is not necessarily the index of the paired value.
These counters can be used as indices only in instances of zero-based,
integer-indexed collections, such as <code>Array</code> and <code>ContiguousArray</code>. For
other collections the counters may be out of range or of the wrong type
to use as an index. To iterate over the elements of a collection with its
indices, use the <code>zip(_:_:)</code> function.</p>

<p>This example iterates over the indices and elements of a set, building a
list consisting of indices of names with five or fewer letters.</p>

<pre><code class="language-swift">let names: Set = [&quot;Sofia&quot;, &quot;Camilla&quot;, &quot;Martina&quot;, &quot;Mateo&quot;, &quot;Nicol√°s&quot;]
var shorterIndices: [SetIndex&lt;String&gt;] = []
for (i, name) in zip(names.indices, names) {
    if name.count &lt;= 5 {
        shorterIndices.append(i)
    }
}</code></pre>

<p>Now that the <code>shorterIndices</code> array holds the indices of the shorter
names in the <code>names</code> set, you can use those indices to access elements in
the set.</p>

<pre><code class="language-swift">for i in shorterIndices {
    print(names[i])
}
// Prints &quot;Sofia&quot;
// Prints &quot;Mateo&quot;</code></pre>

<p><strong>Returns:</strong> A sequence of pairs enumerating the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func enumerated() -&gt; EnumeratedSequence&lt;Set&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-filter_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-filter_">func filter(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-filter_"><div class="p">
    <p>Returns a new set containing the elements of the set that satisfy the
given predicate.</p>

<p>In this example, <code>filter(_:)</code> is used to include only names shorter than
five characters.</p>

<pre><code class="language-swift">let cast: Set = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let shortNames = cast.filter { $0.count &lt; 5 }

shortNames.isSubset(of: cast)
// true
shortNames.contains(&quot;Vivien&quot;)
// false</code></pre>

<p><strong><code>isIncluded</code>:</strong>  A closure that takes an element as its argument
  and returns a Boolean value indicating whether the element should be
  included in the returned set.
<strong>Returns:</strong> A set of the elements that <code>isIncluded</code> allows.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func filter(_ isIncluded: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Set/"><code>Set</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-first-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-first-where_">func first(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-first-where_"><div class="p">
    <p>Returns the first element of the sequence that satisfies the given
predicate.</p>

<p>The following example uses the <code>first(where:)</code> method to find the first
negative number in an array of integers:</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
if let firstNegative = numbers.first(where: { $0 &lt; 0 }) {
    print(&quot;The first negative number is \(firstNegative).&quot;)
}
// Prints &quot;The first negative number is -2.&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element is a match.
<strong>Returns:</strong> The first element of the sequence that satisfies <code>predicate</code>,
  or <code>nil</code> if there is no element that satisfies <code>predicate</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func first(where predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-firstindex-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-firstindex-of_">func firstIndex(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-firstindex-of_"><div class="p">
    <p>Returns the index of the given element in the set, or <code>nil</code> if the
element is not a member of the set.</p>

<p><strong><code>member</code>:</strong>  An element to search for in the set.
<strong>Returns:</strong> The index of <code>member</code> if it exists in the set; otherwise,
  <code>nil</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func firstIndex(of member: Set&lt;Element&gt;.Element) -&gt; Set&lt;Element&gt;.Index?</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-firstindex-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-firstindex-where_">func firstIndex(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-firstindex-where_"><div class="p">
    <p>Returns the first index in which an element of the collection satisfies
the given predicate.</p>

<p>You can use the predicate to find an element of a type that doesn&#39;t
conform to the <code>Equatable</code> protocol or to find an element that matches
particular criteria. Here&#39;s an example that finds a student name that
begins with the letter &quot;A&quot;:</p>

<pre><code class="language-swift">let students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
if let i = students.firstIndex(where: { $0.hasPrefix(&quot;A&quot;) }) {
    print(&quot;\(students[i]) starts with &#39;A&#39;!&quot;)
}
// Prints &quot;Abena starts with &#39;A&#39;!&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element as its argument
  and returns a Boolean value that indicates whether the passed element
  represents a match.
<strong>Returns:</strong> The index of the first element for which <code>predicate</code> returns
  <code>true</code>. If no elements in the collection satisfy the given predicate,
  returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func firstIndex(where predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap_">func flatMap(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-flatmap_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap(_ transform: (Set&lt;Element&gt;.Element) throws -&gt; String?) rethrows -&gt; [String]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap-elementofresult_-self-element-throws-elementofresult">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap-elementofresult_-self-element-throws-elementofresult">func flatMap&lt;ElementOfResult&gt;(<wbr>_: (Set&lt;Element&gt;.Element) throws -&gt; ElementOfResult?)</a>
        
<div class="comment collapse" id="comment-func-flatmap-elementofresult_-self-element-throws-elementofresult"><div class="p">
    <p>Returns an array containing the non-<code>nil</code> results of calling the given
transformation with each element of this sequence.</p>

<p>Use this method to receive an array of nonoptional values when your
transformation produces an optional value.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>flatMap</code> with a transformation that returns an optional <code>Int</code> value.</p>

<pre><code class="language-swift">let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]

let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
// [1, 2, nil, nil, 5]

let flatMapped: [Int] = possibleNumbers.flatMap { str in Int(str) }
// [1, 2, 5]</code></pre>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns an optional value.
<strong>Returns:</strong> An array of the non-<code>nil</code> results of calling <code>transform</code>
  with each element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap&lt;ElementOfResult&gt;(_ transform: (Set&lt;Element&gt;.Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap-segmentofresult_-self-element-throws-segmentofresult">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap-segmentofresult_-self-element-throws-segmentofresult">func flatMap&lt;SegmentOfResult&gt;(<wbr>_: (Set&lt;Element&gt;.Element) throws -&gt; SegmentOfResult)</a>
        
<div class="comment collapse" id="comment-func-flatmap-segmentofresult_-self-element-throws-segmentofresult"><div class="p">
    <p>Returns an array containing the concatenated results of calling the
given transformation with each element of this sequence.</p>

<p>Use this method to receive a single-level collection when your
transformation produces a sequence or collection for each element.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>flatMap</code> with a transformation that returns an array.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4]

let mapped = numbers.map { Array(repeating: $0, count: $0) }
// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]

let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</code></pre>

<p>In fact, <code>s.flatMap(transform)</code>  is equivalent to
<code>Array(s.map(transform).joined())</code>.</p>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns a sequence or collection.
<strong>Returns:</strong> The resulting flattened array.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap&lt;SegmentOfResult&gt;(_ transform: (Set&lt;Element&gt;.Element) throws -&gt; SegmentOfResult) rethrows -&gt; [SegmentOfResult.Element] where SegmentOfResult : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-foreach_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-foreach_">func forEach(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-foreach_"><div class="p">
    <p>Calls the given closure on each element in the sequence in the same order
as a <code>for</code>-<code>in</code> loop.</p>

<p>The two loops in the following example produce the same output:</p>

<pre><code class="language-swift">let numberWords = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
for word in numberWords {
    print(word)
}
// Prints &quot;one&quot;
// Prints &quot;two&quot;
// Prints &quot;three&quot;

numberWords.forEach { word in
    print(word)
}
// Same as above</code></pre>

<p>Using the <code>forEach</code> method is distinct from a <code>for</code>-<code>in</code> loop in two
important ways:</p>

<ol><li>You cannot use a <code>break</code> or <code>continue</code> statement to exit the current
call of the <code>body</code> closure or skip subsequent calls.</li><li>Using the <code>return</code> statement in the <code>body</code> closure will exit only from
the current call to <code>body</code>, not from any outer scope, and won&#39;t skip
subsequent calls.</li></ol>

<p><strong><code>body</code>:</strong>  A closure that takes an element of the sequence as a
  parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func forEach(_ body: (Set&lt;Element&gt;.Element) throws -&gt; Void) rethrows</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex_-inout-self-index-offsetby_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex_-inout-self-index-offsetby_-int">func formIndex(<wbr>_:<wbr> inout Set&lt;Element&gt;.Index, offsetBy: Int)</a>
        
<div class="comment collapse" id="comment-func-formindex_-inout-self-index-offsetby_-int"><div class="p">
    <p>Offsets the given index by the specified distance.</p>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(_ i: inout Set&lt;Element&gt;.Index, offsetBy n: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex-t_-inout-self-index-offsetby_-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-t_-inout-self-index-offsetby_-t">func formIndex&lt;T&gt;(<wbr>_:<wbr> inout Set&lt;Element&gt;.Index, offsetBy: T)</a>
        
<div class="comment collapse" id="comment-func-formindex-t_-inout-self-index-offsetby_-t"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex&lt;T&gt;(_ i: inout Set&lt;Element&gt;.Index, offsetBy n: T)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index">func formIndex(<wbr>_:<wbr> inout Set&lt;Element&gt;.Index, offsetBy:<wbr> Int, limitedBy: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index"><div class="p">
    <p>Offsets the given index by the specified distance, or so that it equals
the given limiting index.</p>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,
    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a
    limit that is greater than <code>i</code> has no effect.
<strong>Returns:</strong> <code>true</code> if <code>i</code> has been offset by exactly <code>n</code> steps without
  going beyond <code>limit</code>; otherwise, <code>false</code>. When the return value is
  <code>false</code>, the value of <code>i</code> is equal to <code>limit</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(_ i: inout Set&lt;Element&gt;.Index, offsetBy n: Int, limitedBy limit: Set&lt;Element&gt;.Index) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index">func formIndex&lt;T&gt;(<wbr>_:<wbr> inout Set&lt;Element&gt;.Index, offsetBy:<wbr> T, limitedBy: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex&lt;T&gt;(_ i: inout Set&lt;Element&gt;.Index, offsetBy n: T, limitedBy limit: Set&lt;Element&gt;.Index) -&gt; Bool where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex-after_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-after_">func formIndex(<wbr>after:)</a>
        
<div class="comment collapse" id="comment-func-formindex-after_"><div class="p">
    <p>Replaces the given index with its successor.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than
  <code>endIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(after i: inout Set&lt;Element&gt;.Index)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-formintersection_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formintersection_">mutating func formIntersection(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-formintersection_"><div class="p">
    <p>Removes the elements of the set that aren&#39;t also in the given sequence.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
not also members of the <code>neighbors</code> set are removed. In particular, the
names <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and <code>&quot;Diana&quot;</code> are removed.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
employees.formIntersection(neighbors)
print(employees)
// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formIntersection&lt;S&gt;(_ other: S)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-formsymmetricdifference_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formsymmetricdifference_-set-set-element-element">mutating func formSymmetricDifference(<wbr>_: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-formsymmetricdifference_-set-set-element-element"><div class="p">
    <p>Removes the elements of the set that are also in the given sequence and
adds the members of the sequence that are not already in the set.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
also members of <code>neighbors</code> are removed from <code>employees</code>, while the
elements of <code>neighbors</code> that are not members of <code>employees</code> are added to
<code>employees</code>. In particular, the names <code>&quot;Alicia&quot;</code>, <code>&quot;Chris&quot;</code>, and
<code>&quot;Diana&quot;</code> are removed from <code>employees</code> while the names <code>&quot;Forlani&quot;</code> and
<code>&quot;Greta&quot;</code> are added.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
employees.formSymmetricDifference(neighbors)
print(employees)
// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;, &quot;Greta&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formSymmetricDifference(_ other: Set&lt;Set&lt;Element&gt;.Element&gt;)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-formsymmetricdifference-s_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formsymmetricdifference-s_-s">mutating func formSymmetricDifference&lt;S&gt;(<wbr>_: S)</a>
        
<div class="comment collapse" id="comment-func-formsymmetricdifference-s_-s"><div class="p">
    <p>Replace this set with the elements contained in this set or the given
set, but not both.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
also members of <code>neighbors</code> are removed from <code>employees</code>, while the
elements of <code>neighbors</code> that are not members of <code>employees</code> are added to
<code>employees</code>. In particular, the names <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are
removed from <code>employees</code> while the name <code>&quot;Forlani&quot;</code> is added.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;]
employees.formSymmetricDifference(neighbors)
print(employees)
// Prints &quot;[&quot;Diana&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formSymmetricDifference&lt;S&gt;(_ other: S)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-formunion_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formunion_">mutating func formUnion(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-formunion_"><div class="p">
    <p>Inserts the elements of the given sequence into the set.</p>

<p>If the set already contains one or more elements that are also in
<code>other</code>, the existing members are kept. If <code>other</code> contains multiple
instances of equivalent elements, only the first instance is kept.</p>

<pre><code class="language-swift">var attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
let visitors = [&quot;Diana&quot;, &quot;Marcia&quot;, &quot;Nathaniel&quot;]
attendees.formUnion(visitors)
print(attendees)
// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func formUnion&lt;S&gt;(_ other: S)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-hash-into_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-hash-into_">func hash(<wbr>into:)</a>
        
<div class="comment collapse" id="comment-func-hash-into_"><div class="p">
    <p>Hashes the essential components of this value by feeding them into the
given hasher.</p>

<p><strong><code>hasher</code>:</strong>  The hasher to use when combining the components
  of this instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func hash(into hasher: inout Hasher)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-self-index-offsetby_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-self-index-offsetby_-int">func index(<wbr>_:<wbr> Set&lt;Element&gt;.Index, offsetBy: Int)</a>
        
<div class="comment collapse" id="comment-func-index_-self-index-offsetby_-int"><div class="p">
    <p>Returns an index that is the specified distance from the given index.</p>

<p>The following example obtains an index advanced four positions from a
string&#39;s starting index and then prints the character at that position.</p>

<pre><code class="language-swift">let s = &quot;Swift&quot;
let i = s.index(s.startIndex, offsetBy: 4)
print(s[i])
// Prints &quot;t&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,
  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.
  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls
  to <code>index(before:)</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Set&lt;Element&gt;.Index, offsetBy n: Int) -&gt; Set&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index-t_-self-index-offsetby_-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-t_-self-index-offsetby_-t">func index&lt;T&gt;(<wbr>_:<wbr> Set&lt;Element&gt;.Index, offsetBy: T)</a>
        
<div class="comment collapse" id="comment-func-index-t_-self-index-offsetby_-t"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index&lt;T&gt;(_ i: Set&lt;Element&gt;.Index, offsetBy n: T) -&gt; Set&lt;Element&gt;.Index where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-self-index-offsetby_-int-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-self-index-offsetby_-int-limitedby_-self-index">func index(<wbr>_:<wbr> Set&lt;Element&gt;.Index, offsetBy:<wbr> Int, limitedBy: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-index_-self-index-offsetby_-int-limitedby_-self-index"><div class="p">
    <p>Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.</p>

<p>The following example obtains an index advanced four positions from a
string&#39;s starting index and then prints the character at that position.
The operation doesn&#39;t require going beyond the limiting <code>s.endIndex</code>
value, so it succeeds.</p>

<pre><code class="language-swift">let s = &quot;Swift&quot;
if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    print(s[i])
}
// Prints &quot;t&quot;</code></pre>

<p>The next example attempts to retrieve an index six positions from
<code>s.startIndex</code> but fails, because that distance is beyond the index
passed as <code>limit</code>.</p>

<pre><code class="language-swift">let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
print(j)
// Prints &quot;nil&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,
    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a
    limit that is greater than <code>i</code> has no effect.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index
  would be beyond <code>limit</code> in the direction of movement. In that case,
  the method returns <code>nil</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Set&lt;Element&gt;.Index, offsetBy n: Int, limitedBy limit: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index-t_-self-index-offsetby_-t-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-t_-self-index-offsetby_-t-limitedby_-self-index">func index&lt;T&gt;(<wbr>_:<wbr> Set&lt;Element&gt;.Index, offsetBy:<wbr> T, limitedBy: Set&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-index-t_-self-index-offsetby_-t-limitedby_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index&lt;T&gt;(_ i: Set&lt;Element&gt;.Index, offsetBy n: T, limitedBy limit: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.Index? where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-index-after_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-after_">func index(<wbr>after:)</a>
        
<div class="comment collapse" id="comment-func-index-after_"><div class="p">
    <p>Returns the position immediately after the given index.</p>

<p>The successor of an index must be well defined. For an index <code>i</code> into a
collection <code>c</code>, calling <code>c.index(after: i)</code> returns the same index every
time.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than
  <code>endIndex</code>.
<strong>Returns:</strong> The index value immediately after <code>i</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(after i: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.Index</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-insert_-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-insert_-set-element-element">mutating func insert(<wbr>_: Set&lt;Element&gt;.Element)</a>
        
<div class="comment collapse" id="comment-func-insert_-set-element-element"><div class="p">
    <p>Inserts the given element in the set if it is not already present.</p>

<p>If an element equal to <code>newMember</code> is already contained in the set, this
method has no effect. In the following example, a new element is
inserted into <code>classDays</code>, a set of days of the week. When an existing
element is inserted, the <code>classDays</code> set does not change.</p>

<pre><code class="language-swift">enum DayOfTheWeek: Int {
    case sunday, monday, tuesday, wednesday, thursday,
        friday, saturday
}

var classDays: Set&lt;DayOfTheWeek&gt; = [.wednesday, .friday]
print(classDays.insert(.monday))
// Prints &quot;(true, .monday)&quot;
print(classDays)
// Prints &quot;[.friday, .wednesday, .monday]&quot;

print(classDays.insert(.friday))
// Prints &quot;(false, .friday)&quot;
print(classDays)
// Prints &quot;[.friday, .wednesday, .monday]&quot;</code></pre>

<p><strong><code>newMember</code>:</strong>  An element to insert into the set.
<strong>Returns:</strong> <code>(true, newMember)</code> if <code>newMember</code> was not contained in the
  set. If an element equal to <code>newMember</code> was already contained in the
  set, the method returns <code>(false, oldMember)</code>, where <code>oldMember</code> is the
  element that was equal to <code>newMember</code>. In some cases, <code>oldMember</code> may
  be distinguishable from <code>newMember</code> by identity comparison or some
  other means.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func insert(_ newMember: Set&lt;Element&gt;.Element) -&gt; (inserted: Bool, memberAfterInsert: Set&lt;Element&gt;.Element)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-insert-concreteelement_-concreteelement">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-insert-concreteelement_-concreteelement">mutating func insert&lt;ConcreteElement&gt;(<wbr>_: ConcreteElement)</a>
        
<div class="comment collapse" id="comment-func-insert-concreteelement_-concreteelement"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func insert&lt;ConcreteElement&gt;(_ newMember: ConcreteElement) -&gt; (inserted: Bool, memberAfterInsert: ConcreteElement) where ConcreteElement : Hashable</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-intersection_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-intersection_-set-set-element-element">func intersection(<wbr>_: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-intersection_-set-set-element-element"><div class="p">
    <p>Returns a new set with the elements that are common to both this set and
the given sequence.</p>

<p>In the following example, the <code>bothNeighborsAndEmployees</code> set is made up
of the elements that are in <em>both</em> the <code>employees</code> and <code>neighbors</code> sets.
Elements that are in only one or the other are left out of the result of
the intersection.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
let bothNeighborsAndEmployees = employees.intersection(neighbors)
print(bothNeighborsAndEmployees)
// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func intersection(_ other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt;</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-intersection-s_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-intersection-s_-s">func intersection&lt;S&gt;(<wbr>_: S)</a>
        
<div class="comment collapse" id="comment-func-intersection-s_-s"><div class="p">
    <p>Returns a new set with the elements that are common to both this set and
the given sequence.</p>

<p>In the following example, the <code>bothNeighborsAndEmployees</code> set is made up
of the elements that are in <em>both</em> the <code>employees</code> and <code>neighbors</code> sets.
Elements that are in only one or the other are left out of the result of
the intersection.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
let bothNeighborsAndEmployees = employees.intersection(neighbors)
print(bothNeighborsAndEmployees)
// Prints &quot;[&quot;Bethany&quot;, &quot;Eric&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func intersection&lt;S&gt;(_ other: S) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt; where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-isdisjoint-with_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isdisjoint-with_-set-set-element-element">func isDisjoint(<wbr>with: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-isdisjoint-with_-set-set-element-element"><div class="p">
    <p>Returns a Boolean value that indicates whether this set has no members in
common with the given set.</p>

<p>In the following example, the <code>employees</code> set is disjoint with the
<code>visitors</code> set because no name appears in both sets.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]
print(employees.isDisjoint(with: visitors))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isDisjoint(with other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-isdisjoint-with_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isdisjoint-with_">func isDisjoint(<wbr>with:)</a>
        
<div class="comment collapse" id="comment-func-isdisjoint-with_"><div class="p">
    <p>Returns a Boolean value that indicates whether the set has no members in
common with the given set.</p>

<p>In the following example, the <code>employees</code> set is disjoint with the
<code>visitors</code> set because no name appears in both sets.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let visitors: Set = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]
print(employees.isDisjoint(with: visitors))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isDisjoint(with other: Set&lt;Element&gt;) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-isdisjoint-s-with_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isdisjoint-s-with_-s">func isDisjoint&lt;S&gt;(<wbr>with: S)</a>
        
<div class="comment collapse" id="comment-func-isdisjoint-s-with_-s"><div class="p">
    <p>Returns a Boolean value that indicates whether the set has no members in
common with the given sequence.</p>

<p>In the following example, the <code>employees</code> set is disjoint with the
elements of the <code>visitors</code> array because no name appears in both.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let visitors = [&quot;Marcia&quot;, &quot;Nathaniel&quot;, &quot;Olivia&quot;]
print(employees.isDisjoint(with: visitors))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.
<strong>Returns:</strong> <code>true</code> if the set has no elements in common with <code>other</code>;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isDisjoint&lt;S&gt;(with other: S) -&gt; Bool where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-isstrictsubset-of_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsubset-of_-set-set-element-element">func isStrictSubset(<wbr>of: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-isstrictsubset-of_-set-set-element-element"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a strict subset
of the given sequence.</p>

<p>Set <em>A</em> is a strict subset of another set <em>B</em> if every member of <em>A</em> is
also a member of <em>B</em> and <em>B</em> contains at least one element that is not a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isStrictSubset(of: employees))
// Prints &quot;true&quot;

// A set is never a strict subset of itself:
print(attendees.isStrictSubset(of: attendees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> <code>true</code> if the set is a strict subset of
  <code>other</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSubset(of other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-isstrictsubset-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsubset-of_">func isStrictSubset(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-isstrictsubset-of_"><div class="p">
    <p>Returns a Boolean value that indicates whether this set is a strict
subset of the given set.</p>

<p>Set <em>A</em> is a strict subset of another set <em>B</em> if every member of <em>A</em> is
also a member of <em>B</em> and <em>B</em> contains at least one element that is not a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isStrictSubset(of: employees))
// Prints &quot;true&quot;

// A set is never a strict subset of itself:
print(attendees.isStrictSubset(of: attendees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> <code>true</code> if the set is a strict subset of <code>other</code>; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSubset(of other: Set&lt;Element&gt;) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-isstrictsubset-s-of_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsubset-s-of_-s">func isStrictSubset&lt;S&gt;(<wbr>of: S)</a>
        
<div class="comment collapse" id="comment-func-isstrictsubset-s-of_-s"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a strict subset
of the given sequence.</p>

<p>Set <em>A</em> is a strict subset of another set <em>B</em> if every member of <em>A</em> is
also a member of <em>B</em> and <em>B</em> contains at least one element that is not a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isStrictSubset(of: employees))
// Prints &quot;true&quot;

// A set is never a strict subset of itself:
print(attendees.isStrictSubset(of: attendees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>possibleStrictSuperset</code>:</strong>  A sequence of elements.
  <code>possibleStrictSuperset</code> must be finite.
<strong>Returns:</strong> <code>true</code> is the set is strict subset of
  <code>possibleStrictSuperset</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSubset&lt;S&gt;(of possibleStrictSuperset: S) -&gt; Bool where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-isstrictsuperset-of_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsuperset-of_-set-set-element-element">func isStrictSuperset(<wbr>of: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-isstrictsuperset-of_-set-set-element-element"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a strict
superset of the given sequence.</p>

<p>Set <em>A</em> is a strict superset of another set <em>B</em> if every member of <em>B</em> is
also a member of <em>A</em> and <em>A</em> contains at least one element that is <em>not</em>
a member of <em>B</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isStrictSuperset(of: attendees))
// Prints &quot;true&quot;
print(employees.isStrictSuperset(of: employees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> <code>true</code> if the set is a strict superset of
  <code>other</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSuperset(of other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-isstrictsuperset-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsuperset-of_">func isStrictSuperset(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-isstrictsuperset-of_"><div class="p">
    <p>Returns a Boolean value that indicates whether this set is a strict
superset of the given set.</p>

<p>Set <em>A</em> is a strict superset of another set <em>B</em> if every member of <em>B</em> is
also a member of <em>A</em> and <em>A</em> contains at least one element that is <em>not</em>
a member of <em>B</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isStrictSuperset(of: attendees))
// Prints &quot;true&quot;

// A set is never a strict superset of itself:
print(employees.isStrictSuperset(of: employees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> <code>true</code> if the set is a strict superset of <code>other</code>; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSuperset(of other: Set&lt;Element&gt;) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-isstrictsuperset-s-of_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-isstrictsuperset-s-of_-s">func isStrictSuperset&lt;S&gt;(<wbr>of: S)</a>
        
<div class="comment collapse" id="comment-func-isstrictsuperset-s-of_-s"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a strict
superset of the given sequence.</p>

<p>Set <em>A</em> is a strict superset of another set <em>B</em> if every member of <em>B</em> is
also a member of <em>A</em> and <em>A</em> contains at least one element that is <em>not</em>
a member of <em>B</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isStrictSuperset(of: attendees))
// Prints &quot;true&quot;
print(employees.isStrictSuperset(of: employees))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>possibleStrictSubset</code>:</strong>  A sequence of elements.
  <code>possibleStrictSubset</code> must be finite.
<strong>Returns:</strong> <code>true</code> if the set is a strict superset of
  <code>possibleStrictSubset</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isStrictSuperset&lt;S&gt;(of possibleStrictSubset: S) -&gt; Bool where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-issubset-of_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issubset-of_-set-set-element-element">func isSubset(<wbr>of: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-issubset-of_-set-set-element-element"><div class="p">
    <p>Returns a Boolean value that indicates whether this set is a subset of
the given set.</p>

<p>Set <em>A</em> is a subset of another set <em>B</em> if every member of <em>A</em> is also a
member of <em>B</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isSubset(of: employees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>other</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSubset(of other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-issubset-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issubset-of_">func isSubset(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-issubset-of_"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a subset of
another set.</p>

<p>Set <em>A</em> is a subset of another set <em>B</em> if every member of <em>A</em> is also a
member of <em>B</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isSubset(of: employees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>other</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSubset(of other: Set&lt;Element&gt;) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-issubset-s-of_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issubset-s-of_-s">func isSubset&lt;S&gt;(<wbr>of: S)</a>
        
<div class="comment collapse" id="comment-func-issubset-s-of_-s"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a subset of the
given sequence.</p>

<p>Set <em>A</em> is a subset of another set <em>B</em> if every member of <em>A</em> is also a
member of <em>B</em>.</p>

<pre><code class="language-swift">let employees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(attendees.isSubset(of: employees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>possibleSuperset</code>:</strong>  A sequence of elements. <code>possibleSuperset</code>
  must be finite.
<strong>Returns:</strong> <code>true</code> if the set is a subset of <code>possibleSuperset</code>;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSubset&lt;S&gt;(of possibleSuperset: S) -&gt; Bool where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-issuperset-of_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issuperset-of_-set-set-element-element">func isSuperset(<wbr>of: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-issuperset-of_-set-set-element-element"><div class="p">
    <p>Returns a Boolean value that indicates whether this set is a superset of
the given set.</p>

<p>Set <em>A</em> is a superset of another set <em>B</em> if every member of <em>B</em> is also a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isSuperset(of: attendees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>other</code>; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSuperset(of other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Bool</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-issuperset-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issuperset-of_">func isSuperset(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-issuperset-of_"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a superset of
the given set.</p>

<p>Set <em>A</em> is a superset of another set <em>B</em> if every member of <em>B</em> is also a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isSuperset(of: attendees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>other</code>; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSuperset(of other: Set&lt;Element&gt;) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-issuperset-s-of_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-issuperset-s-of_-s">func isSuperset&lt;S&gt;(<wbr>of: S)</a>
        
<div class="comment collapse" id="comment-func-issuperset-s-of_-s"><div class="p">
    <p>Returns a Boolean value that indicates whether the set is a superset of
the given sequence.</p>

<p>Set <em>A</em> is a superset of another set <em>B</em> if every member of <em>B</em> is also a
member of <em>A</em>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let attendees = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
print(employees.isSuperset(of: attendees))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>possibleSubset</code>:</strong>  A sequence of elements. <code>possibleSubset</code> must
  be finite.
<strong>Returns:</strong> <code>true</code> if the set is a superset of <code>possibleSubset</code>;
  otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func isSuperset&lt;S&gt;(of possibleSubset: S) -&gt; Bool where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-lexicographicallyprecedes_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lexicographicallyprecedes_by_">func lexicographicallyPrecedes(<wbr>_:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-lexicographicallyprecedes_by_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the given
predicate to compare elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p><strong>Parameters:</strong>
  <strong>other:</strong> A sequence to compare to this sequence.
  <strong>areInIncreasingOrder:</strong>  A predicate that returns <code>true</code> if its first
    argument should be ordered before its second argument; otherwise,
    <code>false</code>.
<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary
  ordering as ordered by <code>areInIncreasingOrder</code>; otherwise, <code>false</code>.</p>

<p><strong>Note:</strong> This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use <code>String</code> APIs that perform
  localized comparison instead.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lexicographicallyPrecedes&lt;OtherSequence&gt;(_ other: OtherSequence, by areInIncreasingOrder: (Set&lt;Element&gt;.Element, Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool where OtherSequence : Sequence, Set&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-makeiterator">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-makeiterator">func makeIterator()</a>
        
<div class="comment collapse" id="comment-func-makeiterator"><div class="p">
    <p>Returns an iterator over the members of the set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func makeIterator() -&gt; SetIterator&lt;Element&gt;</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-map_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-map_">func map(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-map_"><div class="p">
    <p>Returns an array containing the results of mapping the given closure
over the sequence&#39;s elements.</p>

<p>In this example, <code>map</code> is used first to convert the names in the array
to lowercase strings and then to count their characters.</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let lowercaseNames = cast.map { $0.lowercased() }
// &#39;lowercaseNames&#39; == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]
let letterCounts = cast.map { $0.count }
// &#39;letterCounts&#39; == [6, 6, 3, 4]</code></pre>

<p><strong><code>transform</code>:</strong>  A mapping closure. <code>transform</code> accepts an
  element of this sequence as its parameter and returns a transformed
  value of the same or of a different type.
<strong>Returns:</strong> An array containing the transformed elements of this
  sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func map&lt;T&gt;(_ transform: (Set&lt;Element&gt;.Element) throws -&gt; T) rethrows -&gt; [T]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-max-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-max-by_">@warn_unqualified_access
     func max(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-max-by_"><div class="p">
    <p>Returns the maximum element in the sequence, using the given predicate
as the comparison between elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>This example shows how to use the <code>max(by:)</code> method on a
dictionary to find the key-value pair with the highest value.</p>

<pre><code class="language-swift">let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]
let greatestHue = hues.max { a, b in a.value &lt; b.value }
print(greatestHue)
// Prints &quot;Optional((&quot;Heliotrope&quot;, 296))&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>   A predicate that returns <code>true</code> if its
  first argument should be ordered before its second argument;
  otherwise, <code>false</code>.
<strong>Returns:</strong> The sequence&#39;s maximum element if the sequence is not empty;
  otherwise, <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func max(by areInIncreasingOrder: (Set&lt;Element&gt;.Element, Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-min-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-min-by_">func min(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-min-by_"><div class="p">
    <p>Returns the minimum element in the sequence, using the given predicate as
the comparison between elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>This example shows how to use the <code>min(by:)</code> method on a
dictionary to find the key-value pair with the lowest value.</p>

<pre><code class="language-swift">let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]
let leastHue = hues.min { a, b in a.value &lt; b.value }
print(leastHue)
// Prints &quot;Optional((&quot;Coral&quot;, 16))&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code>
  if its first argument should be ordered before its second
  argument; otherwise, <code>false</code>.
<strong>Returns:</strong> The sequence&#39;s minimum element, according to
  <code>areInIncreasingOrder</code>. If the sequence has no elements, returns
  <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func min(by areInIncreasingOrder: (Set&lt;Element&gt;.Element, Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-popfirst">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-popfirst">mutating func popFirst()</a>
        
<div class="comment collapse" id="comment-func-popfirst"><div class="p">
    <p>Removes and returns the first element of the set.</p>

<p>Because a set is not an ordered collection, the &quot;first&quot; element may not
be the first element that was added to the set.</p>

<p><strong>Returns:</strong> A member of the set. If the set is empty, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func popFirst() -&gt; Set&lt;Element&gt;.Element?</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix_">func prefix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-prefix_"><div class="p">
    <p>Returns a subsequence, up to the specified maximum length, containing
the initial elements of the collection.</p>

<p>If the maximum length exceeds the number of elements in the collection,
the result contains all the elements in the collection.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.prefix(2))
// Prints &quot;[1, 2]&quot;
print(numbers.prefix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return.
  <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting at the beginning of this collection
  with at most <code>maxLength</code> elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(_ maxLength: Int) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-through_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-through_">func prefix(<wbr>through:)</a>
        
<div class="comment collapse" id="comment-func-prefix-through_"><div class="p">
    <p>Returns a subsequence from the start of the collection through the
specified position.</p>

<p>The resulting subsequence <em>includes</em> the element at the position <code>end</code>. 
The following example searches for the index of the number <code>40</code> in an
array of integers, and then prints the prefix of the array up to, and
including, that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.prefix(through: i))
}
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p>Using the <code>prefix(through:)</code> method is equivalent to using a partial
closed range as the collection&#39;s subscript. The subscript notation is
preferred over <code>prefix(through:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[...i])
}
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p><strong><code>end</code>:</strong>  The index of the last element to include in the
  resulting subsequence. <code>end</code> must be a valid index of the collection
  that is not equal to the <code>endIndex</code> property.
<strong>Returns:</strong> A subsequence up to, and including, the <code>end</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(through position: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-upto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-upto_">func prefix(<wbr>upTo:)</a>
        
<div class="comment collapse" id="comment-func-prefix-upto_"><div class="p">
    <p>Returns a subsequence from the start of the collection up to, but not
including, the specified position.</p>

<p>The resulting subsequence <em>does not include</em> the element at the position
<code>end</code>. The following example searches for the index of the number <code>40</code>
in an array of integers, and then prints the prefix of the array up to,
but not including, that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.prefix(upTo: i))
}
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p>Passing the collection&#39;s starting index as the <code>end</code> parameter results in
an empty subsequence.</p>

<pre><code class="language-swift">print(numbers.prefix(upTo: numbers.startIndex))
// Prints &quot;[]&quot;</code></pre>

<p>Using the <code>prefix(upTo:)</code> method is equivalent to using a partial
half-open range as the collection&#39;s subscript. The subscript notation is
preferred over <code>prefix(upTo:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[..&lt;i])
}
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p><strong><code>end</code>:</strong>  The &quot;past the end&quot; index of the resulting subsequence.
  <code>end</code> must be a valid index of the collection.
<strong>Returns:</strong> A subsequence up to, but not including, the <code>end</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(upTo end: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-while_">func prefix(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-prefix-while_"><div class="p">
    <p>Returns a subsequence containing the initial elements until <code>predicate</code>
returns <code>false</code> and skipping the remaining elements.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns <code>true</code> if the element should
  be included or <code>false</code> if it should be excluded. Once the predicate
  returns <code>false</code> it will not be called again.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(while predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-randomelement">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-randomelement">func randomElement()</a>
        
<div class="comment collapse" id="comment-func-randomelement"><div class="p">
    <p>Returns a random element of the collection.</p>

<p>Call <code>randomElement()</code> to select a random element from an array or
another collection. This example picks a name at random from an array:</p>

<pre><code class="language-swift">let names = [&quot;Zoey&quot;, &quot;Chloe&quot;, &quot;Amani&quot;, &quot;Amaia&quot;]
let randomName = names.randomElement()!
// randomName == &quot;Amani&quot;</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>names.randomElement()</code> above is equivalent to calling
<code>names.randomElement(using: &amp;Random.default)</code>.</p>

<p><strong>Returns:</strong> A random element from the collection. If the collection is
  empty, the method returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func randomElement() -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-randomelement-using_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-randomelement-using_">func randomElement(<wbr>using:)</a>
        
<div class="comment collapse" id="comment-func-randomelement-using_"><div class="p">
    <p>Returns a random element of the collection, using the given generator as
a source for randomness.</p>

<p>Call <code>randomElement(using:)</code> to select a random element from an array or
another collection when you are using a custom random number generator.
This example picks a name at random from an array:</p>

<pre><code class="language-swift">let names = [&quot;Zoey&quot;, &quot;Chloe&quot;, &quot;Amani&quot;, &quot;Amaia&quot;]
let randomName = names.randomElement(using: &amp;myGenerator)!
// randomName == &quot;Amani&quot;</code></pre>

<p><strong><code>generator</code>:</strong>  The random number generator to use when choosing
  a random element.
<strong>Returns:</strong> A random element from the collection. If the collection is
  empty, the method returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func randomElement&lt;T&gt;(using generator: inout T) -&gt; Set&lt;Element&gt;.Element? where T : RandomNumberGenerator</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reduce__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reduce__">func reduce(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reduce__"><div class="p">
    <p>Returns the result of combining the elements of the sequence using the
given closure.</p>

<p>Use the <code>reduce(_:_:)</code> method to produce a single value from the elements
of an entire sequence. For example, you can use this method on an array
of numbers to find their sum or product.</p>

<p>The <code>nextPartialResult</code> closure is called sequentially with an
accumulating value initialized to <code>initialResult</code> and each element of
the sequence. This example shows how to find the sum of an array of
numbers.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4]
let numberSum = numbers.reduce(0, { x, y in
    x + y
})
// numberSum == 10</code></pre>

<p>When <code>numbers.reduce(_:_:)</code> is called, the following steps occur:</p>

<ol><li>The <code>nextPartialResult</code> closure is called with <code>initialResult</code>---<code>0</code>
in this case---and the first element of <code>numbers</code>, returning the sum:
<code>1</code>.</li><li>The closure is called again repeatedly with the previous call&#39;s return
value and each element of the sequence.</li><li>When the sequence is exhausted, the last value returned from the
closure is returned to the caller.</li></ol>

<p>If the sequence has no elements, <code>nextPartialResult</code> is never executed
and <code>initialResult</code> is the result of the call to <code>reduce(_:_:)</code>.</p>

<p><strong>Parameters:</strong>
  <strong>initialResult:</strong> The value to use as the initial accumulating value.
    <code>initialResult</code> is passed to <code>nextPartialResult</code> the first time the
    closure is executed.
  <strong>nextPartialResult:</strong> A closure that combines an accumulating value and
    an element of the sequence into a new accumulating value, to be used
    in the next call of the <code>nextPartialResult</code> closure or returned to
    the caller.
<strong>Returns:</strong> The final accumulated value. If the sequence has no elements,
  the result is <code>initialResult</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Set&lt;Element&gt;.Element) throws -&gt; Result) rethrows -&gt; Result</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reduce-into__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reduce-into__">func reduce(<wbr>into:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reduce-into__"><div class="p">
    <p>Returns the result of combining the elements of the sequence using the
given closure.</p>

<p>Use the <code>reduce(into:_:)</code> method to produce a single value from the
elements of an entire sequence. For example, you can use this method on an
array of integers to filter adjacent equal entries or count frequencies.</p>

<p>This method is preferred over <code>reduce(_:_:)</code> for efficiency when the
result is a copy-on-write type, for example an Array or a Dictionary.</p>

<p>The <code>updateAccumulatingResult</code> closure is called sequentially with a
mutable accumulating value initialized to <code>initialResult</code> and each element
of the sequence. This example shows how to build a dictionary of letter
frequencies of a string.</p>

<pre><code class="language-swift">let letters = &quot;abracadabra&quot;
let letterCount = letters.reduce(into: [:]) { counts, letter in
    counts[letter, default: 0] += 1
}
// letterCount == [&quot;a&quot;: 5, &quot;b&quot;: 2, &quot;r&quot;: 2, &quot;c&quot;: 1, &quot;d&quot;: 1]</code></pre>

<p>When <code>letters.reduce(into:_:)</code> is called, the following steps occur:</p>

<ol><li>The <code>updateAccumulatingResult</code> closure is called with the initial
accumulating value---<code>[:]</code> in this case---and the first character of
<code>letters</code>, modifying the accumulating value by setting <code>1</code> for the key
<code>&quot;a&quot;</code>.</li><li>The closure is called again repeatedly with the updated accumulating
value and each element of the sequence.</li><li>When the sequence is exhausted, the accumulating value is returned to
the caller.</li></ol>

<p>If the sequence has no elements, <code>updateAccumulatingResult</code> is never
executed and <code>initialResult</code> is the result of the call to
<code>reduce(into:_:)</code>.</p>

<p><strong>Parameters:</strong>
  <strong>initialResult:</strong> The value to use as the initial accumulating value.
  <strong>updateAccumulatingResult:</strong> A closure that updates the accumulating
    value with an element of the sequence.
<strong>Returns:</strong> The final accumulated value. If the sequence has no elements,
  the result is <code>initialResult</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reduce&lt;Result&gt;(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Set&lt;Element&gt;.Element) throws -&gt; ()) rethrows -&gt; Result</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-remove_-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remove_-set-element-element">mutating func remove(<wbr>_: Set&lt;Element&gt;.Element)</a>
        
<div class="comment collapse" id="comment-func-remove_-set-element-element"><div class="p">
    <p>Removes the specified element from the set.</p>

<p>This example removes the element <code>&quot;sugar&quot;</code> from a set of ingredients.</p>

<pre><code class="language-swift">var ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]
let toRemove = &quot;sugar&quot;
if let removed = ingredients.remove(toRemove) {
    print(&quot;The recipe is now \(removed)-free.&quot;)
}
// Prints &quot;The recipe is now sugar-free.&quot;</code></pre>

<p><strong><code>member</code>:</strong>  The element to remove from the set.
<strong>Returns:</strong> The value of the <code>member</code> parameter if it was a member of the
  set; otherwise, <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func remove(_ member: Set&lt;Element&gt;.Element) -&gt; Set&lt;Element&gt;.Element?</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-remove-concreteelement_-concreteelement">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remove-concreteelement_-concreteelement">mutating func remove&lt;ConcreteElement&gt;(<wbr>_: ConcreteElement)</a>
        
<div class="comment collapse" id="comment-func-remove-concreteelement_-concreteelement"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func remove&lt;ConcreteElement&gt;(_ member: ConcreteElement) -&gt; ConcreteElement? where ConcreteElement : Hashable</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-remove-at_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remove-at_">mutating func remove(<wbr>at:)</a>
        
<div class="comment collapse" id="comment-func-remove-at_"><div class="p">
    <p>Removes the element at the given index of the set.</p>

<p><strong><code>position</code>:</strong>  The index of the member to remove. <code>position</code> must
  be a valid index of the set, and must not be equal to the set&#39;s end
  index.
<strong>Returns:</strong> The element that was removed from the set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func remove(at position: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.Element</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-removeall-keepingcapacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removeall-keepingcapacity_">mutating func removeAll(<wbr>keepingCapacity:)</a>
        
<div class="comment collapse" id="comment-func-removeall-keepingcapacity_"><div class="p">
    <p>Removes all members from the set.</p>

<p><strong><code>keepingCapacity</code>:</strong>  If <code>true</code>, the set&#39;s buffer capacity is
  preserved; if <code>false</code>, the underlying buffer is released. The
  default is <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-removefirst">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removefirst">mutating func removeFirst()</a>
        
<div class="comment collapse" id="comment-func-removefirst"><div class="p">
    <p>Removes the first element of the set.</p>

<p>Because a set is not an ordered collection, the &quot;first&quot; element may not
be the first element that was added to the set. The set must not be
empty.</p>

<p><strong>Complexity:</strong> Amortized O(1) if the set does not wrap a bridged <code>NSSet</code>.
  If the set wraps a bridged <code>NSSet</code>, the performance is unspecified.</p>

<p><strong>Returns:</strong> A member of the set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeFirst() -&gt; Set&lt;Element&gt;.Element</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-reservecapacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reservecapacity_">mutating func reserveCapacity(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reservecapacity_"><div class="p">
    <p>Reserves enough space to store the specified number of elements.</p>

<p>If you are adding a known number of elements to a set, use this
method to avoid multiple reallocations. This method ensures that the
set has unique, mutable, contiguous storage, with space allocated
for at least the requested number of elements.</p>

<p>Calling the <code>reserveCapacity(_:)</code> method on a set with bridged
storage triggers a copy to contiguous storage even if the existing
storage has room to store <code>minimumCapacity</code> elements.</p>

<p><strong><code>minimumCapacity</code>:</strong>  The requested number of elements to
  store.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func reserveCapacity(_ minimumCapacity: Int)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-reversed">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reversed">func reversed()</a>
        
<div class="comment collapse" id="comment-func-reversed"><div class="p">
    <p>Returns an array containing the elements of this sequence in reverse
order.</p>

<p>The sequence must be finite.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

<p><strong>Returns:</strong> An array containing the elements of this sequence in
  reverse order.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reversed() -&gt; [Set&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffled">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffled">func shuffled()</a>
        
<div class="comment collapse" id="comment-func-shuffled"><div class="p">
    <p>Returns the elements of the sequence, shuffled.</p>

<p>For example, you can shuffle the numbers between <code>0</code> and <code>9</code> by calling
the <code>shuffled()</code> method on that range:</p>

<pre><code class="language-swift">let numbers = 0...9
let shuffledNumbers = numbers.shuffled()
// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>numbers.shuffled()</code> above is equivalent to calling
<code>numbers.shuffled(using: &amp;Random.default)</code>.</p>

<p><strong>Returns:</strong> A shuffled array of this sequence&#39;s elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func shuffled() -&gt; [Set&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffled-using_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffled-using_">func shuffled(<wbr>using:)</a>
        
<div class="comment collapse" id="comment-func-shuffled-using_"><div class="p">
    <p>Returns the elements of the sequence, shuffled using the given generator
as a source for randomness.</p>

<p>You use this method to randomize the elements of a sequence when you
are using a custom random number generator. For example, you can shuffle
the numbers between <code>0</code> and <code>9</code> by calling the <code>shuffled(using:)</code> method
on that range:</p>

<pre><code class="language-swift">let numbers = 0...9
let shuffledNumbers = numbers.shuffled(using: &amp;myGenerator)
// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]</code></pre>

<p><strong><code>generator</code>:</strong>  The random number generator to use when shuffling
  the sequence.
<strong>Returns:</strong> An array of this sequence&#39;s elements in a shuffled order.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func shuffled&lt;T&gt;(using generator: inout T) -&gt; [Set&lt;Element&gt;.Element] where T : RandomNumberGenerator</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-sorted-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-sorted-by_">func sorted(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-sorted-by_"><div class="p">
    <p>Returns the elements of the sequence, sorted using the given predicate as
the comparison between elements.</p>

<p>When you want to sort a sequence of elements that don&#39;t conform to the
<code>Comparable</code> protocol, pass a predicate to this method that returns
<code>true</code> when the first element passed should be ordered before the
second. The elements of the resulting array are ordered according to the
given predicate.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also <code>true</code>.
(Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements for which <code>areInIncreasingOrder</code> does not
establish an order.</p>

<p>In the following example, the predicate provides an ordering for an array
of a custom <code>HTTPResponse</code> type. The predicate orders errors before
successes and sorts the error responses by their error code.</p>

<pre><code class="language-swift">enum HTTPResponse {
    case ok
    case error(Int)
}

let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
let sortedResponses = responses.sorted {
    switch ($0, $1) {
    // Order errors by code
    case let (.error(aCode), .error(bCode)):
        return aCode &lt; bCode

    // All successes are equivalent, so none is before any other
    case (.ok, .ok): return false

    // Order errors before successes
    case (.error, .ok): return true
    case (.ok, .error): return false
    }
}
print(sortedResponses)
// Prints &quot;[.error(403), .error(404), .error(500), .ok, .ok]&quot;</code></pre>

<p>You also use this method to sort elements that conform to the
<code>Comparable</code> protocol in descending order. To sort your sequence in
descending order, pass the greater-than operator (<code>&gt;</code>) as the
<code>areInIncreasingOrder</code> parameter.</p>

<pre><code class="language-swift">let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
let descendingStudents = students.sorted(by: &gt;)
print(descendingStudents)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

<p>Calling the related <code>sorted()</code> method is equivalent to calling this
method and passing the less-than operator (<code>&lt;</code>) as the predicate.</p>

<pre><code class="language-swift">print(students.sorted())
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;
print(students.sorted(by: &lt;))
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code> if its
  first argument should be ordered before its second argument;
  otherwise, <code>false</code>.
<strong>Returns:</strong> A sorted array of the sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func sorted(by areInIncreasingOrder: (Set&lt;Element&gt;.Element, Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [Set&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-split_omittingemptysubsequences_whereseparator_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-split_omittingemptysubsequences_whereseparator_">func split(<wbr>_:<wbr>omittingEmptySubsequences:<wbr>whereSeparator:)</a>
        
<div class="comment collapse" id="comment-func-split_omittingemptysubsequences_whereseparator_"><div class="p">
    <p>Returns the longest possible subsequences of the collection, in order,
that don&#39;t contain elements satisfying the given predicate.</p>

<p>The resulting array consists of at most <code>maxSplits + 1</code> subsequences.
Elements that are used to split the sequence are not returned as part of
any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string using a
closure that matches spaces. The first use of <code>split</code> returns each word
that was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(line.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>
parameter, so the returned array contains empty strings where spaces
were repeated.</p>

<pre><code class="language-swift">print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>maxSplits:</strong> The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    <code>maxSplits + 1</code> subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    <code>maxSplits</code> must be greater than or equal to zero. The default value
    is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each pair of consecutive elements
    satisfying the <code>isSeparator</code> predicate and for each element at the
    start or end of the collection satisfying the <code>isSeparator</code>
    predicate. The default value is <code>true</code>.
  <strong>isSeparator:</strong> A closure that takes an element as an argument and
    returns a Boolean value indicating whether the collection should be
    split at that element.
<strong>Returns:</strong> An array of subsequences, split from this collection&#39;s
  elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [Set&lt;Element&gt;.SubSequence]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-starts-with_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-starts-with_by_">func starts(<wbr>with:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-starts-with_by_"><div class="p">
    <p>Returns a Boolean value indicating whether the initial elements of the
sequence are equivalent to the elements in another sequence, using
the given predicate as the equivalence test.</p>

<p>The predicate must be a <em>equivalence relation</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)</li><li><code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)</li><li>If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then
<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)</li></ul>

<p><strong>Parameters:</strong>
  <strong>possiblePrefix:</strong> A sequence to compare to this sequence.
  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments
    are equivalent; otherwise, <code>false</code>.
<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are equivalent
  to the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If
  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func starts&lt;PossiblePrefix&gt;(with possiblePrefix: PossiblePrefix, by areEquivalent: (Set&lt;Element&gt;.Element, PossiblePrefix.Element) throws -&gt; Bool) rethrows -&gt; Bool where PossiblePrefix : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-subtract_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtract_-set-set-element-element">mutating func subtract(<wbr>_: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-subtract_-set-set-element-element"><div class="p">
    <p>Removes the elements of the given set from this set.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
also members of the <code>neighbors</code> set are removed. In particular, the
names <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
employees.subtract(neighbors)
print(employees)
// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func subtract(_ other: Set&lt;Set&lt;Element&gt;.Element&gt;)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-subtract_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtract_">mutating func subtract(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subtract_"><div class="p">
    <p>Removes the elements of the given set from this set.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
also members of the <code>neighbors</code> set are removed. In particular, the
names <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
employees.subtract(neighbors)
print(employees)
// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func subtract(_ other: Set&lt;Element&gt;)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-subtract-s_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtract-s_-s">mutating func subtract&lt;S&gt;(<wbr>_: S)</a>
        
<div class="comment collapse" id="comment-func-subtract-s_-s"><div class="p">
    <p>Removes the elements of the given sequence from the set.</p>

<p>In the following example, the elements of the <code>employees</code> set that are
also elements of the <code>neighbors</code> array are removed. In particular, the
names <code>&quot;Bethany&quot;</code> and <code>&quot;Eric&quot;</code> are removed from <code>employees</code>.</p>

<pre><code class="language-swift">var employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
employees.subtract(neighbors)
print(employees)
// Prints &quot;[&quot;Chris&quot;, &quot;Diana&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func subtract&lt;S&gt;(_ other: S)</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-subtracting_-set-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtracting_-set-set-element-element">func subtracting(<wbr>_: Set&lt;Set&lt;Element&gt;.Element&gt;)</a>
        
<div class="comment collapse" id="comment-func-subtracting_-set-set-element-element"><div class="p">
    <p>Returns a new set containing the elements of this set that do not occur
in the given set.</p>

<p>In the following example, the <code>nonNeighbors</code> set is made up of the
elements of the <code>employees</code> set that are not elements of <code>neighbors</code>:</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
let nonNeighbors = employees.subtracting(neighbors)
print(nonNeighbors)
// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  Another set.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func subtracting(_ other: Set&lt;Set&lt;Element&gt;.Element&gt;) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt;</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-subtracting_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtracting_">func subtracting(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subtracting_"><div class="p">
    <p>Returns a new set containing the elements of this set that do not occur
in the given set.</p>

<p>In the following example, the <code>nonNeighbors</code> set is made up of the
elements of the <code>employees</code> set that are not elements of <code>neighbors</code>:</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors: Set = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
let nonNeighbors = employees.subtract(neighbors)
print(nonNeighbors)
// Prints &quot;[&quot;Diana&quot;, &quot;Chris&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A set of the same type as the current set.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func subtracting(_ other: Set&lt;Element&gt;) -&gt; Set&lt;Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>    
</div></div>
</div>
<div class="declaration" id="func-subtracting-s_-s">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subtracting-s_-s">func subtracting&lt;S&gt;(<wbr>_: S)</a>
        
<div class="comment collapse" id="comment-func-subtracting-s_-s"><div class="p">
    <p>Returns a new set containing the elements of this set that do not occur
in the given sequence.</p>

<p>In the following example, the <code>nonNeighbors</code> set is made up of the
elements of the <code>employees</code> set that are not elements of <code>neighbors</code>:</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Chris&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;, &quot;Greta&quot;]
let nonNeighbors = employees.subtracting(neighbors)
print(nonNeighbors)
// Prints &quot;[&quot;Chris&quot;, &quot;Diana&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func subtracting&lt;S&gt;(_ other: S) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt; where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-suffix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-suffix_">func suffix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-suffix_"><div class="p">
    <p>Returns a subsequence, up to the given maximum length, containing the
final elements of the collection.</p>

<p>If the maximum length exceeds the number of elements in the collection,
the result contains all the elements in the collection.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.suffix(2))
// Prints &quot;[4, 5]&quot;
print(numbers.suffix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The
  value of <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence terminating at the end of the collection with at
  most <code>maxLength</code> elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(_ maxLength: Int) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-suffix-from_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-suffix-from_">func suffix(<wbr>from:)</a>
        
<div class="comment collapse" id="comment-func-suffix-from_"><div class="p">
    <p>Returns a subsequence from the specified position to the end of the
collection.</p>

<p>The following example searches for the index of the number <code>40</code> in an
array of integers, and then prints the suffix of the array starting at
that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.suffix(from: i))
}
// Prints &quot;[40, 50, 60]&quot;</code></pre>

<p>Passing the collection&#39;s <code>endIndex</code> as the <code>start</code> parameter results in
an empty subsequence.</p>

<pre><code class="language-swift">print(numbers.suffix(from: numbers.endIndex))
// Prints &quot;[]&quot;</code></pre>

<p>Using the <code>suffix(from:)</code> method is equivalent to using a partial range
from the index as the collection&#39;s subscript. The subscript notation is
preferred over <code>suffix(from:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[i...])
}
// Prints &quot;[40, 50, 60]&quot;</code></pre>

<p><strong><code>start</code>:</strong>  The index at which to start the resulting subsequence.
  <code>start</code> must be a valid index of the collection.
<strong>Returns:</strong> A subsequence starting at the <code>start</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(from start: Set&lt;Element&gt;.Index) -&gt; Set&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-symmetricdifference_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-symmetricdifference_">func symmetricDifference(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-symmetricdifference_"><div class="p">
    <p>Returns a new set with the elements that are either in this set or in the
given sequence, but not in both.</p>

<p>In the following example, the <code>eitherNeighborsOrEmployees</code> set is made up
of the elements of the <code>employees</code> and <code>neighbors</code> sets that are not in
both <code>employees</code> <em>and</em> <code>neighbors</code>. In particular, the names <code>&quot;Bethany&quot;</code>
and <code>&quot;Eric&quot;</code> do not appear in <code>eitherNeighborsOrEmployees</code>.</p>

<pre><code class="language-swift">let employees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;, &quot;Eric&quot;]
let neighbors = [&quot;Bethany&quot;, &quot;Eric&quot;, &quot;Forlani&quot;]
let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
print(eitherNeighborsOrEmployees)
// Prints &quot;[&quot;Diana&quot;, &quot;Forlani&quot;, &quot;Alicia&quot;]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.
<strong>Returns:</strong> A new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func symmetricDifference&lt;S&gt;(_ other: S) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt; where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-union_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-union_">func union(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-union_"><div class="p">
    <p>Returns a new set with the elements of both this set and the given
sequence.</p>

<p>In the following example, the <code>attendeesAndVisitors</code> set is made up
of the elements of the <code>attendees</code> set and the <code>visitors</code> array:</p>

<pre><code class="language-swift">let attendees: Set = [&quot;Alicia&quot;, &quot;Bethany&quot;, &quot;Diana&quot;]
let visitors = [&quot;Marcia&quot;, &quot;Nathaniel&quot;]
let attendeesAndVisitors = attendees.union(visitors)
print(attendeesAndVisitors)
// Prints &quot;[&quot;Diana&quot;, &quot;Nathaniel&quot;, &quot;Bethany&quot;, &quot;Alicia&quot;, &quot;Marcia&quot;]&quot;</code></pre>

<p>If the set already contains one or more elements that are also in
<code>other</code>, the existing members are kept. If <code>other</code> contains multiple
instances of equivalent elements, only the first instance is kept.</p>

<pre><code class="language-swift">let initialIndices = Set(0..&lt;5)
let expandedIndices = initialIndices.union([2, 3, 6, 6, 7, 7])
print(expandedIndices)
// Prints &quot;[2, 4, 6, 7, 0, 1, 3]&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence of elements. <code>other</code> must be finite.
<strong>Returns:</strong> A new set with the unique elements of this set and <code>other</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func union&lt;S&gt;(_ other: S) -&gt; Set&lt;Set&lt;Element&gt;.Element&gt; where Element == S.Element, S : Sequence</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-update-with_-set-element-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-update-with_-set-element-element">mutating func update(<wbr>with: Set&lt;Element&gt;.Element)</a>
        
<div class="comment collapse" id="comment-func-update-with_-set-element-element"><div class="p">
    <p>Inserts the given element into the set unconditionally.</p>

<p>If an element equal to <code>newMember</code> is already contained in the set,
<code>newMember</code> replaces the existing element. In this example, an existing
element is inserted into <code>classDays</code>, a set of days of the week.</p>

<pre><code class="language-swift">enum DayOfTheWeek: Int {
    case sunday, monday, tuesday, wednesday, thursday,
        friday, saturday
}

var classDays: Set&lt;DayOfTheWeek&gt; = [.monday, .wednesday, .friday]
print(classDays.update(with: .monday))
// Prints &quot;Optional(.monday)&quot;</code></pre>

<p><strong><code>newMember</code>:</strong>  An element to insert into the set.
<strong>Returns:</strong> An element equal to <code>newMember</code> if the set already contained
  such a member; otherwise, <code>nil</code>. In some cases, the returned element
  may be distinguishable from <code>newMember</code> by identity comparison or some
  other means.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func update(with newMember: Set&lt;Element&gt;.Element) -&gt; Set&lt;Element&gt;.Element?</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-update-concreteelement-with_-concreteelement">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-update-concreteelement-with_-concreteelement">mutating func update&lt;ConcreteElement&gt;(<wbr>with: ConcreteElement)</a>
        
<div class="comment collapse" id="comment-func-update-concreteelement-with_-concreteelement"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func update&lt;ConcreteElement&gt;(with newMember: ConcreteElement) -&gt; ConcreteElement? where ConcreteElement : Hashable</code>
    
    
</div></div>
</div>


<h3>Conditionally Inherited Items</h3>

<p class="comment">The initializers, methods, and properties listed below may be available on this type under certain conditions (such as methods that are available on <code>Array</code> when its elements are <code>Equatable</code>) or may not ever be available if that determination is beyond SwiftDoc.org's capabilities. Please <a href="https://github.com/SwiftDocOrg/swiftdoc.org/issues">open an issue on GitHub</a> if you see something out of place!</p>





<h4>Where ArrayLiteralElement == Element</h4>

<div class="declaration inherited" id="arrayliteralelement-element-init-arrayliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-arrayliteralelement-element-init-arrayliteral_">init(<wbr>arrayLiteral:)</a><div class="comment collapse" id="comment-arrayliteralelement-element-init-arrayliteral_"><div class="p">
    <p>Creates a set containing the elements of the given array literal.</p>

<p>Do not call this initializer directly. It is used by the compiler when
you use an array literal. Instead, create a new set using an array
literal as its value by enclosing a comma-separated list of values in
square brackets. You can use an array literal anywhere a set is expected
by the type context.</p>

<p>Here, a set of strings is created from an array literal holding only
strings:</p>

<pre><code class="language-swift">let ingredients: Set = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]
if ingredients.isSuperset(of: [&quot;sugar&quot;, &quot;salt&quot;]) {
    print(&quot;Whatever it is, it&#39;s bound to be delicious!&quot;)
}
// Prints &quot;Whatever it is, it&#39;s bound to be delicious!&quot;</code></pre>

<p><strong><code>arrayLiteral</code>:</strong>  A list of elements of the new set.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(arrayLiteral: Set&lt;Element&gt;.Element...)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/SetAlgebra/"><code>SetAlgebra</code></a>
        </div></div>
</div>








<h4>Where Element : Collection</h4>




<div class="declaration inherited" id="func-element_-collection-joined">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-collection-joined">func joined()</a>
        
<div class="comment collapse" id="comment-func-element_-collection-joined"><div class="p">
    <p>Returns the elements of this collection of collections, concatenated.</p>

<p>In this example, an array of three ranges is flattened so that the
elements of each range can be iterated in turn.</p>

<pre><code class="language-swift">let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]

// A for-in loop over &#39;ranges&#39; accesses each range:
for range in ranges {
  print(range)
}
// Prints &quot;0..&lt;3&quot;
// Prints &quot;8..&lt;10&quot;
// Prints &quot;15..&lt;17&quot;

// Use &#39;joined()&#39; to access each element of each range:
for index in ranges.joined() {
    print(index, terminator: &quot; &quot;)
}
// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>

<p><strong>Returns:</strong> A flattened view of the elements of this
  collection of collections.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined() -&gt; FlattenCollection&lt;Set&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>





<h4>Where Element : Comparable</h4>




<div class="declaration inherited" id="func-element_-comparable-lexicographicallyprecedes_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-lexicographicallyprecedes_">func lexicographicallyPrecedes(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-lexicographicallyprecedes_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the
less-than operator (<code>&lt;</code>) to compare elements.</p>

<p>This example uses the <code>lexicographicallyPrecedes</code> method to test which
array of integers comes first in a lexicographical ordering.</p>

<pre><code class="language-swift">let a = [1, 2, 2, 2]
let b = [1, 2, 3, 4]

print(a.lexicographicallyPrecedes(b))
// Prints &quot;true&quot;
print(b.lexicographicallyPrecedes(b))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary
  ordering; otherwise, <code>false</code>.</p>

<p><strong>Note:</strong> This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use <code>String</code> APIs that
  perform localized comparison.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lexicographicallyPrecedes&lt;OtherSequence&gt;(_ other: OtherSequence) -&gt; Bool where OtherSequence : Sequence, Set&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-max">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-max">@warn_unqualified_access
     func max()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-max"><div class="p">
    <p>Returns the maximum element in the sequence.</p>

<p>This example finds the largest value in an array of height measurements.</p>

<pre><code class="language-swift">let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
let greatestHeight = heights.max()
print(greatestHeight)
// Prints &quot;Optional(67.5)&quot;</code></pre>

<p><strong>Returns:</strong> The sequence&#39;s maximum element. If the sequence has no
  elements, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func max() -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-min">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-min">@warn_unqualified_access
     func min()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-min"><div class="p">
    <p>Returns the minimum element in the sequence.</p>

<p>This example finds the smallest value in an array of height measurements.</p>

<pre><code class="language-swift">let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
let lowestHeight = heights.min()
print(lowestHeight)
// Prints &quot;Optional(58.5)&quot;</code></pre>

<p><strong>Returns:</strong> The sequence&#39;s minimum element. If the sequence has no
  elements, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func min() -&gt; Set&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-sorted">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-sorted">func sorted()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-sorted"><div class="p">
    <p>Returns the elements of the sequence, sorted.</p>

<p>You can sort any sequence of elements that conform to the <code>Comparable</code>
protocol by calling this method. Elements are sorted in ascending order.</p>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements that compare equal.</p>

<p>Here&#39;s an example of sorting a list of students&#39; names. Strings in Swift
conform to the <code>Comparable</code> protocol, so the names are sorted in
ascending order according to the less-than operator (<code>&lt;</code>).</p>

<pre><code class="language-swift">let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
let sortedStudents = students.sorted()
print(sortedStudents)
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>

<p>To sort the elements of your sequence in descending order, pass the
greater-than operator (<code>&gt;</code>) to the <code>sorted(by:)</code> method.</p>

<pre><code class="language-swift">let descendingStudents = students.sorted(by: &gt;)
print(descendingStudents)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

<p><strong>Returns:</strong> A sorted array of the sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func sorted() -&gt; [Set&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : Equatable</h4>




<div class="declaration inherited" id="func-element_-equatable-contains_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-contains_">func contains(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-contains_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence contains the
given element.</p>

<p>This example checks to see whether a favorite actor is in an array
storing a movie&#39;s cast.</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
print(cast.contains(&quot;Marlon&quot;))
// Prints &quot;true&quot;
print(cast.contains(&quot;James&quot;))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>element</code>:</strong>  The element to find in the sequence.
<strong>Returns:</strong> <code>true</code> if the element was found in the sequence; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func contains(_ element: Set&lt;Element&gt;.Element) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-elementsequal_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-elementsequal_">func elementsEqual(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-elementsequal_"><div class="p">
    <p>Returns a Boolean value indicating whether this sequence and another
sequence contain the same elements in the same order.</p>

<p>At least one of the sequences must be finite.</p>

<p>This example tests whether one countable range shares the same elements
as another countable range and an array.</p>

<pre><code class="language-swift">let a = 1...3
let b = 1...10

print(a.elementsEqual(b))
// Prints &quot;false&quot;
print(a.elementsEqual([1, 2, 3]))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain the same elements
  in the same order.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func elementsEqual&lt;OtherSequence&gt;(_ other: OtherSequence) -&gt; Bool where OtherSequence : Sequence, Set&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-firstindex-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-firstindex-of_">func firstIndex(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-firstindex-of_"><div class="p">
    <p>Returns the first index where the specified value appears in the
collection.</p>

<p>After using <code>firstIndex(of:)</code> to find the position of a particular element
in a collection, you can use it to access the element by subscripting.
This example shows how you can modify one of the names in an array of
students.</p>

<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;]
if let i = students.firstIndex(of: &quot;Maxime&quot;) {
    students[i] = &quot;Max&quot;
}
print(students)
// Prints &quot;[&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Max&quot;]&quot;</code></pre>

<p><strong><code>element</code>:</strong>  An element to search for in the collection.
<strong>Returns:</strong> The first index where <code>element</code> is found. If <code>element</code> is not
  found in the collection, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func firstIndex(of element: Set&lt;Element&gt;.Element) -&gt; Set&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-split_maxsplits_omittingemptysubsequences_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-split_maxsplits_omittingemptysubsequences_">func split(<wbr>_:<wbr>maxSplits:<wbr>omittingEmptySubsequences:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-split_maxsplits_omittingemptysubsequences_"><div class="p">
    <p>Returns the longest possible subsequences of the collection, in order,
around elements equal to the given element.</p>

<p>The resulting array consists of at most <code>maxSplits + 1</code> subsequences.
Elements that are used to split the collection are not returned as part
of any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string at each
space character (&quot; &quot;). The first use of <code>split</code> returns each word that
was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(separator: &quot; &quot;))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(line.split(separator: &quot; &quot;, maxSplits: 1))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>
parameter, so the returned array contains empty strings where spaces
were repeated.</p>

<pre><code class="language-swift">print(line.split(separator: &quot; &quot;, omittingEmptySubsequences: false))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>separator:</strong> The element that should be split upon.
  <strong>maxSplits:</strong> The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    <code>maxSplits + 1</code> subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    <code>maxSplits</code> must be greater than or equal to zero. The default value
    is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each consecutive pair of <code>separator</code>
    elements in the collection and for each instance of <code>separator</code> at
    the start or end of the collection. If <code>true</code>, only nonempty
    subsequences are returned. The default value is <code>true</code>.
<strong>Returns:</strong> An array of subsequences, split from this collection&#39;s
  elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(separator: Set&lt;Element&gt;.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -&gt; [Set&lt;Element&gt;.SubSequence]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-starts-with_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-starts-with_">func starts(<wbr>with:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-starts-with_"><div class="p">
    <p>Returns a Boolean value indicating whether the initial elements of the
sequence are the same as the elements in another sequence.</p>

<p>This example tests whether one countable range begins with the elements
of another countable range.</p>

<pre><code class="language-swift">let a = 1...3
let b = 1...10

print(b.starts(with: a))
// Prints &quot;true&quot;</code></pre>

<p>Passing a sequence with no elements or an empty collection as
<code>possiblePrefix</code> always results in <code>true</code>.</p>

<pre><code class="language-swift">print(b.starts(with: []))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>possiblePrefix</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are the same as
  the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If
  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func starts&lt;PossiblePrefix&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool where PossiblePrefix : Sequence, Set&lt;Element&gt;.Element == PossiblePrefix.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : Sequence</h4>




<div class="declaration inherited" id="func-element_-sequence-joined">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-sequence-joined">func joined()</a>
        
<div class="comment collapse" id="comment-func-element_-sequence-joined"><div class="p">
    <p>Returns the elements of this sequence of sequences, concatenated.</p>

<p>In this example, an array of three ranges is flattened so that the
elements of each range can be iterated in turn.</p>

<pre><code class="language-swift">let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]

// A for-in loop over &#39;ranges&#39; accesses each range:
for range in ranges {
  print(range)
}
// Prints &quot;0..&lt;3&quot;
// Prints &quot;8..&lt;10&quot;
// Prints &quot;15..&lt;17&quot;

// Use &#39;joined()&#39; to access each element of each range:
for index in ranges.joined() {
    print(index, terminator: &quot; &quot;)
}
// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>

<p><strong>Returns:</strong> A flattened view of the elements of this
  sequence of sequences.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined() -&gt; FlattenSequence&lt;Set&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-sequence-joined_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-sequence-joined_">func joined(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-sequence-joined_"><div class="p">
    <p>Returns the concatenated elements of this sequence of sequences,
inserting the given separator between each element.</p>

<p>This example shows how an array of <code>[Int]</code> instances can be joined, using
another <code>[Int]</code> instance as the separator:</p>

<pre><code class="language-swift">let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
let joined = nestedNumbers.joined(separator: [-1, -2])
print(Array(joined))
// Prints &quot;[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]&quot;</code></pre>

<p><strong><code>separator</code>:</strong>  A sequence to insert between each of this
  sequence&#39;s elements.
<strong>Returns:</strong> The joined sequence of elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined&lt;Separator&gt;(separator: Separator) -&gt; JoinedSequence&lt;Set&lt;Element&gt;&gt; where Separator : Sequence, Separator.Element == Set&lt;Element&gt;.Element.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : StringProtocol</h4>




<div class="declaration inherited" id="func-element_-stringprotocol-joined_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-stringprotocol-joined_">func joined(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-stringprotocol-joined_"><div class="p">
    <p>Returns a new string by concatenating the elements of the sequence,
adding the given separator between each element.</p>

<p>The following example shows how an array of strings can be joined to a
single, comma-separated string:</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let list = cast.joined(separator: &quot;, &quot;)
print(list)
// Prints &quot;Vivien, Marlon, Kim, Karl&quot;</code></pre>

<p><strong><code>separator</code>:</strong>  A string to insert between each of the elements
  in this sequence. The default separator is an empty string.
<strong>Returns:</strong> A single, concatenated string.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined(separator: String = default) -&gt; String</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Indices == DefaultIndices<Self></h4>


<div class="declaration inherited" id="indices-defaultindices-self-var-indices_-defaultindices-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-indices-defaultindices-self-var-indices_-defaultindices-self">var indices: DefaultIndices&lt;Set&lt;Element&gt;&gt;</a><div class="comment collapse" id="comment-indices-defaultindices-self-var-indices_-defaultindices-self"><div class="p">
    <p>The indices that are valid for subscripting the collection, in ascending
order.</p>

<p>A collection&#39;s <code>indices</code> property can hold a strong reference to the
collection itself, causing the collection to be non-uniquely referenced.
If you mutate the collection while iterating over its indices, a strong
reference can cause an unexpected copy of the collection. To avoid the
unexpected copy, use the <code>index(after:)</code> method starting with
<code>startIndex</code> to produce indices instead.</p>

<pre><code class="language-swift">var c = MyFancyCollection([10, 20, 30, 40, 50])
var i = c.startIndex
while i != c.endIndex {
    c[i] /= 5
    i = c.index(after: i)
}
// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var indices: DefaultIndices&lt;Set&lt;Element&gt;&gt; { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>







<h4>Where Iterator == IndexingIterator<Self></h4>




<div class="declaration inherited" id="func-iterator-indexingiterator-self-makeiterator">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-iterator-indexingiterator-self-makeiterator">func makeIterator()</a>
        
<div class="comment collapse" id="comment-func-iterator-indexingiterator-self-makeiterator"><div class="p">
    <p>Returns an iterator over the elements of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func makeIterator() -&gt; IndexingIterator&lt;Set&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>





<h4>Where SubSequence == AnySequence<Element></h4>




<div class="declaration inherited" id="func-subsequence-anysequence-element-drop-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-drop-while_">func drop(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-drop-while_"><div class="p">
    <p>Returns a subsequence by skipping the initial, consecutive elements that
satisfy the given predicate.</p>

<p>The following example uses the <code>drop(while:)</code> method to skip over the
positive numbers at the beginning of the <code>numbers</code> array. The result
begins with the first element of <code>numbers</code> that does not satisfy
<code>predicate</code>.</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
let startingWithNegative = numbers.drop(while: { $0 &gt; 0 })
// startingWithNegative == [-2, 9, -6, 10, 1]</code></pre>

<p>If <code>predicate</code> matches every element in the sequence, the result is an
empty sequence.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element should be included in the result.
<strong>Returns:</strong> A subsequence starting after the initial, consecutive elements
  that satisfy <code>predicate</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func drop(while predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-dropfirst_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-dropfirst_">func dropFirst(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-dropfirst_"><div class="p">
    <p>Returns a subsequence containing all but the given number of initial
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in
the sequence, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst(2))
// Prints &quot;[3, 4, 5]&quot;
print(numbers.dropFirst(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop from the beginning of
  the sequence. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting after the specified number of
  elements.</p>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst(_ n: Int) -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-droplast_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-droplast_">func dropLast(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-droplast_"><div class="p">
    <p>Returns a subsequence containing all but the given number of final
elements.</p>

<p>The sequence must be finite. If the number of elements to drop exceeds
the number of elements in the sequence, the result is an empty
subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast(2))
// Prints &quot;[1, 2, 3]&quot;
print(numbers.dropLast(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop off the end of the
  sequence. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence leaving off the specified number of elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast(_ n: Int) -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-prefix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-prefix_">func prefix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-prefix_"><div class="p">
    <p>Returns a subsequence, up to the specified maximum length, containing the
initial elements of the sequence.</p>

<p>If the maximum length exceeds the number of elements in the sequence,
the result contains all the elements in the sequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.prefix(2))
// Prints &quot;[1, 2]&quot;
print(numbers.prefix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The
  value of <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting at the beginning of this sequence
  with at most <code>maxLength</code> elements.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(_ maxLength: Int) -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-prefix-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-prefix-while_">func prefix(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-prefix-while_"><div class="p">
    <p>Returns a subsequence containing the initial, consecutive elements that
satisfy the given predicate.</p>

<p>The following example uses the <code>prefix(while:)</code> method to find the
positive numbers at the beginning of the <code>numbers</code> array. Every element
of <code>numbers</code> up to, but not including, the first negative value is
included in the result.</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
let positivePrefix = numbers.prefix(while: { $0 &gt; 0 })
// positivePrefix == [3, 7, 4]</code></pre>

<p>If <code>predicate</code> matches every element in the sequence, the resulting
sequence contains every element of the sequence.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element should be included in the result.
<strong>Returns:</strong> A subsequence of the initial, consecutive elements that
  satisfy <code>predicate</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(while predicate: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_">func split(<wbr>_:<wbr>omittingEmptySubsequences:<wbr>whereSeparator:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_"><div class="p">
    <p>Returns the longest possible subsequences of the sequence, in order, that
don&#39;t contain elements satisfying the given predicate. Elements that are
used to split the sequence are not returned as part of any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string using a
closure that matches spaces. The first use of <code>split</code> returns each word
that was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(whereSeparator: { $0 == &quot; &quot; })
          .map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(
   line.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; })
                  .map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>true</code> for the <code>allowEmptySlices</code> parameter, so
the returned array contains empty strings where spaces were repeated.</p>

<pre><code class="language-swift">print(
    line.split(
        omittingEmptySubsequences: false,
        whereSeparator: { $0 == &quot; &quot; }
    ).map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>maxSplits:</strong> The maximum number of times to split the sequence, or one
    less than the number of subsequences to return. If <code>maxSplits + 1</code>
    subsequences are returned, the last one is a suffix of the original
    sequence containing the remaining elements. <code>maxSplits</code> must be
    greater than or equal to zero. The default value is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each pair of consecutive elements
    satisfying the <code>isSeparator</code> predicate and for each element at the
    start or end of the sequence satisfying the <code>isSeparator</code> predicate.
    If <code>true</code>, only nonempty subsequences are returned. The default
    value is <code>true</code>.
  <strong>isSeparator:</strong> A closure that returns <code>true</code> if its argument should be
    used to split the sequence; otherwise, <code>false</code>.
<strong>Returns:</strong> An array of subsequences, split from this sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Set&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [AnySequence&lt;Set&lt;Element&gt;.Element&gt;]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-suffix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-suffix_">func suffix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-suffix_"><div class="p">
    <p>Returns a subsequence, up to the given maximum length, containing the
final elements of the sequence.</p>

<p>The sequence must be finite. If the maximum length exceeds the number of
elements in the sequence, the result contains all the elements in the
sequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.suffix(2))
// Prints &quot;[4, 5]&quot;
print(numbers.suffix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The
  value of <code>maxLength</code> must be greater than or equal to zero.
<strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(_ maxLength: Int) -&gt; AnySequence&lt;Set&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where SubSequence == Slice<Self></h4>



<div class="declaration inherited" id="subscript-subsequence-slice-self-subscript_-range-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subsequence-slice-self-subscript_-range-self-index">subscript(_: Range&lt;Set&lt;Element&gt;.Index&gt;)</a>
<div class="comment collapse" id="comment-subscript-subsequence-slice-self-subscript_-range-self-index"><div class="p">
    <p>Accesses a contiguous subrange of the collection&#39;s elements.</p>

<p>The accessed slice uses the same indices for the same elements as the
original collection. Always use the slice&#39;s <code>startIndex</code> property
instead of assuming that its indices start at a particular value.</p>

<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>

<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let index = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
print(streets[index!])
// Prints &quot;Evarts&quot;</code></pre>

<p><strong><code>bounds</code>:</strong>  A range of the collection&#39;s indices. The bounds of
  the range must be valid indices of the collection.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(bounds: Range&lt;Set&lt;Element&gt;.Index&gt;) -&gt; Slice&lt;Set&lt;Element&gt;&gt; { get }</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>




