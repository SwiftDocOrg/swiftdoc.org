---
layout: "default"
title: "Array"
description: "Swift documentation for 'Array': An ordered, random-access collection."
keywords: "Array,struct,swift,documentation,allSatisfy,append,append,compactMap,contains,distance,distance,distance,drop,dropFirst,dropFirst,dropLast,dropLast,elementsEqual,encode,enumerated,filter,first,firstIndex,flatMap,flatMap,flatMap,forEach,formIndex,formIndex,formIndex,formIndex,formIndex,formIndex,hash,index,index,index,index,index,index,index,index,insert,insert,last,lastIndex,lexicographicallyPrecedes,map,max,min,partition,popLast,prefix,prefix,prefix,prefix,randomElement,randomElement,reduce,reduce,remove,removeAll,removeAll,removeFirst,removeFirst,removeLast,removeLast,removeSubrange,removeSubrange,replaceSubrange,reserveCapacity,reverse,reversed,shuffle,shuffle,shuffled,shuffled,sort,sorted,split,starts,suffix,suffix,swapAt,withUnsafeBufferPointer,withUnsafeBytes,withUnsafeMutableBufferPointer,withUnsafeMutableBytes,capacity,count,customMirror,debugDescription,description,endIndex,first,hashValue,isEmpty,last,lazy,startIndex,underestimatedCount,Index,Indices,Iterator"
root: "/v4.2"
---

<div class="intro-declaration"><code class="language-swift">struct Array&lt;Element&gt;</code></div>

<div class="discussion comment">
    <p>An ordered, random-access collection.</p>

<p>Arrays are one of the most commonly used data types in an app. You use
arrays to organize your app&#39;s data. Specifically, you use the <code>Array</code> type
to hold elements of a single type, the array&#39;s <code>Element</code> type. An array
can store any kind of elements---from integers to strings to classes.</p>

<p>Swift makes it easy to create arrays in your code using an array literal:
simply surround a comma-separated list of values with square brackets.
Without any other information, Swift creates an array that includes the
specified values, automatically inferring the array&#39;s <code>Element</code> type. For
example:</p>

<pre><code class="language-swift">// An array of &#39;Int&#39; elements
let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]

// An array of &#39;String&#39; elements
let streets = [&quot;Albemarle&quot;, &quot;Brandywine&quot;, &quot;Chesapeake&quot;]</code></pre>

<p>You can create an empty array by specifying the <code>Element</code> type of your
array in the declaration. For example:</p>

<pre><code class="language-swift">// Shortened forms are preferred
var emptyDoubles: [Double] = []

// The full type name is also allowed
var emptyFloats: Array&lt;Float&gt; = Array()</code></pre>

<p>If you need an array that is preinitialized with a fixed number of default
values, use the <code>Array(repeating:count:)</code> initializer.</p>

<pre><code class="language-swift">var digitCounts = Array(repeating: 0, count: 10)
print(digitCounts)
// Prints &quot;[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]&quot;</code></pre>

<h1>Accessing Array Values</h1>

<p>When you need to perform an operation on all of an array&#39;s elements, use a
<code>for</code>-<code>in</code> loop to iterate through the array&#39;s contents.</p>

<pre><code class="language-swift">for street in streets {
    print(&quot;I don&#39;t live on \(street).&quot;)
}
// Prints &quot;I don&#39;t live on Albemarle.&quot;
// Prints &quot;I don&#39;t live on Brandywine.&quot;
// Prints &quot;I don&#39;t live on Chesapeake.&quot;</code></pre>

<p>Use the <code>isEmpty</code> property to check quickly whether an array has any
elements, or use the <code>count</code> property to find the number of elements in
the array.</p>

<pre><code class="language-swift">if oddNumbers.isEmpty {
    print(&quot;I don&#39;t know any odd numbers.&quot;)
} else {
    print(&quot;I know \(oddNumbers.count) odd numbers.&quot;)
}
// Prints &quot;I know 8 odd numbers.&quot;</code></pre>

<p>Use the <code>first</code> and <code>last</code> properties for safe access to the value of the
array&#39;s first and last elements. If the array is empty, these properties
are <code>nil</code>.</p>

<pre><code class="language-swift">if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {
    print(firstElement, lastElement, separator: &quot;, &quot;)
}
// Prints &quot;1, 15&quot;

print(emptyDoubles.first, emptyDoubles.last, separator: &quot;, &quot;)
// Prints &quot;nil, nil&quot;</code></pre>

<p>You can access individual array elements through a subscript. The first
element of a nonempty array is always at index zero. You can subscript an
array with any integer from zero up to, but not including, the count of
the array. Using a negative number or an index equal to or greater than
<code>count</code> triggers a runtime error. For example:</p>

<pre><code class="language-swift">print(oddNumbers[0], oddNumbers[3], separator: &quot;, &quot;)
// Prints &quot;1, 7&quot;

print(emptyDoubles[0])
// Triggers runtime error: Index out of range</code></pre>

<h1>Adding and Removing Elements</h1>

<p>Suppose you need to store a list of the names of students that are signed
up for a class you&#39;re teaching. During the registration period, you need
to add and remove names as students add and drop the class.</p>

<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;]</code></pre>

<p>To add single elements to the end of an array, use the <code>append(_:)</code> method.
Add multiple elements at the same time by passing another array or a
sequence of any kind to the <code>append(contentsOf:)</code> method.</p>

<pre><code class="language-swift">students.append(&quot;Maxime&quot;)
students.append(contentsOf: [&quot;Shakia&quot;, &quot;William&quot;])
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]</code></pre>

<p>You can add new elements in the middle of an array by using the
<code>insert(_:at:)</code> method for single elements and by using
<code>insert(contentsOf:at:)</code> to insert multiple elements from another
collection or array literal. The elements at that index and later indices
are shifted back to make room.</p>

<pre><code class="language-swift">students.insert(&quot;Liam&quot;, at: 3)
// [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]</code></pre>

<p>To remove elements from an array, use the <code>remove(at:)</code>,
<code>removeSubrange(_:)</code>, and <code>removeLast()</code> methods.</p>

<pre><code class="language-swift">// Ben&#39;s family is moving to another state
students.remove(at: 0)
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;, &quot;William&quot;]

// William is signing up for a different class
students.removeLast()
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Maxime&quot;, &quot;Shakia&quot;]</code></pre>

<p>You can replace an existing element with a new value by assigning the new
value to the subscript.</p>

<pre><code class="language-swift">if let i = students.firstIndex(of: &quot;Maxime&quot;) {
    students[i] = &quot;Max&quot;
}
// [&quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Liam&quot;, &quot;Max&quot;, &quot;Shakia&quot;]</code></pre>

<h2>Growing the Size of an Array</h2>

<p>Every array reserves a specific amount of memory to hold its contents. When
you add elements to an array and that array begins to exceed its reserved
capacity, the array allocates a larger region of memory and copies its
elements into the new storage. The new storage is a multiple of the old
storage&#39;s size. This exponential growth strategy means that appending an
element happens in constant time, averaging the performance of many append
operations. Append operations that trigger reallocation have a performance
cost, but they occur less and less often as the array grows larger.</p>

<p>If you know approximately how many elements you will need to store, use the
<code>reserveCapacity(_:)</code> method before appending to the array to avoid
intermediate reallocations. Use the <code>capacity</code> and <code>count</code> properties to
determine how many more elements the array can store without allocating
larger storage.</p>

<p>For arrays of most <code>Element</code> types, this storage is a contiguous block of
memory. For arrays with an <code>Element</code> type that is a class or <code>@objc</code>
protocol type, this storage can be a contiguous block of memory or an
instance of <code>NSArray</code>. Because any arbitrary subclass of <code>NSArray</code> can
become an <code>Array</code>, there are no guarantees about representation or
efficiency in this case.</p>

<h1>Modifying Copies of Arrays</h1>

<p>Each array has an independent value that includes the values of all of its
elements. For simple types such as integers and other structures, this
means that when you change a value in one array, the value of that element
does not change in any copies of the array. For example:</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var numbersCopy = numbers
numbers[0] = 100
print(numbers)
// Prints &quot;[100, 2, 3, 4, 5]&quot;
print(numbersCopy)
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p>If the elements in an array are instances of a class, the semantics are the
same, though they might appear different at first. In this case, the
values stored in the array are references to objects that live outside the
array. If you change a reference to an object in one array, only that
array has a reference to the new object. However, if two arrays contain
references to the same object, you can observe changes to that object&#39;s
properties from both arrays. For example:</p>

<pre><code class="language-swift">// An integer type with reference semantics
class IntegerReference {
    var value = 10
}
var firstIntegers = [IntegerReference(), IntegerReference()]
var secondIntegers = firstIntegers

// Modifications to an instance are visible from either array
firstIntegers[0].value = 100
print(secondIntegers[0].value)
// Prints &quot;100&quot;

// Replacements, additions, and removals are still visible
// only in the modified array
firstIntegers[0] = IntegerReference()
print(firstIntegers[0].value)
// Prints &quot;10&quot;
print(secondIntegers[0].value)
// Prints &quot;100&quot;</code></pre>

<p>Arrays, like all variable-size collections in the standard library, use
copy-on-write optimization. Multiple copies of an array share the same
storage until you modify one of the copies. When that happens, the array
being modified replaces its storage with a uniquely owned copy of itself,
which is then modified in place. Optimizations are sometimes applied that
can reduce the amount of copying.</p>

<p>This means that if an array is sharing storage with other copies, the first
mutating operation on that array incurs the cost of copying the array. An
array that is the sole owner of its storage can perform mutating
operations in place.</p>

<p>In the example below, a <code>numbers</code> array is created along with two copies
that share the same storage. When the original <code>numbers</code> array is
modified, it makes a unique copy of its storage before making the
modification. Further modifications to <code>numbers</code> are made in place, while
the two copies continue to share the original storage.</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
var firstCopy = numbers
var secondCopy = numbers

// The storage for &#39;numbers&#39; is copied here
numbers[0] = 100
numbers[1] = 200
numbers[2] = 300
// &#39;numbers&#39; is [100, 200, 300, 4, 5]
// &#39;firstCopy&#39; and &#39;secondCopy&#39; are [1, 2, 3, 4, 5]</code></pre>

<h1>Bridging Between Array and NSArray</h1>

<p>When you need to access APIs that require data in an <code>NSArray</code> instance
instead of <code>Array</code>, use the type-cast operator (<code>as</code>) to bridge your
instance. For bridging to be possible, the <code>Element</code> type of your array
must be a class, an <code>@objc</code> protocol (a protocol imported from Objective-C
or marked with the <code>@objc</code> attribute), or a type that bridges to a
Foundation type.</p>

<p>The following example shows how you can bridge an <code>Array</code> instance to
<code>NSArray</code> to use the <code>write(to:atomically:)</code> method. In this example, the
<code>colors</code> array can be bridged to <code>NSArray</code> because the <code>colors</code> array&#39;s
<code>String</code> elements bridge to <code>NSString</code>. The compiler prevents bridging the
<code>moreColors</code> array, on the other hand, because its <code>Element</code> type is
<code>Optional&lt;String&gt;</code>, which does <em>not</em> bridge to a Foundation type.</p>

<pre><code class="language-swift">let colors = [&quot;periwinkle&quot;, &quot;rose&quot;, &quot;moss&quot;]
let moreColors: [String?] = [&quot;ochre&quot;, &quot;pine&quot;]

let url = NSURL(fileURLWithPath: &quot;names.plist&quot;)
(colors as NSArray).write(to: url, atomically: true)
// true

(moreColors as NSArray).write(to: url, atomically: true)
// error: cannot convert value of type &#39;[String?]&#39; to type &#39;NSArray&#39;</code></pre>

<p>Bridging from <code>Array</code> to <code>NSArray</code> takes O(1) time and O(1) space if the
array&#39;s elements are already instances of a class or an <code>@objc</code> protocol;
otherwise, it takes O(<em>n</em>) time and space.</p>

<p>When the destination array&#39;s element type is a class or an <code>@objc</code>
protocol, bridging from <code>NSArray</code> to <code>Array</code> first calls the <code>copy(with:)</code>
(<code>**copyWithZone:**</code> in Objective-C) method on the array to get an immutable
copy and then performs additional Swift bookkeeping work that takes O(1)
time. For instances of <code>NSArray</code> that are already immutable, <code>copy(with:)</code>
usually returns the same array in O(1) time; otherwise, the copying
performance is unspecified. If <code>copy(with:)</code> returns the same array, the
instances of <code>NSArray</code> and <code>Array</code> share storage using the same
copy-on-write optimization that is used when two instances of <code>Array</code>
share storage.</p>

<p>When the destination array&#39;s element type is a nonclass type that bridges
to a Foundation type, bridging from <code>NSArray</code> to <code>Array</code> performs a
bridging copy of the elements to contiguous storage in O(<em>n</em>) time. For
example, bridging from <code>NSArray</code> to <code>Array&lt;Int&gt;</code> performs such a copy. No
further bridging is required when accessing elements of the <code>Array</code>
instance.</p>

<p><strong>Note:</strong> The <code>ContiguousArray</code> and <code>ArraySlice</code> types are not bridged;
  instances of those types always have a contiguous block of memory as
  their storage.</p>
</div>

<table class="standard">
<tr>
<th id="inheritance">Inheritance</th>
<td>
<code class="inherits">BidirectionalCollection, Collection, CustomDebugStringConvertible, CustomReflectable, CustomStringConvertible, Decodable, Encodable, Equatable, ExpressibleByArrayLiteral, Hashable, MutableCollection, RandomAccessCollection, RangeReplaceableCollection, Sequence</code>
<span class="viz"><a href="hierarchy/">View Protocol Hierarchy &rarr;</a></span>
</td>
</tr>

<tr>
<th id="aliases">Associated Types</th>
<td>
<span id="aliasesmark"></span>
<div class="declaration">
<code class="language-swift">Index = Int</code>
<div class="comment">
    <p>The index type for arrays, <code>Int</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">Indices = Range&lt;Int&gt;</code>
<div class="comment">
    <p>The type that represents the indices that are valid for subscripting an
array, in ascending order.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">Iterator = IndexingIterator&lt;[Element]&gt;</code>
<div class="comment">
    <p>The type that allows iteration over an array&#39;s elements.</p>
</div>
</div>
</td>
</tr>


<tr>
<th>Import</th>
<td><code class="language-swift">import Swift</code></td>
</tr>

</table>


<h3>Initializers</h3>
<div class="declaration" id="init">
<a class="toggle-link" data-toggle="collapse" href="#comment-init">init()</a><div class="comment collapse" id="comment-init"><div class="p">
    <p>Creates a new, empty array.</p>

<p>This is equivalent to initializing with an empty array literal.
For example:</p>

<pre><code class="language-swift">var emptyArray = Array&lt;Int&gt;()
print(emptyArray.isEmpty)
// Prints &quot;true&quot;

emptyArray = []
print(emptyArray.isEmpty)
// Prints &quot;true&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">init()</code>

    </div></div>
</div>
<div class="declaration" id="init_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init_">init(<wbr>_:)</a><div class="comment collapse" id="comment-init_"><div class="p">
    <p>Creates an array containing the elements of a sequence.</p>

<p>You can use this initializer to create an array from any other type that
conforms to the <code>Sequence</code> protocol. For example, you might want to
create an array with the integers from 1 through 7. Use this initializer
around a range instead of typing all those numbers in an array literal.</p>

<pre><code class="language-swift">let numbers = Array(1...7)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 6, 7]&quot;</code></pre>

<p>You can also use this initializer to convert a complex sequence or
collection type back to an array. For example, the <code>keys</code> property of
a dictionary isn&#39;t an array with its own storage, it&#39;s a collection
that maps its elements from the dictionary only when they&#39;re
accessed, saving the time and space needed to allocate an array. If
you need to pass those keys to a method that takes an array, however,
use this initializer to convert that list from its type of
<code>LazyMapCollection&lt;Dictionary&lt;String, Int&gt;, Int&gt;</code> to a simple
<code>[String]</code>.</p>

<pre><code class="language-swift">func cacheImagesWithNames(names: [String]) {
    // custom image loading and caching
 }

let namedHues: [String: Int] = [&quot;Vermillion&quot;: 18, &quot;Magenta&quot;: 302,
        &quot;Gold&quot;: 50, &quot;Cerise&quot;: 320]
let colorNames = Array(namedHues.keys)
cacheImagesWithNames(colorNames)

print(colorNames)
// Prints &quot;[&quot;Gold&quot;, &quot;Cerise&quot;, &quot;Magenta&quot;, &quot;Vermillion&quot;]&quot;</code></pre>

<p><strong><code>s</code>:</strong>  The sequence of elements to turn into an array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init&lt;S&gt;(_ s: S)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Array/"><code>Array</code></a>
        ,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>
        </div></div>
</div>
<div class="declaration" id="init-arrayliteral_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-arrayliteral_">init(<wbr>arrayLiteral:)</a><div class="comment collapse" id="comment-init-arrayliteral_"><div class="p">
    <p>Creates an array from the given array literal.</p>

<p>Do not call this initializer directly. It is used by the compiler
when you use an array literal. Instead, create a new array by using an
array literal as its value. To do this, enclose a comma-separated list of
values in square brackets.</p>

<p>Here, an array of strings is created from an array literal holding
only strings.</p>

<pre><code class="language-swift">let ingredients = [&quot;cocoa beans&quot;, &quot;sugar&quot;, &quot;cocoa butter&quot;, &quot;salt&quot;]</code></pre>

<p><strong><code>elements</code>:</strong>  A variadic list of elements of the new array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(arrayLiteral elements: [Element].Element...)</code>

    </div></div>
</div>
<div class="declaration" id="init-from_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-from_">init(<wbr>from:)</a><div class="comment collapse" id="comment-init-from_"><div class="p">
    <p>Creates a new array by decoding from the given decoder.</p>

<p>This initializer throws an error if reading from the decoder fails, or
if the data read is corrupted or otherwise invalid.</p>

<p><strong><code>decoder</code>:</strong>  The decoder to read data from.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(from decoder: Decoder)</code>

    </div></div>
</div>
<div class="declaration" id="init-repeating_count_">
<a class="toggle-link" data-toggle="collapse" href="#comment-init-repeating_count_">init(<wbr>repeating:<wbr>count:)</a><div class="comment collapse" id="comment-init-repeating_count_"><div class="p">
    <p>Creates a new array containing the specified number of a single, repeated
value.</p>

<p>Here&#39;s an example of creating an array initialized with five strings
containing the letter <em>Z</em>.</p>

<pre><code class="language-swift">let fiveZs = Array(repeating: &quot;Z&quot;, count: 5)
print(fiveZs)
// Prints &quot;[&quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;, &quot;Z&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>repeatedValue:</strong> The element to repeat.
  <strong>count:</strong> The number of times to repeat the value passed in the
    <code>repeating</code> parameter. <code>count</code> must be zero or greater.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">init(repeating repeatedValue: [Element].Element, count: Int)</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Array/"><code>Array</code></a>
        ,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>
        </div></div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="var-capacity_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-capacity_-int">var capacity: Int</a><div class="comment collapse" id="comment-var-capacity_-int"><div class="p">
    <p>The total number of elements that the array can contain without
allocating new storage.</p>

<p>Every array reserves a specific amount of memory to hold its contents.
When you add elements to an array and that array begins to exceed its
reserved capacity, the array allocates a larger region of memory and
copies its elements into the new storage. The new storage is a multiple
of the old storage&#39;s size. This exponential growth strategy means that
appending an element happens in constant time, averaging the performance
of many append operations. Append operations that trigger reallocation
have a performance cost, but they occur less and less often as the array
grows larger.</p>

<p>The following example creates an array of integers from an array literal,
then appends the elements of another collection. Before appending, the
array allocates new storage that is large enough store the resulting
elements.</p>

<pre><code class="language-swift">var numbers = [10, 20, 30, 40, 50]
// numbers.count == 5
// numbers.capacity == 5

numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
// numbers.count == 10
// numbers.capacity == 12</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var capacity: Int { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-count_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-count_-int">var count: Int</a><div class="comment collapse" id="comment-var-count_-int"><div class="p">
    <p>The number of elements in the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var count: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Array/"><code>Array</code></a>
        ,    <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration" id="var-custommirror_-mirror">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-custommirror_-mirror">var customMirror: Mirror</a><div class="comment collapse" id="comment-var-custommirror_-mirror"><div class="p">
    <p>A mirror that reflects the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var customMirror: Mirror { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-debugdescription_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-debugdescription_-string">var debugDescription: String</a><div class="comment collapse" id="comment-var-debugdescription_-string"><div class="p">
    <p>A textual representation of the array and its elements, suitable for
debugging.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var debugDescription: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-description_-string">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-description_-string">var description: String</a><div class="comment collapse" id="comment-var-description_-string"><div class="p">
    <p>A textual representation of the array and its elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var description: String { get }</code>

    </div></div>
</div>
<div class="declaration" id="var-endindex_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-endindex_-int">var endIndex: Int</a><div class="comment collapse" id="comment-var-endindex_-int"><div class="p">
    <p>The array&#39;s &quot;past the end&quot; position---that is, the position one greater
than the last valid subscript argument.</p>

<p>When you need a range that includes the last element of an array, use the
half-open range operator (<code>..&lt;</code>) with <code>endIndex</code>. The <code>..&lt;</code> operator
creates a range that doesn&#39;t include the upper bound, so it&#39;s always
safe to use with <code>endIndex</code>. For example:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let i = numbers.firstIndex(of: 30) {
    print(numbers[i ..&lt; numbers.endIndex])
}
// Prints &quot;[30, 40, 50]&quot;</code></pre>

<p>If the array is empty, <code>endIndex</code> is equal to <code>startIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var endIndex: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-first_-self-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-first_-self-element">var first: Array&lt;Element&gt;.Element?</a><div class="comment collapse" id="comment-var-first_-self-element"><div class="p">
    <p>The first element of the collection.</p>

<p>If the collection is empty, the value of this property is <code>nil</code>.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let firstNumber = numbers.first {
    print(firstNumber)
}
// Prints &quot;10&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var first: Array&lt;Element&gt;.Element? { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration" id="var-hashvalue_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-hashvalue_-int">var hashValue: Int</a><div class="comment collapse" id="comment-var-hashvalue_-int"><div class="p">
    <p>Hashes the essential components of this value by feeding them into the
given hasher.</p>

<p><strong><code>hasher</code>:</strong>  The hasher to use when combining the components
  of this instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var hashValue: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-isempty_-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-isempty_-bool">var isEmpty: Bool</a><div class="comment collapse" id="comment-var-isempty_-bool"><div class="p">
    <p>A Boolean value indicating whether the collection is empty.</p>

<p>When you need to check whether your collection is empty, use the
<code>isEmpty</code> property instead of checking that the <code>count</code> property is
equal to zero. For collections that don&#39;t conform to
<code>RandomAccessCollection</code>, accessing the <code>count</code> property iterates
through the elements of the collection.</p>

<pre><code class="language-swift">let horseName = &quot;Silver&quot;
if horseName.isEmpty {
    print(&quot;I&#39;ve been through the desert on a horse with no name.&quot;)
} else {
    print(&quot;Hi ho, \(horseName)!&quot;)
}
// Prints &quot;Hi ho, Silver!&quot;)</code></pre>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var isEmpty: Bool { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-last_-self-element">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-last_-self-element">var last: Array&lt;Element&gt;.Element?</a><div class="comment collapse" id="comment-var-last_-self-element"><div class="p">
    <p>The last element of the collection.</p>

<p>If the collection is empty, the value of this property is <code>nil</code>.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let lastNumber = numbers.last {
    print(lastNumber)
}
// Prints &quot;50&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var last: Array&lt;Element&gt;.Element? { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>
        </div></div>
</div>
<div class="declaration inherited" id="var-lazy_-lazycollection-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-lazy_-lazycollection-self">var lazy: LazyCollection&lt;Array&lt;Element&gt;&gt;</a><div class="comment collapse" id="comment-var-lazy_-lazycollection-self"><div class="p">
    <p>A view onto this collection that provides lazy implementations of
normally eager operations, such as <code>map</code> and <code>filter</code>.</p>

<p>Use the <code>lazy</code> property when chaining operations to prevent
intermediate operations from allocating storage, or when you only
need a part of the final collection to avoid unnecessary computation.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var lazy: LazyCollection&lt;Array&lt;Element&gt;&gt; { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>
<div class="declaration" id="var-startindex_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-startindex_-int">var startIndex: Int</a><div class="comment collapse" id="comment-var-startindex_-int"><div class="p">
    <p>The position of the first element in a nonempty array.</p>

<p>For an instance of <code>Array</code>, <code>startIndex</code> is always zero. If the array
is empty, <code>startIndex</code> is equal to <code>endIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var startIndex: Int { get }</code>

    </div></div>
</div>
<div class="declaration inherited" id="var-underestimatedcount_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-var-underestimatedcount_-int">var underestimatedCount: Int</a><div class="comment collapse" id="comment-var-underestimatedcount_-int"><div class="p">
    <p>A value less than or equal to the number of elements in the collection.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the length
  of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var underestimatedCount: Int { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        ,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>
        </div></div>
</div>

<h3>Subscripts</h3>
<div class="declaration inherited" id="subscript-subscript_-unboundedrange">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-unboundedrange">subscript(_: (UnboundedRange_)</a>
<div class="comment collapse" id="comment-subscript-subscript_-unboundedrange"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(x: (UnboundedRange_) -&gt; ()) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="subscript-subscript_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-int">subscript(_: Int)</a>
<div class="comment collapse" id="comment-subscript-subscript_-int"><div class="p">
    <p>Accesses the element at the specified position.</p>

<p>The following example uses indexed subscripting to update an array&#39;s
second element. After assigning the new value (<code>&quot;Butler&quot;</code>) at a specific
position, that value is immediately available at that same position.</p>

<pre><code class="language-swift">var streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
streets[1] = &quot;Butler&quot;
print(streets[1])
// Prints &quot;Butler&quot;</code></pre>

<p><strong><code>index</code>:</strong>  The position of the element to access. <code>index</code> must be
  greater than or equal to <code>startIndex</code> and less than <code>endIndex</code>.</p>

<p><strong>Complexity:</strong> Reading an element from an array is O(1). Writing is O(1)
  unless the array&#39;s storage is shared with another array, in which case
  writing is O(<em>n</em>), where <em>n</em> is the length of the array.
  If the array uses a bridged <code>NSArray</code> instance as its storage, the
  efficiency is unspecified.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(index: Int) -&gt; Element</code>
    
    
</div></div>
</div>
<div class="declaration" id="subscript-subscript_-range-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-range-int">subscript(_: Range&lt;Int&gt;)</a>
<div class="comment collapse" id="comment-subscript-subscript_-range-int"><div class="p">
    <p>Accesses a contiguous subrange of the array&#39;s elements.</p>

<p>The returned <code>ArraySlice</code> instance uses the same indices for the same
elements as the original array. In particular, that slice, unlike an
array, may have a nonzero <code>startIndex</code> and an <code>endIndex</code> that is not
equal to <code>count</code>. Always use the slice&#39;s <code>startIndex</code> and <code>endIndex</code>
properties instead of assuming that its indices start or end at a
particular value.</p>

<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>

<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let i = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
print(streets[i!])
// Prints &quot;Evarts&quot;</code></pre>

<p><strong><code>bounds</code>:</strong>  A range of integers. The bounds of the range must be
  valid indices of the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(bounds: Range&lt;Int&gt;) -&gt; ArraySlice&lt;Element&gt;</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="subscript-subscript_-range-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript_-range-self-index">subscript(_: Range&lt;Array&lt;Element&gt;.Index&gt;)</a>
<div class="comment collapse" id="comment-subscript-subscript_-range-self-index"><div class="p">
    <p>Accesses a contiguous subrange of the collection&#39;s elements.</p>

<p>The accessed slice uses the same indices for the same elements as the
original collection. Always use the slice&#39;s <code>startIndex</code> property
instead of assuming that its indices start at a particular value.</p>

<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>

<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let index = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
streets[index!] = &quot;Eustace&quot;
print(streets[index!])
// Prints &quot;Eustace&quot;</code></pre>

<p><strong><code>bounds</code>:</strong>  A range of the collection&#39;s indices. The bounds of
  the range must be valid indices of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(bounds: Range&lt;Array&lt;Element&gt;.Index&gt;) -&gt; Slice&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="subscript-subscript-r_-r">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subscript-r_-r">subscript&lt;R&gt;(_: R)</a>
<div class="comment collapse" id="comment-subscript-subscript-r_-r"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">subscript&lt;R&gt;(r: R) -&gt; Array&lt;Element&gt;.SubSequence where R : RangeExpression, Array&lt;Element&gt;.Index == R.Bound</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>


<h3>Instance Methods</h3>
<div class="declaration inherited" id="func-allsatisfy_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-allsatisfy_">func allSatisfy(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-allsatisfy_"><div class="p">
    <p>Returns a Boolean value indicating whether every element of a sequence
satisfies a given predicate.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element satisfies a condition.
<strong>Returns:</strong> <code>true</code> if the sequence contains only elements that satisfy
  <code>predicate</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func allSatisfy(_ predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-append_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-append_">mutating func append(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-append_"><div class="p">
    <p>Adds a new element at the end of the array.</p>

<p>Use this method to append a single element to the end of a mutable array.</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(100)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 100]&quot;</code></pre>

<p>Because arrays increase their allocated capacity using an exponential
strategy, appending a single element to an array is an O(1) operation
when averaged over many calls to the <code>append(_:)</code> method. When an array
has additional capacity and is not sharing its storage with another
instance, appending an element is O(1). When an array needs to
reallocate storage before appending or its storage is shared with
another copy, appending is O(<em>n</em>), where <em>n</em> is the length of the array.</p>

<p><strong><code>newElement</code>:</strong>  The element to append to the array.</p>

<p><strong>Complexity:</strong> Amortized O(1) over many additions. If the array uses a
  bridged <code>NSArray</code> instance as its storage, the efficiency is
  unspecified.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func append(_ newElement: [Element].Element)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-append-contentsof_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-append-contentsof_">mutating func append(<wbr>contentsOf:)</a>
        
<div class="comment collapse" id="comment-func-append-contentsof_"><div class="p">
    <p>Adds the elements of a sequence to the end of the array.</p>

<p>Use this method to append the elements of a sequence to the end of this
array. This example appends the elements of a <code>Range&lt;Int&gt;</code> instance
to an array of integers.</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.append(contentsOf: 10...15)
print(numbers)
// Prints &quot;[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]&quot;</code></pre>

<p><strong><code>newElements</code>:</strong>  The elements to append to the array.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the resulting array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func append&lt;S&gt;(contentsOf newElements: S)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-compactmap_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-compactmap_">func compactMap(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-compactmap_"><div class="p">
    <p>Returns an array containing the non-<code>nil</code> results of calling the given
transformation with each element of this sequence.</p>

<p>Use this method to receive an array of nonoptional values when your
transformation produces an optional value.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>compactMap</code> with a transformation that returns an optional <code>Int</code> value.</p>

<pre><code class="language-swift">let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]

let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
// [1, 2, nil, nil, 5]

let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
// [1, 2, 5]</code></pre>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns an optional value.
<strong>Returns:</strong> An array of the non-<code>nil</code> results of calling <code>transform</code>
  with each element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func compactMap&lt;ElementOfResult&gt;(_ transform: (Array&lt;Element&gt;.Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-contains-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-contains-where_">func contains(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-contains-where_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence contains an
element that satisfies the given predicate.</p>

<p>You can use the predicate to check for an element of a type that
doesn&#39;t conform to the <code>Equatable</code> protocol, such as the
<code>HTTPResponse</code> enumeration in this example.</p>

<pre><code class="language-swift">enum HTTPResponse {
    case ok
    case error(Int)
}

let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
let hadError = lastThreeResponses.contains { element in
    if case .error = element {
        return true
    } else {
        return false
    }
}
// &#39;hadError&#39; == true</code></pre>

<p>Alternatively, a predicate can be satisfied by a range of <code>Equatable</code>
elements or a general condition. This example shows how you can check an
array for an expense greater than $100.</p>

<pre><code class="language-swift">let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
let hasBigPurchase = expenses.contains { $0 &gt; 100 }
// &#39;hasBigPurchase&#39; == true</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element represents a match.
<strong>Returns:</strong> <code>true</code> if the sequence contains an element that satisfies
  <code>predicate</code>; otherwise, <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func contains(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-from_-self-index-to_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-from_-self-index-to_-self-index">func distance(<wbr>from:<wbr> Array&lt;Element&gt;.Index, to: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-distance-from_-self-index-to_-self-index"><div class="p">
    <p>Returns the distance between two indices.</p>

<p>Unless the collection conforms to the <code>BidirectionalCollection</code> protocol,
<code>start</code> must be less than or equal to <code>end</code>.</p>

<p><strong>Parameters:</strong>
  <strong>start:</strong> A valid index of the collection.
  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to
    <code>start</code>, the result is zero.
<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>. The result can be
  negative only if the collection conforms to the
  <code>BidirectionalCollection</code> protocol.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the
  resulting distance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(from start: Array&lt;Element&gt;.Index, to end: Array&lt;Element&gt;.Index) -&gt; Int</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-distance-from_to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-from_to_">func distance(<wbr>from:<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-distance-from_to_"><div class="p">
    <p>Returns the distance between two indices.</p>

<p><strong>Parameters:</strong>
  <strong>start:</strong> A valid index of the collection.
  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to
    <code>start</code>, the result is zero.
<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(from start: Int, to end: Int) -&gt; Int</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-distance-t-from_-self-index-to_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-distance-t-from_-self-index-to_-self-index">func distance&lt;T&gt;(<wbr>from:<wbr> Array&lt;Element&gt;.Index, to: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-distance-t-from_-self-index-to_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance&lt;T&gt;(from start: Array&lt;Element&gt;.Index, to end: Array&lt;Element&gt;.Index) -&gt; T where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-drop-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-drop-while_">func drop(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-drop-while_"><div class="p">
    <p>Returns a subsequence by skipping elements while <code>predicate</code> returns
<code>true</code> and returning the remaining elements.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns <code>true</code> if the element should
  be skipped or <code>false</code> if it should be included. Once the predicate
  returns <code>false</code> it will not be called again.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func drop(while predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-dropfirst">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dropfirst">func dropFirst()</a>
        
<div class="comment collapse" id="comment-func-dropfirst"><div class="p">
    <p>Returns a subsequence containing all but the first element of the
sequence.</p>

<p>The following example drops the first element from an array of integers.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst())
// Prints &quot;[2, 3, 4, 5]&quot;</code></pre>

<p>If the sequence has no elements, the result is an empty subsequence.</p>

<pre><code class="language-swift">let empty: [Int] = []
print(empty.dropFirst())
// Prints &quot;[]&quot;</code></pre>

<p><strong>Returns:</strong> A subsequence starting after the first element of the
  sequence.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst() -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-dropfirst_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-dropfirst_">func dropFirst(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-dropfirst_"><div class="p">
    <p>Returns a subsequence containing all but the given number of initial
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in
the collection, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst(2))
// Prints &quot;[3, 4, 5]&quot;
print(numbers.dropFirst(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop from the beginning of
  the collection. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting after the specified number of
  elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the number of elements to drop from
  the beginning of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst(_ n: Int) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-droplast">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-droplast">func dropLast()</a>
        
<div class="comment collapse" id="comment-func-droplast"><div class="p">
    <p>Returns a subsequence containing all but the last element of the
sequence.</p>

<p>The sequence must be finite.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast())
// Prints &quot;[1, 2, 3, 4]&quot;</code></pre>

<p>If the sequence has no elements, the result is an empty subsequence.</p>

<pre><code class="language-swift">let empty: [Int] = []
print(empty.dropLast())
// Prints &quot;[]&quot;</code></pre>

<p><strong>Returns:</strong> A subsequence leaving off the last element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast() -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-droplast_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-droplast_">func dropLast(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-droplast_"><div class="p">
    <p>Returns a subsequence containing all but the specified number of final
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in the
collection, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast(2))
// Prints &quot;[1, 2, 3]&quot;
print(numbers.dropLast(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop off the end of the
  collection. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence that leaves off <code>n</code> elements from the end.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the number of elements to drop.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast(_ n: Int) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-elementsequal_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-elementsequal_by_">func elementsEqual(<wbr>_:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-elementsequal_by_"><div class="p">
    <p>Returns a Boolean value indicating whether this sequence and another
sequence contain equivalent elements in the same order, using the given
predicate as the equivalence test.</p>

<p>At least one of the sequences must be finite.</p>

<p>The predicate must be a <em>equivalence relation</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)</li><li><code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)</li><li>If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then
<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)</li></ul>

<p><strong>Parameters:</strong>
  <strong>other:</strong> A sequence to compare to this sequence.
  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments
    are equivalent; otherwise, <code>false</code>.
<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain equivalent items,
  using <code>areEquivalent</code> as the equivalence test; otherwise, <code>false.</code></p>

    <h4>Declaration</h4>    
    <code class="language-swift">func elementsEqual&lt;OtherSequence&gt;(_ other: OtherSequence, by areEquivalent: (Array&lt;Element&gt;.Element, OtherSequence.Element) throws -&gt; Bool) rethrows -&gt; Bool where OtherSequence : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-encode-to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-encode-to_">func encode(<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-encode-to_"><div class="p">
    <p>Encodes the elements of this array into the given encoder in an unkeyed
container.</p>

<p>This function throws an error if any values are invalid for the given
encoder&#39;s format.</p>

<p><strong><code>encoder</code>:</strong>  The encoder to write data to.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func encode(to encoder: Encoder) throws</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-enumerated">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-enumerated">func enumerated()</a>
        
<div class="comment collapse" id="comment-func-enumerated"><div class="p">
    <p>Returns a sequence of pairs (<em>n</em>, <em>x</em>), where <em>n</em> represents a
consecutive integer starting at zero and <em>x</em> represents an element of
the sequence.</p>

<p>This example enumerates the characters of the string &quot;Swift&quot; and prints
each character along with its place in the string.</p>

<pre><code class="language-swift">for (n, c) in &quot;Swift&quot;.enumerated() {
    print(&quot;\(n): &#39;\(c)&#39;&quot;)
}
// Prints &quot;0: &#39;S&#39;&quot;
// Prints &quot;1: &#39;w&#39;&quot;
// Prints &quot;2: &#39;i&#39;&quot;
// Prints &quot;3: &#39;f&#39;&quot;
// Prints &quot;4: &#39;t&#39;&quot;</code></pre>

<p>When you enumerate a collection, the integer part of each pair is a counter
for the enumeration, but is not necessarily the index of the paired value.
These counters can be used as indices only in instances of zero-based,
integer-indexed collections, such as <code>Array</code> and <code>ContiguousArray</code>. For
other collections the counters may be out of range or of the wrong type
to use as an index. To iterate over the elements of a collection with its
indices, use the <code>zip(_:_:)</code> function.</p>

<p>This example iterates over the indices and elements of a set, building a
list consisting of indices of names with five or fewer letters.</p>

<pre><code class="language-swift">let names: Set = [&quot;Sofia&quot;, &quot;Camilla&quot;, &quot;Martina&quot;, &quot;Mateo&quot;, &quot;Nicols&quot;]
var shorterIndices: [SetIndex&lt;String&gt;] = []
for (i, name) in zip(names.indices, names) {
    if name.count &lt;= 5 {
        shorterIndices.append(i)
    }
}</code></pre>

<p>Now that the <code>shorterIndices</code> array holds the indices of the shorter
names in the <code>names</code> set, you can use those indices to access elements in
the set.</p>

<pre><code class="language-swift">for i in shorterIndices {
    print(names[i])
}
// Prints &quot;Sofia&quot;
// Prints &quot;Mateo&quot;</code></pre>

<p><strong>Returns:</strong> A sequence of pairs enumerating the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func enumerated() -&gt; EnumeratedSequence&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-filter_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-filter_">func filter(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-filter_"><div class="p">
    <p>Returns a new collection of the same type containing, in order, the
elements of the original collection that satisfy the given predicate.</p>

<p>In this example, <code>filter(_:)</code> is used to include only names shorter than
five characters.</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let shortNames = cast.filter { $0.count &lt; 5 }
print(shortNames)
// Prints &quot;[&quot;Kim&quot;, &quot;Karl&quot;]&quot;</code></pre>

<p><strong><code>isIncluded</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns a Boolean value indicating
  whether the element should be included in the returned array.
<strong>Returns:</strong> An array of the elements that <code>isIncluded</code> allowed.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func filter(_ isIncluded: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-first-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-first-where_">func first(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-first-where_"><div class="p">
    <p>Returns the first element of the sequence that satisfies the given
predicate.</p>

<p>The following example uses the <code>first(where:)</code> method to find the first
negative number in an array of integers:</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
if let firstNegative = numbers.first(where: { $0 &lt; 0 }) {
    print(&quot;The first negative number is \(firstNegative).&quot;)
}
// Prints &quot;The first negative number is -2.&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element is a match.
<strong>Returns:</strong> The first element of the sequence that satisfies <code>predicate</code>,
  or <code>nil</code> if there is no element that satisfies <code>predicate</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func first(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-firstindex-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-firstindex-where_">func firstIndex(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-firstindex-where_"><div class="p">
    <p>Returns the first index in which an element of the collection satisfies
the given predicate.</p>

<p>You can use the predicate to find an element of a type that doesn&#39;t
conform to the <code>Equatable</code> protocol or to find an element that matches
particular criteria. Here&#39;s an example that finds a student name that
begins with the letter &quot;A&quot;:</p>

<pre><code class="language-swift">let students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
if let i = students.firstIndex(where: { $0.hasPrefix(&quot;A&quot;) }) {
    print(&quot;\(students[i]) starts with &#39;A&#39;!&quot;)
}
// Prints &quot;Abena starts with &#39;A&#39;!&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element as its argument
  and returns a Boolean value that indicates whether the passed element
  represents a match.
<strong>Returns:</strong> The index of the first element for which <code>predicate</code> returns
  <code>true</code>. If no elements in the collection satisfy the given predicate,
  returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func firstIndex(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap_">func flatMap(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-flatmap_"><div class="p">
    

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap(_ transform: (Array&lt;Element&gt;.Element) throws -&gt; String?) rethrows -&gt; [String]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap-elementofresult_-self-element-throws-elementofresult">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap-elementofresult_-self-element-throws-elementofresult">func flatMap&lt;ElementOfResult&gt;(<wbr>_: (Array&lt;Element&gt;.Element) throws -&gt; ElementOfResult?)</a>
        
<div class="comment collapse" id="comment-func-flatmap-elementofresult_-self-element-throws-elementofresult"><div class="p">
    <p>Returns an array containing the non-<code>nil</code> results of calling the given
transformation with each element of this sequence.</p>

<p>Use this method to receive an array of nonoptional values when your
transformation produces an optional value.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>flatMap</code> with a transformation that returns an optional <code>Int</code> value.</p>

<pre><code class="language-swift">let possibleNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;///4///&quot;, &quot;5&quot;]

let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
// [1, 2, nil, nil, 5]

let flatMapped: [Int] = possibleNumbers.flatMap { str in Int(str) }
// [1, 2, 5]</code></pre>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns an optional value.
<strong>Returns:</strong> An array of the non-<code>nil</code> results of calling <code>transform</code>
  with each element of the sequence.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap&lt;ElementOfResult&gt;(_ transform: (Array&lt;Element&gt;.Element) throws -&gt; ElementOfResult?) rethrows -&gt; [ElementOfResult]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-flatmap-segmentofresult_-self-element-throws-segmentofresult">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-flatmap-segmentofresult_-self-element-throws-segmentofresult">func flatMap&lt;SegmentOfResult&gt;(<wbr>_: (Array&lt;Element&gt;.Element) throws -&gt; SegmentOfResult)</a>
        
<div class="comment collapse" id="comment-func-flatmap-segmentofresult_-self-element-throws-segmentofresult"><div class="p">
    <p>Returns an array containing the concatenated results of calling the
given transformation with each element of this sequence.</p>

<p>Use this method to receive a single-level collection when your
transformation produces a sequence or collection for each element.</p>

<p>In this example, note the difference in the result of using <code>map</code> and
<code>flatMap</code> with a transformation that returns an array.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4]

let mapped = numbers.map { Array(repeating: $0, count: $0) }
// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]

let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</code></pre>

<p>In fact, <code>s.flatMap(transform)</code>  is equivalent to
<code>Array(s.map(transform).joined())</code>.</p>

<p><strong><code>transform</code>:</strong>  A closure that accepts an element of this
  sequence as its argument and returns a sequence or collection.
<strong>Returns:</strong> The resulting flattened array.</p>

<p><strong>Complexity:</strong> O(<em>m</em> + <em>n</em>), where <em>m</em> is the length of this sequence
  and <em>n</em> is the length of the result.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func flatMap&lt;SegmentOfResult&gt;(_ transform: (Array&lt;Element&gt;.Element) throws -&gt; SegmentOfResult) rethrows -&gt; [SegmentOfResult.Element] where SegmentOfResult : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-foreach_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-foreach_">func forEach(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-foreach_"><div class="p">
    <p>Calls the given closure on each element in the sequence in the same order
as a <code>for</code>-<code>in</code> loop.</p>

<p>The two loops in the following example produce the same output:</p>

<pre><code class="language-swift">let numberWords = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
for word in numberWords {
    print(word)
}
// Prints &quot;one&quot;
// Prints &quot;two&quot;
// Prints &quot;three&quot;

numberWords.forEach { word in
    print(word)
}
// Same as above</code></pre>

<p>Using the <code>forEach</code> method is distinct from a <code>for</code>-<code>in</code> loop in two
important ways:</p>

<ol><li>You cannot use a <code>break</code> or <code>continue</code> statement to exit the current
call of the <code>body</code> closure or skip subsequent calls.</li><li>Using the <code>return</code> statement in the <code>body</code> closure will exit only from
the current call to <code>body</code>, not from any outer scope, and won&#39;t skip
subsequent calls.</li></ol>

<p><strong><code>body</code>:</strong>  A closure that takes an element of the sequence as a
  parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func forEach(_ body: (Array&lt;Element&gt;.Element) throws -&gt; Void) rethrows</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex_-inout-self-index-offsetby_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex_-inout-self-index-offsetby_-int">func formIndex(<wbr>_:<wbr> inout Array&lt;Element&gt;.Index, offsetBy: Int)</a>
        
<div class="comment collapse" id="comment-func-formindex_-inout-self-index-offsetby_-int"><div class="p">
    <p>Offsets the given index by the specified distance.</p>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(_ i: inout Array&lt;Element&gt;.Index, offsetBy n: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex-t_-inout-self-index-offsetby_-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-t_-inout-self-index-offsetby_-t">func formIndex&lt;T&gt;(<wbr>_:<wbr> inout Array&lt;Element&gt;.Index, offsetBy: T)</a>
        
<div class="comment collapse" id="comment-func-formindex-t_-inout-self-index-offsetby_-t"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex&lt;T&gt;(_ i: inout Array&lt;Element&gt;.Index, offsetBy n: T)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index">func formIndex(<wbr>_:<wbr> inout Array&lt;Element&gt;.Index, offsetBy:<wbr> Int, limitedBy: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-formindex_-inout-self-index-offsetby_-int-limitedby_-self-index"><div class="p">
    <p>Offsets the given index by the specified distance, or so that it equals
the given limiting index.</p>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,
    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a
    limit that is greater than <code>i</code> has no effect.
<strong>Returns:</strong> <code>true</code> if <code>i</code> has been offset by exactly <code>n</code> steps without
  going beyond <code>limit</code>; otherwise, <code>false</code>. When the return value is
  <code>false</code>, the value of <code>i</code> is equal to <code>limit</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(_ i: inout Array&lt;Element&gt;.Index, offsetBy n: Int, limitedBy limit: Array&lt;Element&gt;.Index) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index">func formIndex&lt;T&gt;(<wbr>_:<wbr> inout Array&lt;Element&gt;.Index, offsetBy:<wbr> T, limitedBy: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-formindex-t_-inout-self-index-offsetby_-t-limitedby_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex&lt;T&gt;(_ i: inout Array&lt;Element&gt;.Index, offsetBy n: T, limitedBy limit: Array&lt;Element&gt;.Index) -&gt; Bool where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-formindex-after_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-after_">func formIndex(<wbr>after:)</a>
        
<div class="comment collapse" id="comment-func-formindex-after_"><div class="p">
    <p>Replaces the given index with its successor.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than
  <code>endIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(after i: inout Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-formindex-before_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-formindex-before_">func formIndex(<wbr>before:)</a>
        
<div class="comment collapse" id="comment-func-formindex-before_"><div class="p">
    <p>Replaces the given index with its predecessor.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than
  <code>startIndex</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func formIndex(before i: inout Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-hash-into_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-hash-into_">func hash(<wbr>into:)</a>
        
<div class="comment collapse" id="comment-func-hash-into_"><div class="p">
    <p>Hashes the essential components of this value by feeding them into the
given hasher.</p>

<p>Implement this method to conform to the <code>Hashable</code> protocol. The
components used for hashing must be the same as the components compared
in your type&#39;s <code>==</code> operator implementation. Call <code>hasher.combine(_:)</code>
with each of these components.</p>

<p><strong>Important:</strong> Never call <code>finalize()</code> on <code>hasher</code>. Doing so may become a
  compile-time error in the future.</p>

<p><strong><code>hasher</code>:</strong>  The hasher to use when combining the components
  of this instance.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func hash(into hasher: inout Hasher)</code>
    
    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-self-index-offsetby_-int">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-self-index-offsetby_-int">func index(<wbr>_:<wbr> Array&lt;Element&gt;.Index, offsetBy: Int)</a>
        
<div class="comment collapse" id="comment-func-index_-self-index-offsetby_-int"><div class="p">
    <p>Returns an index that is the specified distance from the given index.</p>

<p>The following example obtains an index advanced four positions from a
string&#39;s starting index and then prints the character at that position.</p>

<pre><code class="language-swift">let s = &quot;Swift&quot;
let i = s.index(s.startIndex, offsetBy: 4)
print(s[i])
// Prints &quot;t&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,
  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.
  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls
  to <code>index(before:)</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Array&lt;Element&gt;.Index, offsetBy n: Int) -&gt; Array&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-index_offsetby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_offsetby_">func index(<wbr>_:<wbr>offsetBy:)</a>
        
<div class="comment collapse" id="comment-func-index_offsetby_"><div class="p">
    <p>Returns an index that is the specified distance from the given index.</p>

<p>The following example obtains an index advanced four positions from an
array&#39;s starting index and then prints the element at that position.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
let i = numbers.index(numbers.startIndex, offsetBy: 4)
print(numbers[i])
// Prints &quot;50&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the array.
  <strong>n:</strong> The distance to offset <code>i</code>.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,
  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.
  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls
  to <code>index(before:)</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Int, offsetBy n: Int) -&gt; Int</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index-t_-self-index-offsetby_-t">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-t_-self-index-offsetby_-t">func index&lt;T&gt;(<wbr>_:<wbr> Array&lt;Element&gt;.Index, offsetBy: T)</a>
        
<div class="comment collapse" id="comment-func-index-t_-self-index-offsetby_-t"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index&lt;T&gt;(_ i: Array&lt;Element&gt;.Index, offsetBy n: T) -&gt; Array&lt;Element&gt;.Index where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-self-index-offsetby_-int-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-self-index-offsetby_-int-limitedby_-self-index">func index(<wbr>_:<wbr> Array&lt;Element&gt;.Index, offsetBy:<wbr> Int, limitedBy: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-index_-self-index-offsetby_-int-limitedby_-self-index"><div class="p">
    <p>Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.</p>

<p>The following example obtains an index advanced four positions from a
string&#39;s starting index and then prints the character at that position.
The operation doesn&#39;t require going beyond the limiting <code>s.endIndex</code>
value, so it succeeds.</p>

<pre><code class="language-swift">let s = &quot;Swift&quot;
if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    print(s[i])
}
// Prints &quot;t&quot;</code></pre>

<p>The next example attempts to retrieve an index six positions from
<code>s.startIndex</code> but fails, because that distance is beyond the index
passed as <code>limit</code>.</p>

<pre><code class="language-swift">let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
print(j)
// Prints &quot;nil&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>. <code>n</code> must not be negative unless the
    collection conforms to the <code>BidirectionalCollection</code> protocol.
  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,
    a limit that is less than <code>i</code> has no effect. Likewise, if <code>n &lt; 0</code>, a
    limit that is greater than <code>i</code> has no effect.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index
  would be beyond <code>limit</code> in the direction of movement. In that case,
  the method returns <code>nil</code>.</p>

<p><strong>Complexity:</strong> O(1) if the collection conforms to
  <code>RandomAccessCollection</code>; otherwise, O(<em>n</em>), where <em>n</em> is the absolute
  value of <code>n</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Array&lt;Element&gt;.Index, offsetBy n: Int, limitedBy limit: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-index_offsetby_limitedby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_offsetby_limitedby_">func index(<wbr>_:<wbr>offsetBy:<wbr>limitedBy:)</a>
        
<div class="comment collapse" id="comment-func-index_offsetby_limitedby_"><div class="p">
    <p>Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.</p>

<p>The following example obtains an index advanced four positions from an
array&#39;s starting index and then prints the element at that position. The
operation doesn&#39;t require going beyond the limiting <code>numbers.endIndex</code>
value, so it succeeds.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
if let i = numbers.index(numbers.startIndex,
                         offsetBy: 4,
                         limitedBy: numbers.endIndex) {
    print(numbers[i])
}
// Prints &quot;50&quot;</code></pre>

<p>The next example attempts to retrieve an index ten positions from
<code>numbers.startIndex</code>, but fails, because that distance is beyond the
index passed as <code>limit</code>.</p>

<pre><code class="language-swift">let j = numbers.index(numbers.startIndex,
                      offsetBy: 10,
                      limitedBy: numbers.endIndex)
print(j)
// Prints &quot;nil&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection, unless the index passed as <code>limit</code> prevents offsetting
beyond those bounds.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the array.
  <strong>n:</strong> The distance to offset <code>i</code>.
  <strong>limit:</strong> A valid index of the collection to use as a limit. If <code>n &gt; 0</code>,
    <code>limit</code> has no effect if it is less than <code>i</code>. Likewise, if <code>n &lt; 0</code>,
    <code>limit</code> has no effect if it is greater than <code>i</code>.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>, unless that index
  would be beyond <code>limit</code> in the direction of movement. In that case,
  the method returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -&gt; Int?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>,    <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index-t_-self-index-offsetby_-t-limitedby_-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-t_-self-index-offsetby_-t-limitedby_-self-index">func index&lt;T&gt;(<wbr>_:<wbr> Array&lt;Element&gt;.Index, offsetBy:<wbr> T, limitedBy: Array&lt;Element&gt;.Index)</a>
        
<div class="comment collapse" id="comment-func-index-t_-self-index-offsetby_-t-limitedby_-self-index"><div class="p">
    <p><em>Deprecated:</em> all index distances are now of type Int.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index&lt;T&gt;(_ i: Array&lt;Element&gt;.Index, offsetBy n: T, limitedBy limit: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.Index? where T : BinaryInteger</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-index-after_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-after_">func index(<wbr>after:)</a>
        
<div class="comment collapse" id="comment-func-index-after_"><div class="p">
    <p>Returns the position immediately after the given index.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than
  <code>endIndex</code>.
<strong>Returns:</strong> The index immediately after <code>i</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(after i: Int) -&gt; Int</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-index-before_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index-before_">func index(<wbr>before:)</a>
        
<div class="comment collapse" id="comment-func-index-before_"><div class="p">
    <p>Returns the position immediately before the given index.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than
  <code>startIndex</code>.
<strong>Returns:</strong> The index immediately before <code>i</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(before i: Int) -&gt; Int</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-insert_at_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-insert_at_">mutating func insert(<wbr>_:<wbr>at:)</a>
        
<div class="comment collapse" id="comment-func-insert_at_"><div class="p">
    <p>Inserts a new element at the specified position.</p>

<p>The new element is inserted before the element currently at the specified
index. If you pass the array&#39;s <code>endIndex</code> property as the <code>index</code>
parameter, the new element is appended to the array.</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.insert(100, at: 3)
numbers.insert(200, at: numbers.endIndex)

print(numbers)
// Prints &quot;[1, 2, 3, 100, 4, 5, 200]&quot;</code></pre>

<p><strong><code>newElement</code>:</strong>  The new element to insert into the array.</p>

<p><strong><code>i</code>:</strong>  The position at which to insert the new element.
  <code>index</code> must be a valid index of the array or equal to its <code>endIndex</code>
  property.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func insert(_ newElement: [Element].Element, at i: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-insert-contentsof_at_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-insert-contentsof_at_">mutating func insert(<wbr>contentsOf:<wbr>at:)</a>
        
<div class="comment collapse" id="comment-func-insert-contentsof_at_"><div class="p">
    <p>Inserts the elements of a sequence into the collection at the specified
position.</p>

<p>The new elements are inserted before the element currently at the
specified index. If you pass the collection&#39;s <code>endIndex</code> property as the
<code>index</code> parameter, the new elements are appended to the collection.</p>

<p>Here&#39;s an example of inserting a range of integers into an array of the
same type:</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.insert(contentsOf: 100...103, at: 3)
print(numbers)
// Prints &quot;[1, 2, 3, 100, 101, 102, 103, 4, 5]&quot;</code></pre>

<p>Calling this method may invalidate any existing indices for use with this
collection.</p>

<p><strong><code>newElements</code>:</strong>  The new elements to insert into the collection.</p>

<p><strong><code>i</code>:</strong>  The position at which to insert the new elements. <code>index</code>
  must be a valid index of the collection.</p>

<p><strong>Complexity:</strong> O(<em>m</em>), where <em>m</em> is the combined length of the collection
  and <code>newElements</code>. If <code>i</code> is equal to the collection&#39;s <code>endIndex</code>
  property, the complexity is O(<em>n</em>), where <em>n</em> is the length of
  <code>newElements</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func insert&lt;C&gt;(contentsOf newElements: C, at i: Array&lt;Element&gt;.Index)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-last-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-last-where_">func last(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-last-where_"><div class="p">
    <p>Returns the last element of the sequence that satisfies the given
predicate.</p>

<p>This example uses the <code>last(where:)</code> method to find the last
negative number in an array of integers:</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
if let lastNegative = numbers.last(where: { $0 &lt; 0 }) {
    print(&quot;The last negative number is \(firstNegative).&quot;)
}
// Prints &quot;The last negative number is -6.&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element is a match.
<strong>Returns:</strong> The last element of the sequence that satisfies <code>predicate</code>,
  or <code>nil</code> if there is no element that satisfies <code>predicate</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func last(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lastindex-where_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lastindex-where_">func lastIndex(<wbr>where:)</a>
        
<div class="comment collapse" id="comment-func-lastindex-where_"><div class="p">
    <p>Returns the index of the last element in the collection that matches the
given predicate.</p>

<p>You can use the predicate to find an element of a type that doesn&#39;t
conform to the <code>Equatable</code> protocol or to find an element that matches
particular criteria. This example finds the index of the last name that
begins with the letter &quot;A&quot;:</p>

<pre><code class="language-swift">let students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
if let i = students.lastIndex(where: { $0.hasPrefix(&quot;A&quot;) }) {
    print(&quot;\(students[i]) starts with &#39;A&#39;!&quot;)
}
// Prints &quot;Akosua starts with &#39;A&#39;!&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element as its argument
  and returns a Boolean value that indicates whether the passed element
  represents a match.
<strong>Returns:</strong> The index of the last element in the collection that matches
  <code>predicate</code>, or <code>nil</code> if no elements match.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lastIndex(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-lexicographicallyprecedes_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-lexicographicallyprecedes_by_">func lexicographicallyPrecedes(<wbr>_:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-lexicographicallyprecedes_by_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the given
predicate to compare elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p><strong>Parameters:</strong>
  <strong>other:</strong> A sequence to compare to this sequence.
  <strong>areInIncreasingOrder:</strong>  A predicate that returns <code>true</code> if its first
    argument should be ordered before its second argument; otherwise,
    <code>false</code>.
<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary
  ordering as ordered by <code>areInIncreasingOrder</code>; otherwise, <code>false</code>.</p>

<p><strong>Note:</strong> This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use <code>String</code> APIs that perform
  localized comparison instead.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lexicographicallyPrecedes&lt;OtherSequence&gt;(_ other: OtherSequence, by areInIncreasingOrder: (Array&lt;Element&gt;.Element, Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Bool where OtherSequence : Sequence, Array&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-map_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-map_">func map(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-map_"><div class="p">
    <p>Returns an array containing the results of mapping the given closure
over the sequence&#39;s elements.</p>

<p>In this example, <code>map</code> is used first to convert the names in the array
to lowercase strings and then to count their characters.</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let lowercaseNames = cast.map { $0.lowercased() }
// &#39;lowercaseNames&#39; == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]
let letterCounts = cast.map { $0.count }
// &#39;letterCounts&#39; == [6, 6, 3, 4]</code></pre>

<p><strong><code>transform</code>:</strong>  A mapping closure. <code>transform</code> accepts an
  element of this sequence as its parameter and returns a transformed
  value of the same or of a different type.
<strong>Returns:</strong> An array containing the transformed elements of this
  sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func map&lt;T&gt;(_ transform: (Array&lt;Element&gt;.Element) throws -&gt; T) rethrows -&gt; [T]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-max-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-max-by_">@warn_unqualified_access
     func max(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-max-by_"><div class="p">
    <p>Returns the maximum element in the sequence, using the given predicate
as the comparison between elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>This example shows how to use the <code>max(by:)</code> method on a
dictionary to find the key-value pair with the highest value.</p>

<pre><code class="language-swift">let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]
let greatestHue = hues.max { a, b in a.value &lt; b.value }
print(greatestHue)
// Prints &quot;Optional((&quot;Heliotrope&quot;, 296))&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>   A predicate that returns <code>true</code> if its
  first argument should be ordered before its second argument;
  otherwise, <code>false</code>.
<strong>Returns:</strong> The sequence&#39;s maximum element if the sequence is not empty;
  otherwise, <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func max(by areInIncreasingOrder: (Array&lt;Element&gt;.Element, Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-min-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-min-by_">func min(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-min-by_"><div class="p">
    <p>Returns the minimum element in the sequence, using the given predicate as
the comparison between elements.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also
<code>true</code>. (Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>This example shows how to use the <code>min(by:)</code> method on a
dictionary to find the key-value pair with the lowest value.</p>

<pre><code class="language-swift">let hues = [&quot;Heliotrope&quot;: 296, &quot;Coral&quot;: 16, &quot;Aquamarine&quot;: 156]
let leastHue = hues.min { a, b in a.value &lt; b.value }
print(leastHue)
// Prints &quot;Optional((&quot;Coral&quot;, 16))&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code>
  if its first argument should be ordered before its second
  argument; otherwise, <code>false</code>.
<strong>Returns:</strong> The sequence&#39;s minimum element, according to
  <code>areInIncreasingOrder</code>. If the sequence has no elements, returns
  <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func min(by areInIncreasingOrder: (Array&lt;Element&gt;.Element, Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-partition-by_-self-element-throws-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-partition-by_-self-element-throws-bool">mutating func partition(<wbr>by: (Array&lt;Element&gt;.Element) throws -&gt; Bool)</a>
        
<div class="comment collapse" id="comment-func-partition-by_-self-element-throws-bool"><div class="p">
    <p>Reorders the elements of the collection such that all the elements
that match the given predicate are after all the elements that don&#39;t
match.</p>

<p>After partitioning a collection, there is a pivot index <code>p</code> where
no element before <code>p</code> satisfies the <code>belongsInSecondPartition</code>
predicate and every element at or after <code>p</code> satisfies
<code>belongsInSecondPartition</code>.</p>

<p>In the following example, an array of numbers is partitioned by a
predicate that matches elements greater than 30.</p>

<pre><code class="language-swift">var numbers = [30, 40, 20, 30, 30, 60, 10]
let p = numbers.partition(by: { $0 &gt; 30 })
// p == 5
// numbers == [30, 10, 20, 30, 30, 60, 40]</code></pre>

<p>The <code>numbers</code> array is now arranged in two partitions. The first
partition, <code>numbers[..&lt;p]</code>, is made up of the elements that
are not greater than 30. The second partition, <code>numbers[p...]</code>,
is made up of the elements that <em>are</em> greater than 30.</p>

<pre><code class="language-swift">let first = numbers[..&lt;p]
// first == [30, 10, 20, 30, 30]
let second = numbers[p...]
// second == [60, 40]</code></pre>

<p><strong><code>belongsInSecondPartition</code>:</strong>  A predicate used to partition
  the collection. All elements satisfying this predicate are ordered
  after all elements not satisfying it.
<strong>Returns:</strong> The index of the first element in the reordered collection
  that matches <code>belongsInSecondPartition</code>. If no elements in the
  collection match <code>belongsInSecondPartition</code>, the returned index is
  equal to the collection&#39;s <code>endIndex</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func partition(by belongsInSecondPartition: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-poplast">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-poplast">mutating func popLast()</a>
        
<div class="comment collapse" id="comment-func-poplast"><div class="p">
    <p>Removes and returns the last element of the collection.</p>

<p>Calling this method may invalidate all saved indices of this
collection. Do not rely on a previously stored index value after
altering a collection with any operation that can change its length.</p>

<p><strong>Returns:</strong> The last element of the collection if the collection is not
empty; otherwise, <code>nil</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func popLast() -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix_">func prefix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-prefix_"><div class="p">
    <p>Returns a subsequence, up to the specified maximum length, containing
the initial elements of the collection.</p>

<p>If the maximum length exceeds the number of elements in the collection,
the result contains all the elements in the collection.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.prefix(2))
// Prints &quot;[1, 2]&quot;
print(numbers.prefix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return.
  <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting at the beginning of this collection
  with at most <code>maxLength</code> elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(_ maxLength: Int) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-through_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-through_">func prefix(<wbr>through:)</a>
        
<div class="comment collapse" id="comment-func-prefix-through_"><div class="p">
    <p>Returns a subsequence from the start of the collection through the
specified position.</p>

<p>The resulting subsequence <em>includes</em> the element at the position <code>end</code>. 
The following example searches for the index of the number <code>40</code> in an
array of integers, and then prints the prefix of the array up to, and
including, that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.prefix(through: i))
}
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p>Using the <code>prefix(through:)</code> method is equivalent to using a partial
closed range as the collection&#39;s subscript. The subscript notation is
preferred over <code>prefix(through:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[...i])
}
// Prints &quot;[10, 20, 30, 40]&quot;</code></pre>

<p><strong><code>end</code>:</strong>  The index of the last element to include in the
  resulting subsequence. <code>end</code> must be a valid index of the collection
  that is not equal to the <code>endIndex</code> property.
<strong>Returns:</strong> A subsequence up to, and including, the <code>end</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(through position: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-upto_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-upto_">func prefix(<wbr>upTo:)</a>
        
<div class="comment collapse" id="comment-func-prefix-upto_"><div class="p">
    <p>Returns a subsequence from the start of the collection up to, but not
including, the specified position.</p>

<p>The resulting subsequence <em>does not include</em> the element at the position
<code>end</code>. The following example searches for the index of the number <code>40</code>
in an array of integers, and then prints the prefix of the array up to,
but not including, that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.prefix(upTo: i))
}
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p>Passing the collection&#39;s starting index as the <code>end</code> parameter results in
an empty subsequence.</p>

<pre><code class="language-swift">print(numbers.prefix(upTo: numbers.startIndex))
// Prints &quot;[]&quot;</code></pre>

<p>Using the <code>prefix(upTo:)</code> method is equivalent to using a partial
half-open range as the collection&#39;s subscript. The subscript notation is
preferred over <code>prefix(upTo:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[..&lt;i])
}
// Prints &quot;[10, 20, 30]&quot;</code></pre>

<p><strong><code>end</code>:</strong>  The &quot;past the end&quot; index of the resulting subsequence.
  <code>end</code> must be a valid index of the collection.
<strong>Returns:</strong> A subsequence up to, but not including, the <code>end</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(upTo end: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-prefix-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-prefix-while_">func prefix(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-prefix-while_"><div class="p">
    <p>Returns a subsequence containing the initial elements until <code>predicate</code>
returns <code>false</code> and skipping the remaining elements.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns <code>true</code> if the element should
  be included or <code>false</code> if it should be excluded. Once the predicate
  returns <code>false</code> it will not be called again.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(while predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-randomelement">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-randomelement">func randomElement()</a>
        
<div class="comment collapse" id="comment-func-randomelement"><div class="p">
    <p>Returns a random element of the collection.</p>

<p>Call <code>randomElement()</code> to select a random element from an array or
another collection. This example picks a name at random from an array:</p>

<pre><code class="language-swift">let names = [&quot;Zoey&quot;, &quot;Chloe&quot;, &quot;Amani&quot;, &quot;Amaia&quot;]
let randomName = names.randomElement()!
// randomName == &quot;Amani&quot;</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>names.randomElement()</code> above is equivalent to calling
<code>names.randomElement(using: &amp;Random.default)</code>.</p>

<p><strong>Returns:</strong> A random element from the collection. If the collection is
  empty, the method returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func randomElement() -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-randomelement-using_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-randomelement-using_">func randomElement(<wbr>using:)</a>
        
<div class="comment collapse" id="comment-func-randomelement-using_"><div class="p">
    <p>Returns a random element of the collection, using the given generator as
a source for randomness.</p>

<p>Call <code>randomElement(using:)</code> to select a random element from an array or
another collection when you are using a custom random number generator.
This example picks a name at random from an array:</p>

<pre><code class="language-swift">let names = [&quot;Zoey&quot;, &quot;Chloe&quot;, &quot;Amani&quot;, &quot;Amaia&quot;]
let randomName = names.randomElement(using: &amp;myGenerator)!
// randomName == &quot;Amani&quot;</code></pre>

<p><strong><code>generator</code>:</strong>  The random number generator to use when choosing
  a random element.
<strong>Returns:</strong> A random element from the collection. If the collection is
  empty, the method returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func randomElement&lt;T&gt;(using generator: inout T) -&gt; Array&lt;Element&gt;.Element? where T : RandomNumberGenerator</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reduce__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reduce__">func reduce(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reduce__"><div class="p">
    <p>Returns the result of combining the elements of the sequence using the
given closure.</p>

<p>Use the <code>reduce(_:_:)</code> method to produce a single value from the elements
of an entire sequence. For example, you can use this method on an array
of numbers to find their sum or product.</p>

<p>The <code>nextPartialResult</code> closure is called sequentially with an
accumulating value initialized to <code>initialResult</code> and each element of
the sequence. This example shows how to find the sum of an array of
numbers.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4]
let numberSum = numbers.reduce(0, { x, y in
    x + y
})
// numberSum == 10</code></pre>

<p>When <code>numbers.reduce(_:_:)</code> is called, the following steps occur:</p>

<ol><li>The <code>nextPartialResult</code> closure is called with <code>initialResult</code>---<code>0</code>
in this case---and the first element of <code>numbers</code>, returning the sum:
<code>1</code>.</li><li>The closure is called again repeatedly with the previous call&#39;s return
value and each element of the sequence.</li><li>When the sequence is exhausted, the last value returned from the
closure is returned to the caller.</li></ol>

<p>If the sequence has no elements, <code>nextPartialResult</code> is never executed
and <code>initialResult</code> is the result of the call to <code>reduce(_:_:)</code>.</p>

<p><strong>Parameters:</strong>
  <strong>initialResult:</strong> The value to use as the initial accumulating value.
    <code>initialResult</code> is passed to <code>nextPartialResult</code> the first time the
    closure is executed.
  <strong>nextPartialResult:</strong> A closure that combines an accumulating value and
    an element of the sequence into a new accumulating value, to be used
    in the next call of the <code>nextPartialResult</code> closure or returned to
    the caller.
<strong>Returns:</strong> The final accumulated value. If the sequence has no elements,
  the result is <code>initialResult</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Array&lt;Element&gt;.Element) throws -&gt; Result) rethrows -&gt; Result</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reduce-into__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reduce-into__">func reduce(<wbr>into:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reduce-into__"><div class="p">
    <p>Returns the result of combining the elements of the sequence using the
given closure.</p>

<p>Use the <code>reduce(into:_:)</code> method to produce a single value from the
elements of an entire sequence. For example, you can use this method on an
array of integers to filter adjacent equal entries or count frequencies.</p>

<p>This method is preferred over <code>reduce(_:_:)</code> for efficiency when the
result is a copy-on-write type, for example an Array or a Dictionary.</p>

<p>The <code>updateAccumulatingResult</code> closure is called sequentially with a
mutable accumulating value initialized to <code>initialResult</code> and each element
of the sequence. This example shows how to build a dictionary of letter
frequencies of a string.</p>

<pre><code class="language-swift">let letters = &quot;abracadabra&quot;
let letterCount = letters.reduce(into: [:]) { counts, letter in
    counts[letter, default: 0] += 1
}
// letterCount == [&quot;a&quot;: 5, &quot;b&quot;: 2, &quot;r&quot;: 2, &quot;c&quot;: 1, &quot;d&quot;: 1]</code></pre>

<p>When <code>letters.reduce(into:_:)</code> is called, the following steps occur:</p>

<ol><li>The <code>updateAccumulatingResult</code> closure is called with the initial
accumulating value---<code>[:]</code> in this case---and the first character of
<code>letters</code>, modifying the accumulating value by setting <code>1</code> for the key
<code>&quot;a&quot;</code>.</li><li>The closure is called again repeatedly with the updated accumulating
value and each element of the sequence.</li><li>When the sequence is exhausted, the accumulating value is returned to
the caller.</li></ol>

<p>If the sequence has no elements, <code>updateAccumulatingResult</code> is never
executed and <code>initialResult</code> is the result of the call to
<code>reduce(into:_:)</code>.</p>

<p><strong>Parameters:</strong>
  <strong>initialResult:</strong> The value to use as the initial accumulating value.
  <strong>updateAccumulatingResult:</strong> A closure that updates the accumulating
    value with an element of the sequence.
<strong>Returns:</strong> The final accumulated value. If the sequence has no elements,
  the result is <code>initialResult</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reduce&lt;Result&gt;(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Array&lt;Element&gt;.Element) throws -&gt; ()) rethrows -&gt; Result</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration" id="func-remove-at_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-remove-at_">mutating func remove(<wbr>at:)</a>
        
<div class="comment collapse" id="comment-func-remove-at_"><div class="p">
    <p>Removes and returns the element at the specified position.</p>

<p>All the elements following the specified position are moved up to
close the gap.</p>

<pre><code class="language-swift">var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
let removed = measurements.remove(at: 2)
print(measurements)
// Prints &quot;[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]&quot;</code></pre>

<p><strong><code>index</code>:</strong>  The position of the element to remove. <code>index</code> must
  be a valid index of the array.
<strong>Returns:</strong> The element at the specified index.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func remove(at index: Int) -&gt; [Element].Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-removeall-keepingcapacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removeall-keepingcapacity_">mutating func removeAll(<wbr>keepingCapacity:)</a>
        
<div class="comment collapse" id="comment-func-removeall-keepingcapacity_"><div class="p">
    <p>Removes all elements from the array.</p>

<p><strong><code>keepCapacity</code>:</strong>  Pass <code>true</code> to keep the existing capacity of
  the array after removing its elements. The default value is
  <code>false</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeAll(keepingCapacity keepCapacity: Bool = default)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removeall-where_-self-element-throws-bool">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removeall-where_-self-element-throws-bool">mutating func removeAll(<wbr>where: (Array&lt;Element&gt;.Element) throws -&gt; Bool)</a>
        
<div class="comment collapse" id="comment-func-removeall-where_-self-element-throws-bool"><div class="p">
    <p>Removes all the elements that satisfy the given predicate.</p>

<p>Use this method to remove every element in a collection that meets
particular criteria. This example removes all the vowels from a string:</p>

<pre><code class="language-swift">var phrase = &quot;The rain in Spain stays mainly in the plain.&quot;

let vowels: Set&lt;Character&gt; = [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;]
phrase.removeAll(where: { vowels.contains($0) })
// phrase == &quot;Th rn n Spn stys mnly n th pln.&quot;</code></pre>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the
  sequence as its argument and returns a Boolean value indicating
  whether the element should be removed from the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeAll(where predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removefirst">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removefirst">mutating func removeFirst()</a>
        
<div class="comment collapse" id="comment-func-removefirst"><div class="p">
    <p>Removes and returns the first element of the collection.</p>

<p>The collection must not be empty.</p>

<pre><code class="language-swift">var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]
bugs.removeFirst()
print(bugs)
// Prints &quot;[&quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>

<p>Calling this method may invalidate any existing indices for use with this
collection.</p>

<p><strong>Returns:</strong> The removed element.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeFirst() -&gt; Array&lt;Element&gt;.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removefirst_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removefirst_">mutating func removeFirst(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-removefirst_"><div class="p">
    <p>Removes the specified number of elements from the beginning of the
collection.</p>

<pre><code class="language-swift">var bugs = [&quot;Aphid&quot;, &quot;Bumblebee&quot;, &quot;Cicada&quot;, &quot;Damselfly&quot;, &quot;Earwig&quot;]
bugs.removeFirst(3)
print(bugs)
// Prints &quot;[&quot;Damselfly&quot;, &quot;Earwig&quot;]&quot;</code></pre>

<p>Calling this method may invalidate any existing indices for use with this
collection.</p>

<p><strong><code>n</code>:</strong>  The number of elements to remove from the collection.
  <code>n</code> must be greater than or equal to zero and must not exceed the
  number of elements in the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeFirst(_ n: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removelast">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removelast">mutating func removeLast()</a>
        
<div class="comment collapse" id="comment-func-removelast"><div class="p">
    <p>Removes and returns the last element of the collection.</p>

<p>The collection must not be empty.</p>

<p>Calling this method may invalidate all saved indices of this
collection. Do not rely on a previously stored index value after
altering a collection with any operation that can change its length.</p>

<p><strong>Returns:</strong> The last element of the collection.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeLast() -&gt; Array&lt;Element&gt;.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removelast_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removelast_">mutating func removeLast(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-removelast_"><div class="p">
    <p>Removes the specified number of elements from the end of the
collection.</p>

<p>Attempting to remove more elements than exist in the collection
triggers a runtime error.</p>

<p>Calling this method may invalidate all saved indices of this
collection. Do not rely on a previously stored index value after
altering a collection with any operation that can change its length.</p>

<p><strong><code>n</code>:</strong>  The number of elements to remove from the collection.
  <code>n</code> must be greater than or equal to zero and must not exceed the
  number of elements in the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the specified number of elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeLast(_ n: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removesubrange_-range-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removesubrange_-range-self-index">mutating func removeSubrange(<wbr>_: Range&lt;Array&lt;Element&gt;.Index&gt;)</a>
        
<div class="comment collapse" id="comment-func-removesubrange_-range-self-index"><div class="p">
    <p>Removes the elements in the specified subrange from the collection.</p>

<p>All the elements following the specified position are moved to close the
gap. This example removes three elements from the middle of an array of
measurements.</p>

<pre><code class="language-swift">var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
measurements.removeSubrange(1..&lt;4)
print(measurements)
// Prints &quot;[1.2, 1.5]&quot;</code></pre>

<p>Calling this method may invalidate any existing indices for use with this
collection.</p>

<p><strong><code>bounds</code>:</strong>  The range of the collection to be removed. The
  bounds of the range must be valid indices of the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeSubrange(_ bounds: Range&lt;Array&lt;Element&gt;.Index&gt;)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-removesubrange-r_-r">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-removesubrange-r_-r">mutating func removeSubrange&lt;R&gt;(<wbr>_: R)</a>
        
<div class="comment collapse" id="comment-func-removesubrange-r_-r"><div class="p">
    <p>Removes the elements in the specified subrange from the collection.</p>

<p>All the elements following the specified position are moved to close the
gap. This example removes three elements from the middle of an array of
measurements.</p>

<pre><code class="language-swift">var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
measurements.removeSubrange(1..&lt;4)
print(measurements)
// Prints &quot;[1.2, 1.5]&quot;</code></pre>

<p>Calling this method may invalidate any existing indices for use with this
collection.</p>

<p><strong><code>bounds</code>:</strong>  The range of the collection to be removed. The
  bounds of the range must be valid indices of the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func removeSubrange&lt;R&gt;(_ bounds: R)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-replacesubrange_with_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-replacesubrange_with_">mutating func replaceSubrange(<wbr>_:<wbr>with:)</a>
        
<div class="comment collapse" id="comment-func-replacesubrange_with_"><div class="p">
    <p>Replaces a range of elements with the elements in the specified
collection.</p>

<p>This method has the effect of removing the specified range of elements
from the array and inserting the new elements at the same location. The
number of new elements need not match the number of elements being
removed.</p>

<p>In this example, three elements in the middle of an array of integers are
replaced by the five elements of a <code>Repeated&lt;Int&gt;</code> instance.</p>

<pre><code class="language-swift"> var nums = [10, 20, 30, 40, 50]
 nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
 print(nums)
 // Prints &quot;[10, 1, 1, 1, 1, 1, 50]&quot;</code></pre>

<p>If you pass a zero-length range as the <code>subrange</code> parameter, this method
inserts the elements of <code>newElements</code> at <code>subrange.startIndex</code>. Calling
the <code>insert(contentsOf:at:)</code> method instead is preferred.</p>

<p>Likewise, if you pass a zero-length collection as the <code>newElements</code>
parameter, this method removes the elements in the given subrange
without replacement. Calling the <code>removeSubrange(_:)</code> method instead is
preferred.</p>

<p><strong>Parameters:</strong>
  <strong>subrange:</strong> The subrange of the array to replace. The start and end of
    a subrange must be valid indices of the array.
  <strong>newElements:</strong> The new elements to add to the array.</p>

<p><strong>Complexity:</strong> O(<code>subrange.count</code>) if you are replacing a suffix of the
  array with an empty collection; otherwise, O(<em>n</em>), where <em>n</em> is the
  length of the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func replaceSubrange&lt;C&gt;(_ subrange: Range&lt;Int&gt;, with newElements: C)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-reservecapacity_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reservecapacity_">mutating func reserveCapacity(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-reservecapacity_"><div class="p">
    <p>Reserves enough space to store the specified number of elements.</p>

<p>If you are adding a known number of elements to an array, use this method
to avoid multiple reallocations. This method ensures that the array has
unique, mutable, contiguous storage, with space allocated for at least
the requested number of elements.</p>

<p>Calling the <code>reserveCapacity(_:)</code> method on an array with bridged storage
triggers a copy to contiguous storage even if the existing storage
has room to store <code>minimumCapacity</code> elements.</p>

<p>For performance reasons, the size of the newly allocated storage might be
greater than the requested capacity. Use the array&#39;s <code>capacity</code> property
to determine the size of the new storage.</p>

<h1>Preserving an Array&#39;s Geometric Growth Strategy</h1>

<p>If you implement a custom data structure backed by an array that grows
dynamically, naively calling the <code>reserveCapacity(_:)</code> method can lead
to worse than expected performance. Arrays need to follow a geometric
allocation pattern for appending elements to achieve amortized
constant-time performance. The <code>Array</code> type&#39;s <code>append(_:)</code> and
<code>append(contentsOf:)</code> methods take care of this detail for you, but
<code>reserveCapacity(_:)</code> allocates only as much space as you tell it to
(padded to a round value), and no more. This avoids over-allocation, but
can result in insertion not having amortized constant-time performance.</p>

<p>The following code declares <code>values</code>, an array of integers, and the
<code>addTenQuadratic()</code> function, which adds ten more values to the <code>values</code>
array on each call.</p>

<pre><code class="language-swift">  var values: [Int] = [0, 1, 2, 3]

  // Don&#39;t use &#39;reserveCapacity(_:)&#39; like this
  func addTenQuadratic() {
      let newCount = values.count + 10
      values.reserveCapacity(newCount)
      for n in values.count..&lt;newCount {
          values.append(n)
      }
  }</code></pre>

<p>The call to <code>reserveCapacity(_:)</code> increases the <code>values</code> array&#39;s capacity
by exactly 10 elements on each pass through <code>addTenQuadratic()</code>, which
is linear growth. Instead of having constant time when averaged over
many calls, the function may decay to performance that is linear in
<code>values.count</code>. This is almost certainly not what you want.</p>

<p>In cases like this, the simplest fix is often to simply remove the call
to <code>reserveCapacity(_:)</code>, and let the <code>append(_:)</code> method grow the array
for you.</p>

<pre><code class="language-swift">  func addTen() {
      let newCount = values.count + 10
      for n in values.count..&lt;newCount {
          values.append(n)
      }
  }</code></pre>

<p>If you need more control over the capacity of your array, implement your
own geometric growth strategy, passing the size you compute to
<code>reserveCapacity(_:)</code>.</p>

<p><strong><code>minimumCapacity</code>:</strong>  The requested number of elements to store.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the number of elements in the array.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func reserveCapacity(_ minimumCapacity: Int)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Array/"><code>Array</code></a>,    <a href="../../protocol/RangeReplaceableCollection/"><code>RangeReplaceableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reverse">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reverse">mutating func reverse()</a>
        
<div class="comment collapse" id="comment-func-reverse"><div class="p">
    <p>Reverses the elements of the collection in place.</p>

<p>The following example reverses the elements of an array of characters:</p>

<pre><code class="language-swift">var characters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;f&quot;, &quot;&quot;]
characters.reverse()
print(characters)
// Prints &quot;[&quot;&quot;, &quot;f&quot;, &quot;a&quot;, &quot;C&quot;]</code></pre>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the number of elements in the
  collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func reverse()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-reversed">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-reversed">func reversed()</a>
        
<div class="comment collapse" id="comment-func-reversed"><div class="p">
    <p>Returns a view presenting the elements of the collection in reverse
order.</p>

<p>You can reverse a collection without allocating new space for its
elements by calling this <code>reversed()</code> method. A <code>ReversedCollection</code>
instance wraps an underlying collection and provides access to its
elements in reverse order. This example prints the characters of a
string in reverse order:</p>

<pre><code class="language-swift">let word = &quot;Backwards&quot;
for char in word.reversed() {
    print(char, terminator: &quot;&quot;)
}
// Prints &quot;sdrawkcaB&quot;</code></pre>

<p>If you need a reversed collection of the same type, you may be able to
use the collection&#39;s sequence-based or collection-based initializer. For
example, to get the reversed version of a string, reverse its
characters and initialize a new <code>String</code> instance from the result.</p>

<pre><code class="language-swift">let reversedWord = String(word.reversed())
print(reversedWord)
// Prints &quot;sdrawkcaB&quot;</code></pre>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func reversed() -&gt; ReversedCollection&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffle">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffle">mutating func shuffle()</a>
        
<div class="comment collapse" id="comment-func-shuffle"><div class="p">
    <p>Shuffles the collection in place.</p>

<p>Use the <code>shuffle()</code> method to randomly reorder the elements of an
array.</p>

<pre><code class="language-swift">var names = [&quot;Alejandro&quot;, &quot;Camila&quot;, &quot;Diego&quot;, &quot;Luciana&quot;, &quot;Luis&quot;, &quot;Sofa&quot;]
names.shuffle(using: myGenerator)
// names == [&quot;Luis&quot;, &quot;Camila&quot;, &quot;Luciana&quot;, &quot;Sofa&quot;, &quot;Alejandro&quot;, &quot;Diego&quot;]</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>names.shuffle()</code> above is equivalent to calling
<code>names.shuffle(using: &amp;Random.default)</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func shuffle()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffle-using_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffle-using_">mutating func shuffle(<wbr>using:)</a>
        
<div class="comment collapse" id="comment-func-shuffle-using_"><div class="p">
    <p>Shuffles the collection in place, using the given generator as a source
for randomness.</p>

<p>You use this method to randomize the elements of a collection when you
are using a custom random number generator. For example, you can use the
<code>shuffle(using:)</code> method to randomly reorder the elements of an array.</p>

<pre><code class="language-swift">var names = [&quot;Alejandro&quot;, &quot;Camila&quot;, &quot;Diego&quot;, &quot;Luciana&quot;, &quot;Luis&quot;, &quot;Sofa&quot;]
names.shuffle(using: &amp;myGenerator)
// names == [&quot;Sofa&quot;, &quot;Alejandro&quot;, &quot;Camila&quot;, &quot;Luis&quot;, &quot;Diego&quot;, &quot;Luciana&quot;]</code></pre>

<p><strong><code>generator</code>:</strong>  The random number generator to use when shuffling
  the collection.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func shuffle&lt;T&gt;(using generator: inout T)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffled">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffled">func shuffled()</a>
        
<div class="comment collapse" id="comment-func-shuffled"><div class="p">
    <p>Returns the elements of the sequence, shuffled.</p>

<p>For example, you can shuffle the numbers between <code>0</code> and <code>9</code> by calling
the <code>shuffled()</code> method on that range:</p>

<pre><code class="language-swift">let numbers = 0...9
let shuffledNumbers = numbers.shuffled()
// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]</code></pre>

<p>This method uses the default random generator, <code>Random.default</code>. The call
to <code>numbers.shuffled()</code> above is equivalent to calling
<code>numbers.shuffled(using: &amp;Random.default)</code>.</p>

<p><strong>Returns:</strong> A shuffled array of this sequence&#39;s elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func shuffled() -&gt; [Array&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-shuffled-using_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-shuffled-using_">func shuffled(<wbr>using:)</a>
        
<div class="comment collapse" id="comment-func-shuffled-using_"><div class="p">
    <p>Returns the elements of the sequence, shuffled using the given generator
as a source for randomness.</p>

<p>You use this method to randomize the elements of a sequence when you
are using a custom random number generator. For example, you can shuffle
the numbers between <code>0</code> and <code>9</code> by calling the <code>shuffled(using:)</code> method
on that range:</p>

<pre><code class="language-swift">let numbers = 0...9
let shuffledNumbers = numbers.shuffled(using: &amp;myGenerator)
// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]</code></pre>

<p><strong><code>generator</code>:</strong>  The random number generator to use when shuffling
  the sequence.
<strong>Returns:</strong> An array of this sequence&#39;s elements in a shuffled order.</p>

<p><strong>Complexity:</strong> O(<em>n</em>)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func shuffled&lt;T&gt;(using generator: inout T) -&gt; [Array&lt;Element&gt;.Element] where T : RandomNumberGenerator</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-sort-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-sort-by_">mutating func sort(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-sort-by_"><div class="p">
    <p>Sorts the collection in place, using the given predicate as the
comparison between elements.</p>

<p>When you want to sort a collection of elements that doesn&#39;t conform to
the <code>Comparable</code> protocol, pass a closure to this method that returns
<code>true</code> when the first element passed should be ordered before the
second.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also <code>true</code>.
(Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements for which <code>areInIncreasingOrder</code> does not
establish an order.</p>

<p>In the following example, the closure provides an ordering for an array
of a custom enumeration that describes an HTTP response. The predicate
orders errors before successes and sorts the error responses by their
error code.</p>

<pre><code class="language-swift">enum HTTPResponse {
    case ok
    case error(Int)
}

var responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
responses.sort {
    switch ($0, $1) {
    // Order errors by code
    case let (.error(aCode), .error(bCode)):
        return aCode &lt; bCode

    // All successes are equivalent, so none is before any other
    case (.ok, .ok): return false

    // Order errors before successes
    case (.error, .ok): return true
    case (.ok, .error): return false
    }
}
print(responses)
// Prints &quot;[.error(403), .error(404), .error(500), .ok, .ok]&quot;</code></pre>

<p>Alternatively, use this method to sort a collection of elements that do
conform to <code>Comparable</code> when you want the sort to be descending instead
of ascending. Pass the greater-than operator (<code>&gt;</code>) operator as the
predicate.</p>

<pre><code class="language-swift">var students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
students.sort(by: &gt;)
print(students)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code> if its
  first argument should be ordered before its second argument;
  otherwise, <code>false</code>. If <code>areInIncreasingOrder</code> throws an error during
  the sort, the elements may be in a different order, but none will be
  lost.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func sort(by areInIncreasingOrder: (Array&lt;Element&gt;.Element, Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-sorted-by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-sorted-by_">func sorted(<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-sorted-by_"><div class="p">
    <p>Returns the elements of the sequence, sorted using the given predicate as
the comparison between elements.</p>

<p>When you want to sort a sequence of elements that don&#39;t conform to the
<code>Comparable</code> protocol, pass a predicate to this method that returns
<code>true</code> when the first element passed should be ordered before the
second. The elements of the resulting array are ordered according to the
given predicate.</p>

<p>The predicate must be a <em>strict weak ordering</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areInIncreasingOrder(a, a)</code> is always <code>false</code>. (Irreflexivity)</li><li>If <code>areInIncreasingOrder(a, b)</code> and <code>areInIncreasingOrder(b, c)</code> are
both <code>true</code>, then <code>areInIncreasingOrder(a, c)</code> is also <code>true</code>.
(Transitive comparability)</li><li>Two elements are <em>incomparable</em> if neither is ordered before the other
according to the predicate. If <code>a</code> and <code>b</code> are incomparable, and <code>b</code>
and <code>c</code> are incomparable, then <code>a</code> and <code>c</code> are also incomparable.
(Transitive incomparability)</li></ul>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements for which <code>areInIncreasingOrder</code> does not
establish an order.</p>

<p>In the following example, the predicate provides an ordering for an array
of a custom <code>HTTPResponse</code> type. The predicate orders errors before
successes and sorts the error responses by their error code.</p>

<pre><code class="language-swift">enum HTTPResponse {
    case ok
    case error(Int)
}

let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
let sortedResponses = responses.sorted {
    switch ($0, $1) {
    // Order errors by code
    case let (.error(aCode), .error(bCode)):
        return aCode &lt; bCode

    // All successes are equivalent, so none is before any other
    case (.ok, .ok): return false

    // Order errors before successes
    case (.error, .ok): return true
    case (.ok, .error): return false
    }
}
print(sortedResponses)
// Prints &quot;[.error(403), .error(404), .error(500), .ok, .ok]&quot;</code></pre>

<p>You also use this method to sort elements that conform to the
<code>Comparable</code> protocol in descending order. To sort your sequence in
descending order, pass the greater-than operator (<code>&gt;</code>) as the
<code>areInIncreasingOrder</code> parameter.</p>

<pre><code class="language-swift">let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
let descendingStudents = students.sorted(by: &gt;)
print(descendingStudents)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

<p>Calling the related <code>sorted()</code> method is equivalent to calling this
method and passing the less-than operator (<code>&lt;</code>) as the predicate.</p>

<pre><code class="language-swift">print(students.sorted())
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;
print(students.sorted(by: &lt;))
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>

<p><strong><code>areInIncreasingOrder</code>:</strong>  A predicate that returns <code>true</code> if its
  first argument should be ordered before its second argument;
  otherwise, <code>false</code>.
<strong>Returns:</strong> A sorted array of the sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func sorted(by areInIncreasingOrder: (Array&lt;Element&gt;.Element, Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [Array&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-split_omittingemptysubsequences_whereseparator_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-split_omittingemptysubsequences_whereseparator_">func split(<wbr>_:<wbr>omittingEmptySubsequences:<wbr>whereSeparator:)</a>
        
<div class="comment collapse" id="comment-func-split_omittingemptysubsequences_whereseparator_"><div class="p">
    <p>Returns the longest possible subsequences of the collection, in order,
that don&#39;t contain elements satisfying the given predicate.</p>

<p>The resulting array consists of at most <code>maxSplits + 1</code> subsequences.
Elements that are used to split the sequence are not returned as part of
any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string using a
closure that matches spaces. The first use of <code>split</code> returns each word
that was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(line.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>
parameter, so the returned array contains empty strings where spaces
were repeated.</p>

<pre><code class="language-swift">print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == &quot; &quot; }))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>maxSplits:</strong> The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    <code>maxSplits + 1</code> subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    <code>maxSplits</code> must be greater than or equal to zero. The default value
    is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each pair of consecutive elements
    satisfying the <code>isSeparator</code> predicate and for each element at the
    start or end of the collection satisfying the <code>isSeparator</code>
    predicate. The default value is <code>true</code>.
  <strong>isSeparator:</strong> A closure that takes an element as an argument and
    returns a Boolean value indicating whether the collection should be
    split at that element.
<strong>Returns:</strong> An array of subsequences, split from this collection&#39;s
  elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [Array&lt;Element&gt;.SubSequence]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-starts-with_by_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-starts-with_by_">func starts(<wbr>with:<wbr>by:)</a>
        
<div class="comment collapse" id="comment-func-starts-with_by_"><div class="p">
    <p>Returns a Boolean value indicating whether the initial elements of the
sequence are equivalent to the elements in another sequence, using
the given predicate as the equivalence test.</p>

<p>The predicate must be a <em>equivalence relation</em> over the elements. That
is, for any elements <code>a</code>, <code>b</code>, and <code>c</code>, the following conditions must
hold:</p>

<ul><li><code>areEquivalent(a, a)</code> is always <code>true</code>. (Reflexivity)</li><li><code>areEquivalent(a, b)</code> implies <code>areEquivalent(b, a)</code>. (Symmetry)</li><li>If <code>areEquivalent(a, b)</code> and <code>areEquivalent(b, c)</code> are both <code>true</code>, then
<code>areEquivalent(a, c)</code> is also <code>true</code>. (Transitivity)</li></ul>

<p><strong>Parameters:</strong>
  <strong>possiblePrefix:</strong> A sequence to compare to this sequence.
  <strong>areEquivalent:</strong> A predicate that returns <code>true</code> if its two arguments
    are equivalent; otherwise, <code>false</code>.
<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are equivalent
  to the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If
  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func starts&lt;PossiblePrefix&gt;(with possiblePrefix: PossiblePrefix, by areEquivalent: (Array&lt;Element&gt;.Element, PossiblePrefix.Element) throws -&gt; Bool) rethrows -&gt; Bool where PossiblePrefix : Sequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-suffix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-suffix_">func suffix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-suffix_"><div class="p">
    <p>Returns a subsequence, up to the given maximum length, containing the
final elements of the collection.</p>

<p>If the maximum length exceeds the number of elements in the collection,
the result contains the entire collection.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.suffix(2))
// Prints &quot;[4, 5]&quot;
print(numbers.suffix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return.
  <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence terminating at the end of the collection with at
  most <code>maxLength</code> elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is equal to <code>maxLength</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(_ maxLength: Int) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>,    <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-suffix-from_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-suffix-from_">func suffix(<wbr>from:)</a>
        
<div class="comment collapse" id="comment-func-suffix-from_"><div class="p">
    <p>Returns a subsequence from the specified position to the end of the
collection.</p>

<p>The following example searches for the index of the number <code>40</code> in an
array of integers, and then prints the suffix of the array starting at
that index:</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50, 60]
if let i = numbers.firstIndex(of: 40) {
    print(numbers.suffix(from: i))
}
// Prints &quot;[40, 50, 60]&quot;</code></pre>

<p>Passing the collection&#39;s <code>endIndex</code> as the <code>start</code> parameter results in
an empty subsequence.</p>

<pre><code class="language-swift">print(numbers.suffix(from: numbers.endIndex))
// Prints &quot;[]&quot;</code></pre>

<p>Using the <code>suffix(from:)</code> method is equivalent to using a partial range
from the index as the collection&#39;s subscript. The subscript notation is
preferred over <code>suffix(from:)</code>.</p>

<pre><code class="language-swift">if let i = numbers.firstIndex(of: 40) {
    print(numbers[i...])
}
// Prints &quot;[40, 50, 60]&quot;</code></pre>

<p><strong><code>start</code>:</strong>  The index at which to start the resulting subsequence.
  <code>start</code> must be a valid index of the collection.
<strong>Returns:</strong> A subsequence starting at the <code>start</code> position.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(from start: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.SubSequence</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-swapat__">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-swapat__">mutating func swapAt(<wbr>_:<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-swapat__"><div class="p">
    <p>Exchanges the values at the specified indices of the collection.</p>

<p>Both parameters must be valid indices of the collection that are not
equal to <code>endIndex</code>. Calling <code>swapAt(_:_:)</code> with the same index as both
<code>i</code> and <code>j</code> has no effect.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> The index of the first value to swap.
  <strong>j:</strong> The index of the second value to swap.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func swapAt(_ i: Array&lt;Element&gt;.Index, _ j: Array&lt;Element&gt;.Index)</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration" id="func-withunsafebufferpointer_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-withunsafebufferpointer_">func withUnsafeBufferPointer(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-withunsafebufferpointer_"><div class="p">
    <p>Calls a closure with a pointer to the array&#39;s contiguous storage.</p>

<p>Often, the optimizer can eliminate bounds checks within an array
algorithm, but when that fails, invoking the same algorithm on the
buffer pointer passed into your closure lets you trade safety for speed.</p>

<p>The following example shows how you can iterate over the contents of the
buffer pointer:</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
let sum = numbers.withUnsafeBufferPointer { buffer -&gt; Int in
    var result = 0
    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
        result += buffer[i]
    }
    return result
}
// &#39;sum&#39; == 9</code></pre>

<p>The pointer passed as an argument to <code>body</code> is valid only during the
execution of <code>withUnsafeBufferPointer(_:)</code>. Do not store or return the
pointer for later use.</p>

<p><strong><code>body</code>:</strong>  A closure with an <code>UnsafeBufferPointer</code> parameter that
  points to the contiguous storage for the array.  If no such storage exists, it is created. If
  <code>body</code> has a return value, that value is also used as the return value
  for the <code>withUnsafeBufferPointer(_:)</code> method. The pointer argument is
  valid only for the duration of the method&#39;s execution.
<strong>Returns:</strong> The return value, if any, of the <code>body</code> closure parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func withUnsafeBufferPointer&lt;R&gt;(_ body: (UnsafeBufferPointer&lt;[Element].Element&gt;) throws -&gt; R) rethrows -&gt; R</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-withunsafebytes_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-withunsafebytes_">func withUnsafeBytes(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-withunsafebytes_"><div class="p">
    <p>Calls the given closure with a pointer to the underlying bytes of the
array&#39;s contiguous storage.</p>

<p>The array&#39;s <code>Element</code> type must be a <em>trivial type</em>, which can be copied
with just a bit-for-bit copy without any indirection or
reference-counting operations. Generally, native Swift types that do not
contain strong or weak references are trivial, as are imported C structs
and enums.</p>

<p>The following example copies the bytes of the <code>numbers</code> array into a
buffer of <code>UInt8</code>:</p>

<pre><code class="language-swift">var numbers = [1, 2, 3]
var byteBuffer: [UInt8] = []
numbers.withUnsafeBytes {
    byteBuffer.append(contentsOf: $0)
}
// byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]</code></pre>

<p><strong><code>body</code>:</strong>  A closure with an <code>UnsafeRawBufferPointer</code> parameter
  that points to the contiguous storage for the array.
   If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
  used as the return value for the <code>withUnsafeBytes(_:)</code> method. The
  argument is valid only for the duration of the closure&#39;s execution.
<strong>Returns:</strong> The return value, if any, of the <code>body</code> closure parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func withUnsafeBytes&lt;R&gt;(_ body: (UnsafeRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-withunsafemutablebufferpointer_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-withunsafemutablebufferpointer_">mutating func withUnsafeMutableBufferPointer(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-withunsafemutablebufferpointer_"><div class="p">
    <p>Calls the given closure with a pointer to the array&#39;s mutable contiguous
storage.</p>

<p>Often, the optimizer can eliminate bounds checks within an array
algorithm, but when that fails, invoking the same algorithm on the
buffer pointer passed into your closure lets you trade safety for speed.</p>

<p>The following example shows how modifying the contents of the
<code>UnsafeMutableBufferPointer</code> argument to <code>body</code> alters the contents of
the array:</p>

<pre><code class="language-swift">var numbers = [1, 2, 3, 4, 5]
numbers.withUnsafeMutableBufferPointer { buffer in
    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
        buffer.swapAt(i, i + 1)
    }
}
print(numbers)
// Prints &quot;[2, 1, 4, 3, 5]&quot;</code></pre>

<p>The pointer passed as an argument to <code>body</code> is valid only during the
execution of <code>withUnsafeMutableBufferPointer(_:)</code>. Do not store or
return the pointer for later use.</p>

<p><strong>Warning:</strong> Do not rely on anything about the array that is the target of
  this method during execution of the <code>body</code> closure; it might not
  appear to have its correct value. Instead, use only the
  <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.</p>

<p><strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableBufferPointer</code>
  parameter that points to the contiguous storage for the array.
   If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
  used as the return value for the <code>withUnsafeMutableBufferPointer(_:)</code>
  method. The pointer argument is valid only for the duration of the
  method&#39;s execution.
<strong>Returns:</strong> The return value, if any, of the <code>body</code> closure parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func withUnsafeMutableBufferPointer&lt;R&gt;(_ body: (inout UnsafeMutableBufferPointer&lt;[Element].Element&gt;) throws -&gt; R) rethrows -&gt; R</code>
    
    
</div></div>
</div>
<div class="declaration" id="func-withunsafemutablebytes_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-withunsafemutablebytes_">mutating func withUnsafeMutableBytes(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-withunsafemutablebytes_"><div class="p">
    <p>Calls the given closure with a pointer to the underlying bytes of the
array&#39;s mutable contiguous storage.</p>

<p>The array&#39;s <code>Element</code> type must be a <em>trivial type</em>, which can be copied
with just a bit-for-bit copy without any indirection or
reference-counting operations. Generally, native Swift types that do not
contain strong or weak references are trivial, as are imported C structs
and enums.</p>

<p>The following example copies bytes from the <code>byteValues</code> array into
<code>numbers</code>, an array of <code>Int</code>:</p>

<pre><code class="language-swift">var numbers: [Int32] = [0, 0]
var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]

numbers.withUnsafeMutableBytes { destBytes in
    byteValues.withUnsafeBytes { srcBytes in
        destBytes.copyBytes(from: srcBytes)
    }
}
// numbers == [1, 2]</code></pre>

<p>The pointer passed as an argument to <code>body</code> is valid only for the
lifetime of the closure. Do not escape it from the closure for later
use.</p>

<p><strong>Warning:</strong> Do not rely on anything about the array that is the target of
  this method during execution of the <code>body</code> closure; it might not
  appear to have its correct value. Instead, use only the
  <code>UnsafeMutableRawBufferPointer</code> argument to <code>body</code>.</p>

<p><strong><code>body</code>:</strong>  A closure with an <code>UnsafeMutableRawBufferPointer</code>
  parameter that points to the contiguous storage for the array.
   If no such storage exists, it is created. If <code>body</code> has a return value, that value is also
  used as the return value for the <code>withUnsafeMutableBytes(_:)</code> method.
  The argument is valid only for the duration of the closure&#39;s
  execution.
<strong>Returns:</strong> The return value, if any, of the <code>body</code> closure parameter.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func withUnsafeMutableBytes&lt;R&gt;(_ body: (UnsafeMutableRawBufferPointer) throws -&gt; R) rethrows -&gt; R</code>
    
    
</div></div>
</div>


<h3>Conditionally Inherited Items</h3>

<p class="comment">The initializers, methods, and properties listed below may be available on this type under certain conditions (such as methods that are available on <code>Array</code> when its elements are <code>Equatable</code>) or may not ever be available if that determination is beyond SwiftDoc.org's capabilities. Please <a href="https://github.com/SwiftDocOrg/swiftdoc.org/issues">open an issue on GitHub</a> if you see something out of place!</p>





<h4>Where Element : Collection</h4>




<div class="declaration inherited" id="func-element_-collection-joined">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-collection-joined">func joined()</a>
        
<div class="comment collapse" id="comment-func-element_-collection-joined"><div class="p">
    <p>Returns the elements of this collection of collections, concatenated.</p>

<p>In this example, an array of three ranges is flattened so that the
elements of each range can be iterated in turn.</p>

<pre><code class="language-swift">let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]

// A for-in loop over &#39;ranges&#39; accesses each range:
for range in ranges {
  print(range)
}
// Prints &quot;0..&lt;3&quot;
// Prints &quot;8..&lt;10&quot;
// Prints &quot;15..&lt;17&quot;

// Use &#39;joined()&#39; to access each element of each range:
for index in ranges.joined() {
    print(index, terminator: &quot; &quot;)
}
// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>

<p><strong>Returns:</strong> A flattened view of the elements of this
  collection of collections.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined() -&gt; FlattenCollection&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>





<h4>Where Element : Comparable</h4>




<div class="declaration inherited" id="func-element_-comparable-lexicographicallyprecedes_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-lexicographicallyprecedes_">func lexicographicallyPrecedes(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-lexicographicallyprecedes_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the
less-than operator (<code>&lt;</code>) to compare elements.</p>

<p>This example uses the <code>lexicographicallyPrecedes</code> method to test which
array of integers comes first in a lexicographical ordering.</p>

<pre><code class="language-swift">let a = [1, 2, 2, 2]
let b = [1, 2, 3, 4]

print(a.lexicographicallyPrecedes(b))
// Prints &quot;true&quot;
print(b.lexicographicallyPrecedes(b))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if this sequence precedes <code>other</code> in a dictionary
  ordering; otherwise, <code>false</code>.</p>

<p><strong>Note:</strong> This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use <code>String</code> APIs that
  perform localized comparison.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lexicographicallyPrecedes&lt;OtherSequence&gt;(_ other: OtherSequence) -&gt; Bool where OtherSequence : Sequence, Array&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-max">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-max">@warn_unqualified_access
     func max()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-max"><div class="p">
    <p>Returns the maximum element in the sequence.</p>

<p>This example finds the largest value in an array of height measurements.</p>

<pre><code class="language-swift">let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
let greatestHeight = heights.max()
print(greatestHeight)
// Prints &quot;Optional(67.5)&quot;</code></pre>

<p><strong>Returns:</strong> The sequence&#39;s maximum element. If the sequence has no
  elements, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func max() -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-min">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-min">@warn_unqualified_access
     func min()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-min"><div class="p">
    <p>Returns the minimum element in the sequence.</p>

<p>This example finds the smallest value in an array of height measurements.</p>

<pre><code class="language-swift">let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
let lowestHeight = heights.min()
print(lowestHeight)
// Prints &quot;Optional(58.5)&quot;</code></pre>

<p><strong>Returns:</strong> The sequence&#39;s minimum element. If the sequence has no
  elements, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">@warn_unqualified_access
     func min() -&gt; Array&lt;Element&gt;.Element?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-sort">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-sort">mutating func sort()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-sort"><div class="p">
    <p>Sorts the collection in place.</p>

<p>You can sort any mutable collection of elements that conform to the
<code>Comparable</code> protocol by calling this method. Elements are sorted in
ascending order.</p>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements that compare equal.</p>

<p>Here&#39;s an example of sorting a list of students&#39; names. Strings in Swift
conform to the <code>Comparable</code> protocol, so the names are sorted in
ascending order according to the less-than operator (<code>&lt;</code>).</p>

<pre><code class="language-swift">var students = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
students.sort()
print(students)
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>

<p>To sort the elements of your collection in descending order, pass the
greater-than operator (<code>&gt;</code>) to the <code>sort(by:)</code> method.</p>

<pre><code class="language-swift">students.sort(by: &gt;)
print(students)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">mutating func sort()</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/MutableCollection/"><code>MutableCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-comparable-sorted">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-comparable-sorted">func sorted()</a>
        
<div class="comment collapse" id="comment-func-element_-comparable-sorted"><div class="p">
    <p>Returns the elements of the sequence, sorted.</p>

<p>You can sort any sequence of elements that conform to the <code>Comparable</code>
protocol by calling this method. Elements are sorted in ascending order.</p>

<p>The sorting algorithm is not stable. A nonstable sort may change the
relative order of elements that compare equal.</p>

<p>Here&#39;s an example of sorting a list of students&#39; names. Strings in Swift
conform to the <code>Comparable</code> protocol, so the names are sorted in
ascending order according to the less-than operator (<code>&lt;</code>).</p>

<pre><code class="language-swift">let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
let sortedStudents = students.sorted()
print(sortedStudents)
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</code></pre>

<p>To sort the elements of your sequence in descending order, pass the
greater-than operator (<code>&gt;</code>) to the <code>sorted(by:)</code> method.</p>

<pre><code class="language-swift">let descendingStudents = students.sorted(by: &gt;)
print(descendingStudents)
// Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;</code></pre>

<p><strong>Returns:</strong> A sorted array of the sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func sorted() -&gt; [Array&lt;Element&gt;.Element]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : Equatable</h4>




<div class="declaration inherited" id="func-element_-equatable-contains_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-contains_">func contains(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-contains_"><div class="p">
    <p>Returns a Boolean value indicating whether the sequence contains the
given element.</p>

<p>This example checks to see whether a favorite actor is in an array
storing a movie&#39;s cast.</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
print(cast.contains(&quot;Marlon&quot;))
// Prints &quot;true&quot;
print(cast.contains(&quot;James&quot;))
// Prints &quot;false&quot;</code></pre>

<p><strong><code>element</code>:</strong>  The element to find in the sequence.
<strong>Returns:</strong> <code>true</code> if the element was found in the sequence; otherwise,
  <code>false</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func contains(_ element: Array&lt;Element&gt;.Element) -&gt; Bool</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-elementsequal_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-elementsequal_">func elementsEqual(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-elementsequal_"><div class="p">
    <p>Returns a Boolean value indicating whether this sequence and another
sequence contain the same elements in the same order.</p>

<p>At least one of the sequences must be finite.</p>

<p>This example tests whether one countable range shares the same elements
as another countable range and an array.</p>

<pre><code class="language-swift">let a = 1...3
let b = 1...10

print(a.elementsEqual(b))
// Prints &quot;false&quot;
print(a.elementsEqual([1, 2, 3]))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>other</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if this sequence and <code>other</code> contain the same elements
  in the same order.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func elementsEqual&lt;OtherSequence&gt;(_ other: OtherSequence) -&gt; Bool where OtherSequence : Sequence, Array&lt;Element&gt;.Element == OtherSequence.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-firstindex-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-firstindex-of_">func firstIndex(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-firstindex-of_"><div class="p">
    <p>Returns the first index where the specified value appears in the
collection.</p>

<p>After using <code>firstIndex(of:)</code> to find the position of a particular element
in a collection, you can use it to access the element by subscripting.
This example shows how you can modify one of the names in an array of
students.</p>

<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Maxime&quot;]
if let i = students.firstIndex(of: &quot;Maxime&quot;) {
    students[i] = &quot;Max&quot;
}
print(students)
// Prints &quot;[&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Max&quot;]&quot;</code></pre>

<p><strong><code>element</code>:</strong>  An element to search for in the collection.
<strong>Returns:</strong> The first index where <code>element</code> is found. If <code>element</code> is not
  found in the collection, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func firstIndex(of element: Array&lt;Element&gt;.Element) -&gt; Array&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-lastindex-of_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-lastindex-of_">func lastIndex(<wbr>of:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-lastindex-of_"><div class="p">
    <p>Returns the last index where the specified value appears in the
collection.</p>

<p>After using <code>lastIndex(of:)</code> to find the position of the last instance of
a particular element in a collection, you can use it to access the
element by subscripting. This example shows how you can modify one of
the names in an array of students.</p>

<pre><code class="language-swift">var students = [&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Ben&quot;, &quot;Maxime&quot;]
if let i = students.lastIndex(of: &quot;Ben&quot;) {
    students[i] = &quot;Benjamin&quot;
}
print(students)
// Prints &quot;[&quot;Ben&quot;, &quot;Ivy&quot;, &quot;Jordell&quot;, &quot;Benjamin&quot;, &quot;Max&quot;]&quot;</code></pre>

<p><strong><code>element</code>:</strong>  An element to search for in the collection.
<strong>Returns:</strong> The last index where <code>element</code> is found. If <code>element</code> is not
  found in the collection, returns <code>nil</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func lastIndex(of element: Array&lt;Element&gt;.Element) -&gt; Array&lt;Element&gt;.Index?</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/BidirectionalCollection/"><code>BidirectionalCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-split_maxsplits_omittingemptysubsequences_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-split_maxsplits_omittingemptysubsequences_">func split(<wbr>_:<wbr>maxSplits:<wbr>omittingEmptySubsequences:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-split_maxsplits_omittingemptysubsequences_"><div class="p">
    <p>Returns the longest possible subsequences of the collection, in order,
around elements equal to the given element.</p>

<p>The resulting array consists of at most <code>maxSplits + 1</code> subsequences.
Elements that are used to split the collection are not returned as part
of any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string at each
space character (&quot; &quot;). The first use of <code>split</code> returns each word that
was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(separator: &quot; &quot;))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(line.split(separator: &quot; &quot;, maxSplits: 1))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>false</code> for the <code>omittingEmptySubsequences</code>
parameter, so the returned array contains empty strings where spaces
were repeated.</p>

<pre><code class="language-swift">print(line.split(separator: &quot; &quot;, omittingEmptySubsequences: false))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>separator:</strong> The element that should be split upon.
  <strong>maxSplits:</strong> The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    <code>maxSplits + 1</code> subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    <code>maxSplits</code> must be greater than or equal to zero. The default value
    is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each consecutive pair of <code>separator</code>
    elements in the collection and for each instance of <code>separator</code> at
    the start or end of the collection. If <code>true</code>, only nonempty
    subsequences are returned. The default value is <code>true</code>.
<strong>Returns:</strong> An array of subsequences, split from this collection&#39;s
  elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(separator: Array&lt;Element&gt;.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -&gt; [Array&lt;Element&gt;.SubSequence]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>,    <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-equatable-starts-with_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-equatable-starts-with_">func starts(<wbr>with:)</a>
        
<div class="comment collapse" id="comment-func-element_-equatable-starts-with_"><div class="p">
    <p>Returns a Boolean value indicating whether the initial elements of the
sequence are the same as the elements in another sequence.</p>

<p>This example tests whether one countable range begins with the elements
of another countable range.</p>

<pre><code class="language-swift">let a = 1...3
let b = 1...10

print(b.starts(with: a))
// Prints &quot;true&quot;</code></pre>

<p>Passing a sequence with no elements or an empty collection as
<code>possiblePrefix</code> always results in <code>true</code>.</p>

<pre><code class="language-swift">print(b.starts(with: []))
// Prints &quot;true&quot;</code></pre>

<p><strong><code>possiblePrefix</code>:</strong>  A sequence to compare to this sequence.
<strong>Returns:</strong> <code>true</code> if the initial elements of the sequence are the same as
  the elements of <code>possiblePrefix</code>; otherwise, <code>false</code>. If
  <code>possiblePrefix</code> has no elements, the return value is <code>true</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func starts&lt;PossiblePrefix&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool where PossiblePrefix : Sequence, Array&lt;Element&gt;.Element == PossiblePrefix.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : Sequence</h4>




<div class="declaration inherited" id="func-element_-sequence-joined">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-sequence-joined">func joined()</a>
        
<div class="comment collapse" id="comment-func-element_-sequence-joined"><div class="p">
    <p>Returns the elements of this sequence of sequences, concatenated.</p>

<p>In this example, an array of three ranges is flattened so that the
elements of each range can be iterated in turn.</p>

<pre><code class="language-swift">let ranges = [0..&lt;3, 8..&lt;10, 15..&lt;17]

// A for-in loop over &#39;ranges&#39; accesses each range:
for range in ranges {
  print(range)
}
// Prints &quot;0..&lt;3&quot;
// Prints &quot;8..&lt;10&quot;
// Prints &quot;15..&lt;17&quot;

// Use &#39;joined()&#39; to access each element of each range:
for index in ranges.joined() {
    print(index, terminator: &quot; &quot;)
}
// Prints: &quot;0 1 2 8 9 15 16&quot;</code></pre>

<p><strong>Returns:</strong> A flattened view of the elements of this
  sequence of sequences.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined() -&gt; FlattenSequence&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-element_-sequence-joined_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-sequence-joined_">func joined(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-sequence-joined_"><div class="p">
    <p>Returns the concatenated elements of this sequence of sequences,
inserting the given separator between each element.</p>

<p>This example shows how an array of <code>[Int]</code> instances can be joined, using
another <code>[Int]</code> instance as the separator:</p>

<pre><code class="language-swift">let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
let joined = nestedNumbers.joined(separator: [-1, -2])
print(Array(joined))
// Prints &quot;[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]&quot;</code></pre>

<p><strong><code>separator</code>:</strong>  A sequence to insert between each of this
  sequence&#39;s elements.
<strong>Returns:</strong> The joined sequence of elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined&lt;Separator&gt;(separator: Separator) -&gt; JoinedSequence&lt;Array&lt;Element&gt;&gt; where Separator : Sequence, Separator.Element == Array&lt;Element&gt;.Element.Element</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Element : StringProtocol</h4>




<div class="declaration inherited" id="func-element_-stringprotocol-joined_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-element_-stringprotocol-joined_">func joined(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-element_-stringprotocol-joined_"><div class="p">
    <p>Returns a new string by concatenating the elements of the sequence,
adding the given separator between each element.</p>

<p>The following example shows how an array of strings can be joined to a
single, comma-separated string:</p>

<pre><code class="language-swift">let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]
let list = cast.joined(separator: &quot;, &quot;)
print(list)
// Prints &quot;Vivien, Marlon, Kim, Karl&quot;</code></pre>

<p><strong><code>separator</code>:</strong>  A string to insert between each of the elements
  in this sequence. The default separator is an empty string.
<strong>Returns:</strong> A single, concatenated string.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func joined(separator: String = default) -&gt; String</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where Index : Strideable, Indices == Range<Index>, Index.Stride == Int</h4>


<div class="declaration inherited" id="index_-strideable-indices-range-index-index-stride-int-var-indices_-range-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-index_-strideable-indices-range-index-index-stride-int-var-indices_-range-self-index">var indices: Range&lt;Array&lt;Element&gt;.Index&gt;</a><div class="comment collapse" id="comment-index_-strideable-indices-range-index-index-stride-int-var-indices_-range-self-index"><div class="p">
    <p>The indices that are valid for subscripting the collection, in ascending
order.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">var indices: Range&lt;Array&lt;Element&gt;.Index&gt; { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>
        </div></div>
</div>


<div class="declaration inherited" id="func-index_-strideable-indices-range-index-index-stride-int-distance-from_to_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-strideable-indices-range-index-index-stride-int-distance-from_to_">func distance(<wbr>from:<wbr>to:)</a>
        
<div class="comment collapse" id="comment-func-index_-strideable-indices-range-index-index-stride-int-distance-from_to_"><div class="p">
    <p>Returns the distance between two indices.</p>

<p><strong>Parameters:</strong>
  <strong>start:</strong> A valid index of the collection.
  <strong>end:</strong> Another valid index of the collection. If <code>end</code> is equal to
    <code>start</code>, the result is zero.
<strong>Returns:</strong> The distance between <code>start</code> and <code>end</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func distance(from start: Array&lt;Element&gt;.Index, to end: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.Index.Stride</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-strideable-indices-range-index-index-stride-int-index_offsetby_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-strideable-indices-range-index-index-stride-int-index_offsetby_">func index(<wbr>_:<wbr>offsetBy:)</a>
        
<div class="comment collapse" id="comment-func-index_-strideable-indices-range-index-index-stride-int-index_offsetby_"><div class="p">
    <p>Returns an index that is the specified distance from the given index.</p>

<p>The following example obtains an index advanced four positions from an
array&#39;s starting index and then prints the element at that position.</p>

<pre><code class="language-swift">let numbers = [10, 20, 30, 40, 50]
let i = numbers.index(numbers.startIndex, offsetBy: 4)
print(numbers[i])
// Prints &quot;50&quot;</code></pre>

<p>The value passed as <code>n</code> must not offset <code>i</code> beyond the bounds of the
collection.</p>

<p><strong>Parameters:</strong>
  <strong>i:</strong> A valid index of the collection.
  <strong>n:</strong> The distance to offset <code>i</code>.
<strong>Returns:</strong> An index offset by <code>n</code> from the index <code>i</code>. If <code>n</code> is positive,
  this is the same value as the result of <code>n</code> calls to <code>index(after:)</code>.
  If <code>n</code> is negative, this is the same value as the result of <code>-n</code> calls
  to <code>index(before:)</code>.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(_ i: Array&lt;Element&gt;.Index, offsetBy n: Array&lt;Element&gt;.Index.Stride) -&gt; Array&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-strideable-indices-range-index-index-stride-int-index-after_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-strideable-indices-range-index-index-stride-int-index-after_">func index(<wbr>after:)</a>
        
<div class="comment collapse" id="comment-func-index_-strideable-indices-range-index-index-stride-int-index-after_"><div class="p">
    <p>Returns the position immediately after the given index.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be less than
  <code>endIndex</code>.
<strong>Returns:</strong> The index value immediately after <code>i</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(after i: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-index_-strideable-indices-range-index-index-stride-int-index-before_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-index_-strideable-indices-range-index-index-stride-int-index-before_">func index(<wbr>before:)</a>
        
<div class="comment collapse" id="comment-func-index_-strideable-indices-range-index-index-stride-int-index-before_"><div class="p">
    <p>Returns the position immediately after the given index.</p>

<p><strong><code>i</code>:</strong>  A valid index of the collection. <code>i</code> must be greater than
  <code>startIndex</code>.
<strong>Returns:</strong> The index value immediately before <code>i</code>.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func index(before i: Array&lt;Element&gt;.Index) -&gt; Array&lt;Element&gt;.Index</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/RandomAccessCollection/"><code>RandomAccessCollection</code></a>    
</div></div>
</div>





<h4>Where Indices == DefaultIndices<Self></h4>


<div class="declaration inherited" id="indices-defaultindices-self-var-indices_-defaultindices-self">
<a class="toggle-link" data-toggle="collapse" href="#comment-indices-defaultindices-self-var-indices_-defaultindices-self">var indices: DefaultIndices&lt;Array&lt;Element&gt;&gt;</a><div class="comment collapse" id="comment-indices-defaultindices-self-var-indices_-defaultindices-self"><div class="p">
    <p>The indices that are valid for subscripting the collection, in ascending
order.</p>

<p>A collection&#39;s <code>indices</code> property can hold a strong reference to the
collection itself, causing the collection to be non-uniquely referenced.
If you mutate the collection while iterating over its indices, a strong
reference can cause an unexpected copy of the collection. To avoid the
unexpected copy, use the <code>index(after:)</code> method starting with
<code>startIndex</code> to produce indices instead.</p>

<pre><code class="language-swift">var c = MyFancyCollection([10, 20, 30, 40, 50])
var i = c.startIndex
while i != c.endIndex {
    c[i] /= 5
    i = c.index(after: i)
}
// c == MyFancyCollection([2, 4, 6, 8, 10])</code></pre>

    <h4>Declaration</h4>    
    <code class="language-swift">var indices: DefaultIndices&lt;Array&lt;Element&gt;&gt; { get }</code>

        <h4>Declared In</h4>
            <a href="../../protocol/Collection/"><code>Collection</code></a>
        </div></div>
</div>







<h4>Where Iterator == IndexingIterator<Self></h4>




<div class="declaration inherited" id="func-iterator-indexingiterator-self-makeiterator">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-iterator-indexingiterator-self-makeiterator">func makeIterator()</a>
        
<div class="comment collapse" id="comment-func-iterator-indexingiterator-self-makeiterator"><div class="p">
    <p>Returns an iterator over the elements of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func makeIterator() -&gt; IndexingIterator&lt;Array&lt;Element&gt;&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>





<h4>Where SubSequence == AnySequence<Element></h4>




<div class="declaration inherited" id="func-subsequence-anysequence-element-drop-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-drop-while_">func drop(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-drop-while_"><div class="p">
    <p>Returns a subsequence by skipping the initial, consecutive elements that
satisfy the given predicate.</p>

<p>The following example uses the <code>drop(while:)</code> method to skip over the
positive numbers at the beginning of the <code>numbers</code> array. The result
begins with the first element of <code>numbers</code> that does not satisfy
<code>predicate</code>.</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
let startingWithNegative = numbers.drop(while: { $0 &gt; 0 })
// startingWithNegative == [-2, 9, -6, 10, 1]</code></pre>

<p>If <code>predicate</code> matches every element in the sequence, the result is an
empty sequence.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element should be included in the result.
<strong>Returns:</strong> A subsequence starting after the initial, consecutive elements
  that satisfy <code>predicate</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func drop(while predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-dropfirst_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-dropfirst_">func dropFirst(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-dropfirst_"><div class="p">
    <p>Returns a subsequence containing all but the given number of initial
elements.</p>

<p>If the number of elements to drop exceeds the number of elements in
the sequence, the result is an empty subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropFirst(2))
// Prints &quot;[3, 4, 5]&quot;
print(numbers.dropFirst(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop from the beginning of
  the sequence. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting after the specified number of
  elements.</p>

<p><strong>Complexity:</strong> O(1).</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropFirst(_ n: Int) -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-droplast_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-droplast_">func dropLast(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-droplast_"><div class="p">
    <p>Returns a subsequence containing all but the given number of final
elements.</p>

<p>The sequence must be finite. If the number of elements to drop exceeds
the number of elements in the sequence, the result is an empty
subsequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.dropLast(2))
// Prints &quot;[1, 2, 3]&quot;
print(numbers.dropLast(10))
// Prints &quot;[]&quot;</code></pre>

<p><strong><code>n</code>:</strong>  The number of elements to drop off the end of the
  sequence. <code>n</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence leaving off the specified number of elements.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func dropLast(_ n: Int) -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-prefix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-prefix_">func prefix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-prefix_"><div class="p">
    <p>Returns a subsequence, up to the specified maximum length, containing the
initial elements of the sequence.</p>

<p>If the maximum length exceeds the number of elements in the sequence,
the result contains all the elements in the sequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.prefix(2))
// Prints &quot;[1, 2]&quot;
print(numbers.prefix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The
  value of <code>maxLength</code> must be greater than or equal to zero.
<strong>Returns:</strong> A subsequence starting at the beginning of this sequence
  with at most <code>maxLength</code> elements.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(_ maxLength: Int) -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-prefix-while_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-prefix-while_">func prefix(<wbr>while:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-prefix-while_"><div class="p">
    <p>Returns a subsequence containing the initial, consecutive elements that
satisfy the given predicate.</p>

<p>The following example uses the <code>prefix(while:)</code> method to find the
positive numbers at the beginning of the <code>numbers</code> array. Every element
of <code>numbers</code> up to, but not including, the first negative value is
included in the result.</p>

<pre><code class="language-swift">let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
let positivePrefix = numbers.prefix(while: { $0 &gt; 0 })
// positivePrefix == [3, 7, 4]</code></pre>

<p>If <code>predicate</code> matches every element in the sequence, the resulting
sequence contains every element of the sequence.</p>

<p><strong><code>predicate</code>:</strong>  A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element should be included in the result.
<strong>Returns:</strong> A subsequence of the initial, consecutive elements that
  satisfy <code>predicate</code>.</p>

<p><strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the collection.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func prefix(while predicate: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_">func split(<wbr>_:<wbr>omittingEmptySubsequences:<wbr>whereSeparator:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-split_omittingemptysubsequences_whereseparator_"><div class="p">
    <p>Returns the longest possible subsequences of the sequence, in order, that
don&#39;t contain elements satisfying the given predicate. Elements that are
used to split the sequence are not returned as part of any subsequence.</p>

<p>The following examples show the effects of the <code>maxSplits</code> and
<code>omittingEmptySubsequences</code> parameters when splitting a string using a
closure that matches spaces. The first use of <code>split</code> returns each word
that was originally separated by one or more spaces.</p>

<pre><code class="language-swift">let line = &quot;BLANCHE:   I don&#39;t want realism. I want magic!&quot;
print(line.split(whereSeparator: { $0 == &quot; &quot; })
          .map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p>The second example passes <code>1</code> for the <code>maxSplits</code> parameter, so the
original string is split just once, into two new strings.</p>

<pre><code class="language-swift">print(
   line.split(maxSplits: 1, whereSeparator: { $0 == &quot; &quot; })
                  .map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;  I don\&#39;t want realism. I want magic!&quot;]&quot;</code></pre>

<p>The final example passes <code>true</code> for the <code>allowEmptySlices</code> parameter, so
the returned array contains empty strings where spaces were repeated.</p>

<pre><code class="language-swift">print(
    line.split(
        omittingEmptySubsequences: false,
        whereSeparator: { $0 == &quot; &quot; }
    ).map(String.init))
// Prints &quot;[&quot;BLANCHE:&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;don\&#39;t&quot;, &quot;want&quot;, &quot;realism.&quot;, &quot;I&quot;, &quot;want&quot;, &quot;magic!&quot;]&quot;</code></pre>

<p><strong>Parameters:</strong>
  <strong>maxSplits:</strong> The maximum number of times to split the sequence, or one
    less than the number of subsequences to return. If <code>maxSplits + 1</code>
    subsequences are returned, the last one is a suffix of the original
    sequence containing the remaining elements. <code>maxSplits</code> must be
    greater than or equal to zero. The default value is <code>Int.max</code>.
  <strong>omittingEmptySubsequences:</strong> If <code>false</code>, an empty subsequence is
    returned in the result for each pair of consecutive elements
    satisfying the <code>isSeparator</code> predicate and for each element at the
    start or end of the sequence satisfying the <code>isSeparator</code> predicate.
    If <code>true</code>, only nonempty subsequences are returned. The default
    value is <code>true</code>.
  <strong>isSeparator:</strong> A closure that returns <code>true</code> if its argument should be
    used to split the sequence; otherwise, <code>false</code>.
<strong>Returns:</strong> An array of subsequences, split from this sequence&#39;s elements.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Array&lt;Element&gt;.Element) throws -&gt; Bool) rethrows -&gt; [AnySequence&lt;Array&lt;Element&gt;.Element&gt;]</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>
<div class="declaration inherited" id="func-subsequence-anysequence-element-suffix_">
<a class="toggle-link" data-toggle="collapse" href="#comment-func-subsequence-anysequence-element-suffix_">func suffix(<wbr>_:)</a>
        
<div class="comment collapse" id="comment-func-subsequence-anysequence-element-suffix_"><div class="p">
    <p>Returns a subsequence, up to the given maximum length, containing the
final elements of the sequence.</p>

<p>The sequence must be finite. If the maximum length exceeds the number of
elements in the sequence, the result contains all the elements in the
sequence.</p>

<pre><code class="language-swift">let numbers = [1, 2, 3, 4, 5]
print(numbers.suffix(2))
// Prints &quot;[4, 5]&quot;
print(numbers.suffix(10))
// Prints &quot;[1, 2, 3, 4, 5]&quot;</code></pre>

<p><strong><code>maxLength</code>:</strong>  The maximum number of elements to return. The
  value of <code>maxLength</code> must be greater than or equal to zero.
<strong>Complexity:</strong> O(<em>n</em>), where <em>n</em> is the length of the sequence.</p>

    <h4>Declaration</h4>    
    <code class="language-swift">func suffix(_ maxLength: Int) -&gt; AnySequence&lt;Array&lt;Element&gt;.Element&gt;</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Sequence/"><code>Sequence</code></a>    
</div></div>
</div>





<h4>Where SubSequence == Slice<Self></h4>



<div class="declaration inherited" id="subscript-subsequence-slice-self-subscript_-range-self-index">
<a class="toggle-link" data-toggle="collapse" href="#comment-subscript-subsequence-slice-self-subscript_-range-self-index">subscript(_: Range&lt;Array&lt;Element&gt;.Index&gt;)</a>
<div class="comment collapse" id="comment-subscript-subsequence-slice-self-subscript_-range-self-index"><div class="p">
    <p>Accesses a contiguous subrange of the collection&#39;s elements.</p>

<p>The accessed slice uses the same indices for the same elements as the
original collection. Always use the slice&#39;s <code>startIndex</code> property
instead of assuming that its indices start at a particular value.</p>

<p>This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.</p>

<pre><code class="language-swift">let streets = [&quot;Adams&quot;, &quot;Bryant&quot;, &quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]
let streetsSlice = streets[2 ..&lt; streets.endIndex]
print(streetsSlice)
// Prints &quot;[&quot;Channing&quot;, &quot;Douglas&quot;, &quot;Evarts&quot;]&quot;

let index = streetsSlice.firstIndex(of: &quot;Evarts&quot;)    // 4
print(streets[index!])
// Prints &quot;Evarts&quot;</code></pre>

<p><strong><code>bounds</code>:</strong>  A range of the collection&#39;s indices. The bounds of
  the range must be valid indices of the collection.</p>

<p><strong>Complexity:</strong> O(1)</p>

    <h4>Declaration</h4>    
    <code class="language-swift">subscript(bounds: Range&lt;Array&lt;Element&gt;.Index&gt;) -&gt; Slice&lt;Array&lt;Element&gt;&gt; { get }</code>
    
        <h4>Declared In</h4>
        <a href="../../protocol/Collection/"><code>Collection</code></a>    
</div></div>
</div>




