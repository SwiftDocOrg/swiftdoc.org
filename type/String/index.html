---
layout: "default"
title: "String"
description: "Swift documentation for 'String': An arbitrary Unicode string value."
keywords: "String,struct,swift,documentation,generate,fromCString,fromCStringRepairingIllFormedUTF8,withCString,getMirror,write,writeTo,extend,append,reserveCapacity,append,extend,join,replaceRange,insert,splice,removeAtIndex,removeRange,removeAll,hasPrefix,hasSuffix,toInt,availableStringEncodings,defaultCStringEncoding,localizedNameOfStringEncoding,localizedStringWithFormat,pathWithComponents,canBeConvertedToEncoding,capitalizedStringWithLocale,caseInsensitiveCompare,commonPrefixWithString,compare,completePathIntoString,componentsSeparatedByCharactersInSet,componentsSeparatedByString,cStringUsingEncoding,dataUsingEncoding,enumerateLines,enumerateLinguisticTagsInRange,enumerateSubstringsInRange,fileSystemRepresentation,getBytes,getCString,getFileSystemRepresentation,getLineStart,getParagraphStart,lengthOfBytesUsingEncoding,lineRangeForRange,linguisticTagsInRange,localizedCaseInsensitiveCompare,localizedCompare,localizedStandardCompare,lowercaseStringWithLocale,maximumLengthOfBytesUsingEncoding,paragraphRangeForRange,propertyList,propertyListFromStringsFileFormat,rangeOfCharacterFromSet,rangeOfComposedCharacterSequenceAtIndex,rangeOfComposedCharacterSequencesForRange,rangeOfString,stringByAddingPercentEncodingWithAllowedCharacters,stringByAddingPercentEscapesUsingEncoding,stringByAppendingFormat,stringByAppendingPathComponent,stringByAppendingPathExtension,stringByAppendingString,stringByFoldingWithOptions,stringByPaddingToLength,stringByReplacingCharactersInRange,stringByReplacingOccurrencesOfString,stringByReplacingPercentEscapesUsingEncoding,stringByTrimmingCharactersInSet,stringsByAppendingPaths,substringFromIndex,substringToIndex,substringWithRange,uppercaseStringWithLocale,writeToFile,writeToURL,startIndex,endIndex,utf16,utf8,nulTerminatedUTF8,debugDescription,hashValue,lowercaseString,uppercaseString,isEmpty,unicodeScalars,capitalizedString,decomposedStringWithCanonicalMapping,decomposedStringWithCompatibilityMapping,fastestEncoding,hash,lastPathComponent,utf16Count,pathComponents,pathExtension,precomposedStringWithCanonicalMapping,precomposedStringWithCompatibilityMapping,smallestEncoding,stringByAbbreviatingWithTildeInPath,stringByDeletingLastPathComponent,stringByDeletingPathExtension,stringByExpandingTildeInPath,stringByRemovingPercentEncoding,stringByResolvingSymlinksInPath,stringByStandardizingPath,UTF16Index,UTF8Index,UnicodeScalarIndex"
---

<code class="language-swift">struct String { ... }</code>

<div class="comment">
    <p>An arbitrary Unicode string value.</p>

<h1>Unicode-Correct</h1>

<p>Swift strings are designed to be Unicode-correct.  In particular,
the APIs make it easy to write code that works correctly, and does
not surprise end-users, regardless of where you venture in the
Unicode character space.  For example,</p>

<ul><li><p>The <code>==</code> operator checks for <a href="http://www.unicode.org/glossary/#deterministic_comparison">Unicode canonical equivalence</a>,
so two different representations of the same string will always
compare equal.</p></li><li><p>String elements are <code>Characters</code> (<a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme clusters</a>),
a unit of text that is meaningful to most humans.</p></li></ul>

<h1>Locale-Insensitive</h1>

<p>The fundamental operations on Swift strings are not sensitive to
locale settings.  That&#39;s because, for example, the validity of a
<code>Dictionary&lt;String, T&gt;</code> in a running program depends on a given
string comparison having a single, stable result.  Therefore,
Swift always uses the default, un-<a href="http://www.unicode.org/glossary/#tailorable">tailored</a> Unicode algorithms
for basic string operations.</p>

<p>Importing <code>Foundation</code> endows swift strings with the full power of
the <code>NSString</code> API, which allows you to choose more complex
locale-sensitive operations explicitly.</p>

<h1>Value Semantics</h1>

<p>Each string variable, <code>let</code> binding, or stored property has an
independent value, so mutations to the string are not observable
through its copies:</p>

<pre><code class="language-swift">var a = &quot;foo&quot;
var b = a
b[b.endIndex.predecessor()] = &quot;x&quot;
println(&quot;a=\(a), b=\(b)&quot;)     // a=foo, b=fox</code></pre>

<p>Strings use Copy-on-Write so that their data is only copied
lazily, upon mutation, when more than one string instance is using
the same buffer.  Therefore, the first in any sequence of mutating
operations may cost <code>O(N)</code> time and space, where <code>N</code> is the length
of the string&#39;s (unspecified) underlying representation,.</p>

<h1>Growth and Capacity</h1>

<p>When a string&#39;s contiguous storage fills up, new storage must be
allocated and characters must be moved to the new storage.
<code>String</code> uses an exponential growth strategy that makes <code>append</code> a
constant time operation <em>when amortized over many invocations</em>.</p>

<h1>Objective-C Bridge</h1>

<p><code>String</code> is bridged to Objective-C as <code>NSString</code>, and a <code>String</code>
that originated in Objective-C may store its characters in an
<code>NSString</code>.  Since any arbitrary subclass of <code>NSSString</code> can
become a <code>String</code>, there are no guarantees about representation or
efficiency in this case.  Since <code>NSString</code> is immutable, it is
just as though the storage was shared by some copy: the first in
any sequence of mutating operations causes elements to be copied
into unique, contiguous storage which may cost <code>O(N)</code> time and
space, where <code>N</code> is the length of the string representation (or
more, if the underlying <code>NSString</code> is has unusual performance
characteristics).</p>
</div>

<h3>Inheritance</h3>
<code class="inherits">CollectionType, Reflectable, OutputStreamType, Streamable, UnicodeScalarLiteralConvertible, ExtendedGraphemeClusterLiteralConvertible, StringLiteralConvertible, DebugPrintable, Equatable, Comparable, Hashable, StringInterpolationConvertible, Sliceable, ExtensibleCollectionType, RangeReplaceableCollectionType</code>
<span class="viz"><a href="hierarchy/">Protocol hierarchy</a></span>

<h3>Associated types</h3>
<div class="declaration">
<code class="language-swift">typealias UTF16Index = String.UTF16View.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>utf16</code> view.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UTF8Index = String.UTF8View.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>.utf8</code> view.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UnicodeScalarIndex = String.UnicodeScalarView.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>.unicodeScalars</code>
view.</p>
</div>
</div>

<h3>Nested types</h3>
<code class="nested">String.Index, String.UTF16View, String.UTF8View, String.UnicodeScalarView, String.UTF16View.Index, String.UTF8View.Index, String.UnicodeScalarView.Index, String.UnicodeScalarView.Generator</code>


<h3>Initializers</h3>
<div class="declaration">
<code class="language-swift">init()</code>
</div>
<div class="declaration">
<code class="language-swift">init?(_ utf16: String.UTF16View)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
UTF-16 code units.  If <code>utf16</code> contains unpaired surrogates, the
result is <code>nil</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(_ utf8: String.UTF8View)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
UTF-8 code units.  If <code>utf8</code> contains unpaired surrogates, the
result is <code>nil</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ unicodeScalars: String.UnicodeScalarView)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
Unicode scalars.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ c: Character)</code>
<div class="comment">
    <p>Construct an instance containing just the given <code>Character</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinUnicodeScalarLiteral value: Builtin.Int32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(unicodeScalarLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, byteSize: Builtin.Word, isASCII: Builtin.Int1)</code>
</div>
<div class="declaration">
<code class="language-swift">init(extendedGraphemeClusterLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinUTF16StringLiteral start: Builtin.RawPointer, numberOfCodeUnits: Builtin.Word)</code>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinStringLiteral start: Builtin.RawPointer, byteSize: Builtin.Word, isASCII: Builtin.Int1)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolation strings: String...)</code>
<div class="comment">
    <p>Create an instance by concatenating the elements of <code>strings</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T&gt;(stringInterpolationSegment expr: T)</code>
<div class="comment">
    <p>Create an instance containing <code>expr</code>&#39;s <code>print</code> representation</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;S : SequenceType where Character == Character&gt;(_ characters: S)</code>
<div class="comment">
    <p>Create an instance containing <code>characters</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: String)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Character)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UnicodeScalar)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Bool)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Float32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Float64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt8)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int8)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt16)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int16)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int)</code>
</div>
<div class="declaration">
<code class="language-swift">init(count: Int, repeatedValue c: Character)</code>
<div class="comment">
    <p>Construct an instance that is the concatenation of <code>count</code> copies
of <code>repeatedValue</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(count: Int, repeatedValue c: UnicodeScalar)</code>
<div class="comment">
    <p>Construct an instance that is the concatenation of <code>count</code> copies
of <code>Character(repeatedValue)</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _SignedIntegerType&gt;(_ v: T)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in base 10.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _UnsignedIntegerType&gt;(_ v: T)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in base 10.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _SignedIntegerType&gt;(_ v: T, radix: Int, uppercase: Bool = default)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in the given <code>radix</code> (base).</p>

<p>Numerals greater than 9 are represented as roman letters,
starting with <code>a</code> if <code>uppercase</code> is <code>false</code> or <code>A</code> otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _UnsignedIntegerType&gt;(_ v: T, radix: Int, uppercase: Bool = default)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in the given <code>radix</code> (base).</p>

<p>Numerals greater than 9 are represented as roman letters,
starting with <code>a</code> if <code>uppercase</code> is <code>false</code> or <code>A</code> otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(contentsOfFile path: String, encoding enc: NSStringEncoding, error: NSErrorPointer = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from the file at a
given path interpreted using a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(contentsOfFile path: String, usedEncoding: UnsafeMutablePointer&lt;NSStringEncoding&gt; = default, error: NSErrorPointer = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from the file at
a given path and returns by reference the encoding used to
interpret the file.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(contentsOfURL url: NSURL, encoding enc: NSStringEncoding, error: NSErrorPointer = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from a given URL
interpreted using a given encoding.  Errors are written into the
inout <code>error</code> argument.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(contentsOfURL url: NSURL, usedEncoding enc: UnsafeMutablePointer&lt;NSStringEncoding&gt; = default, error: NSErrorPointer = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from a given URL
and returns by reference the encoding used to interpret the
data.  Errors are written into the inout <code>error</code> argument.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(CString: UnsafePointer&lt;CChar&gt;, encoding enc: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string containing the bytes in a given C array,
interpreted according to a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(UTF8String bytes: UnsafePointer&lt;CChar&gt;)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by copying the data from a given
C array of UTF8-encoded bytes.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?&lt;S : SequenceType where UInt8 == UInt8&gt;(bytes: S, encoding: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces an initialized <code>NSString</code> object equivalent to the given
<code>bytes</code> interpreted in the given <code>encoding</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(bytesNoCopy bytes: UnsafeMutablePointer&lt;Void&gt;, length: Int, encoding: NSStringEncoding, freeWhenDone flag: Bool)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces an initialized <code>String</code> object that contains a
given number of bytes from a given buffer of bytes interpreted
in a given encoding, and optionally frees the buffer.  WARNING:
this initializer is not memory-safe!</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(utf16CodeUnits: UnsafePointer&lt;unichar&gt;, count: Int)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an initialized <code>String</code> object that contains a
given number of characters from a given array of Unicode
characters.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(utf16CodeUnitsNoCopy: UnsafePointer&lt;unichar&gt;, count: Int, freeWhenDone flag: Bool)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an initialized <code>String</code> object that contains a given
number of characters from a given array of UTF-16 Code Units</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, _ arguments: CVarArgType...)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, arguments: [CVarArgType])</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to the user’s default locale.
 </p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, locale: NSLocale?, _ args: CVarArgType...)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to given locale information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, locale: NSLocale?, arguments: [CVarArgType])</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to given locale information.</p>
</div>
</div>


<h3>Instance Variables</h3>
<div class="declaration">
<code class="language-swift">var startIndex: String.Index { get }</code>
<div class="comment">
    <p>The position of the first <code>Character</code> if the <code>String</code> is
non-empty; identical to <code>endIndex</code> otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var endIndex: String.Index { get }</code>
<div class="comment">
    <p>The <code>String</code>&#39;s &quot;past the end&quot; position.</p>

<p><code>endIndex</code> is not a valid argument to <code>subscript</code>, and is always
reachable from <code>startIndex</code> by zero or more applications of
<code>successor()</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var utf16: String.UTF16View { get }</code>
<div class="comment">
    <p>A UTF-16 encoding of <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var utf8: String.UTF8View { get }</code>
<div class="comment">
    <p>A UTF-8 encoding of <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var nulTerminatedUTF8: ContiguousArray&lt;CodeUnit&gt; { get }</code>
<div class="comment">
    <p>A contiguously-stored nul-terminated UTF-8 representation of
<code>self</code>.</p>

<p>To access the underlying memory, invoke
<code>withUnsafeBufferPointer</code> on the <code>ContiguousArray</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var debugDescription: String { get }</code>
<div class="comment">
    <p>A textual representation of <code>self</code>, suitable for debugging.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var hashValue: Int { get }</code>
<div class="comment">
    <p>The hash value.</p>

<p><strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code></p>

<p><strong>Note:</strong> the hash value is not guaranteed to be stable across
different invocations of the same program.  Do not persist the
hash value across program runs.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var lowercaseString: String { get }</code>
</div>
<div class="declaration">
<code class="language-swift">var uppercaseString: String { get }</code>
</div>
<div class="declaration">
<code class="language-swift">var isEmpty: Bool { get }</code>
<div class="comment">
    <p><code>true</code> iff <code>self</code> contains no characters.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var unicodeScalars: String.UnicodeScalarView { get set }</code>
<div class="comment">
    <p>The value of <code>self</code> as a collection of <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar values</a>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var capitalizedString: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Produce a string with the first character from each word changed
to the corresponding uppercase value.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var decomposedStringWithCanonicalMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form D.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var decomposedStringWithCompatibilityMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form KD.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var fastestEncoding: NSStringEncoding { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the fastest encoding to which the <code>String</code> may be
converted without loss of information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var hash: Int { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> An unsigned integer that can be used as a hash table address.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var lastPathComponent: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the last path component of the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var utf16Count: Int { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the number of Unicode characters in the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var pathComponents: [String] { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array of NSString objects containing, in
order, each path component of the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var pathExtension: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Interprets the <code>String</code> as a path and returns the
<code>String</code>’s extension, if any.
 </p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var precomposedStringWithCanonicalMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form C.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var precomposedStringWithCompatibilityMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form KC.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var smallestEncoding: NSStringEncoding { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the smallest encoding to which the <code>String</code> can
be converted without loss of information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByAbbreviatingWithTildeInPath: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string that replaces the current home
directory portion of the current path with a tilde (<code>~</code>)
character.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByDeletingLastPathComponent: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by deleting the last path
component from the <code>String</code>, along with any final path
separator.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByDeletingPathExtension: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by deleting the extension (if
any, and only the last) from the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByExpandingTildeInPath: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by expanding the initial
component of the <code>String</code> to its full path value.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByRemovingPercentEncoding: String? { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made from the <code>String</code> by replacing
all percent encoded sequences with the matching UTF-8
characters.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByResolvingSymlinksInPath: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made from the <code>String</code> by resolving
all symbolic links and standardizing path.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">var stringByStandardizingPath: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by removing extraneous path
components from the <code>String</code>.</p>
</div>
</div>

<h3>Static Methods</h3>
<div class="declaration">
<code class="language-swift">static func fromCString(cs: UnsafePointer&lt;CChar&gt;) -> String?</code>
<div class="comment">
    <p>Creates a new <code>String</code> by copying the nul-terminated UTF-8 data
referenced by a <code>CString</code>.</p>

<p>Returns <code>nil</code> if the <code>CString</code> is <code>NULL</code> or if it contains ill-formed
UTF-8 code unit sequences.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func fromCStringRepairingIllFormedUTF8(cs: UnsafePointer&lt;CChar&gt;) -> (String?, hadError: Bool)</code>
<div class="comment">
    <p>Creates a new <code>String</code> by copying the nul-terminated UTF-8 data
referenced by a <code>CString</code>.</p>

<p>Returns <code>nil</code> if the <code>CString</code> is <code>NULL</code>.  If <code>CString</code> contains
ill-formed UTF-8 code unit sequences, replaces them with replacement
characters (U+FFFD).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func availableStringEncodings() -> [NSStringEncoding]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an Array of the encodings string objects support
in the application’s environment.
 </p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func defaultCStringEncoding() -> NSStringEncoding</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the C-string encoding assumed for any method accepting
a C string as an argument.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func localizedNameOfStringEncoding(encoding: NSStringEncoding) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a human-readable string giving the name of a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func localizedStringWithFormat(format: String, _ arguments: CVarArgType...) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string created by using a given format string as a
template into which the remaining argument values are substituted
according to the user&#39;s default locale.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">static func pathWithComponents(components: [String]) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string built from the strings in a given array
by concatenating them with a path separator between each pair.</p>
</div>
</div>

<h3>Instance Methods</h3>
<div class="declaration">
<code class="language-swift">func generate() -> IndexingGenerator&lt;String&gt;</code>
<div class="comment">
    <p>Return a <em>generator</em> over the <code>Characters</code> in this <code>String</code>.</p>

<p>Complexity: O(1)</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func withCString&lt;Result&gt;(f: @noescape UnsafePointer&lt;Int8&gt; -&gt; Result) -> Result</code>
<div class="comment">
    <p>Invoke <code>f</code> on the contents of this string, represented as
a nul-terminated array of char, ensuring that the array&#39;s
lifetime extends through the execution of <code>f</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getMirror() -> MirrorType</code>
<div class="comment">
    <p>Returns a mirror that reflects <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func write(other: String)</code>
<div class="comment">
    <p>Append <code>other</code> to this stream.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func writeTo&lt;Target : OutputStreamType&gt;(inout target: Target)</code>
<div class="comment">
    <p>Write a textual representation of <code>self</code> into <code>target</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func extend(other: String)</code>
<div class="comment">
    <p>Append the elements of <code>other</code> to <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func append(x: UnicodeScalar)</code>
<div class="comment">
    <p>Append <code>x</code> to <code>self</code>.</p>

<p>Complexity: amortized O(1).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func reserveCapacity(n: Int)</code>
<div class="comment">
    <p>Reserve enough space to store <code>n</code> ASCII characters.</p>

<p>Complexity: O(<code>n</code>)</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func append(c: Character)</code>
<div class="comment">
    <p>Append <code>c</code> to <code>self</code>.</p>

<p>Complexity: amortized O(1).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func extend&lt;S : SequenceType where Character == Character&gt;(newElements: S)</code>
<div class="comment">
    <p>Append the elements of <code>newElements</code> to <code>self</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func join&lt;S : SequenceType where String == String&gt;(elements: S) -> String</code>
<div class="comment">
    <p>Interpose <code>self</code> between every pair of consecutive <code>elements</code>,
then concatenate the result.  For example:</p>

<pre><code class="language-swift">&quot;-|-&quot;.join([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]) // &quot;foo-|-bar-|-baz&quot;</code></pre>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func replaceRange&lt;C : CollectionType where Character == Character&gt;(subRange: Range&lt;String.Index&gt;, with newElements: C)</code>
<div class="comment">
    <p>Replace the given <code>subRange</code> of elements with <code>newElements</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p>Complexity: O(<code>count(subRange)</code>) if <code>subRange.endIndex
== self.endIndex</code> and <code>isEmpty(newElements)</code>, O(N) otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func insert(newElement: Character, atIndex i: String.Index)</code>
<div class="comment">
    <p>Insert <code>newElement</code> at index <code>i</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p>Complexity: O(<code>count(self)</code>).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func splice&lt;S : CollectionType where Character == Character&gt;(newElements: S, atIndex i: String.Index)</code>
<div class="comment">
    <p>Insert <code>newElements</code> at index <code>i</code></p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p>Complexity: O(<code>count(self) + count(newElements)</code>).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func removeAtIndex(i: String.Index) -> Character</code>
<div class="comment">
    <p>Remove and return the element at index <code>i</code></p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p>Complexity: O(<code>count(self)</code>).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func removeRange(subRange: Range&lt;String.Index&gt;)</code>
<div class="comment">
    <p>Remove the indicated <code>subRange</code> of characters</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p>Complexity: O(<code>count(self)</code>).</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">mutating func removeAll(keepCapacity: Bool = default)</code>
<div class="comment">
    <p>Remove all characters.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong><code>keepCapacity</code></strong>, if <code>true</code>, prevents the release of
  allocated storage, which can be a useful optimization
  when <code>self</code> is going to be grown again.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func hasPrefix(prefix: String) -> Bool</code>
<div class="comment">
    <p>Return <code>true</code> iff <code>self</code> begins with <code>prefix</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func hasSuffix(suffix: String) -> Bool</code>
<div class="comment">
    <p>Return <code>true</code> iff <code>self</code> ends with <code>suffix</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func toInt() -> Int?</code>
<div class="comment">
    <p>If the string represents an integer that fits into an Int, returns
the corresponding integer.  This accepts strings that match the regular
expression &quot;[-+]?[0-9]+&quot; only.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func canBeConvertedToEncoding(encoding: NSStringEncoding) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a Boolean value that indicates whether the
<code>String</code> can be converted to a given encoding without loss of
information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func capitalizedStringWithLocale(locale: NSLocale?) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a capitalized representation of the <code>String</code>
using the specified locale.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func caseInsensitiveCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the result of invoking <code>compare:options:</code> with
<code>NSCaseInsensitiveSearch</code> as the only option.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func commonPrefixWithString(aString: String, options: NSStringCompareOptions) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string containing characters the <code>String</code> and a
given string have in common, starting from the beginning of each
up to the first characters that aren’t equivalent.
 </p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func compare(aString: String, options mask: NSStringCompareOptions = default, range: Range&lt;String.Index&gt;? = default, locale: NSLocale? = default) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string using the specified options and
returns the lexical ordering for the range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func completePathIntoString(_ outputName: UnsafeMutablePointer&lt;String&gt; = default, caseSensitive: Bool, matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt; = default, filterTypes: [String]? = default) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Interprets the <code>String</code> as a path in the file system and
attempts to perform filename completion, returning a numeric
value that indicates whether a match was possible, and by
reference the longest path that matches the <code>String</code>.
Returns the actual number of matching paths.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func componentsSeparatedByCharactersInSet(separator: NSCharacterSet) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array containing substrings from the <code>String</code>
that have been divided by characters in a given set.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func componentsSeparatedByString(separator: String) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array containing substrings from the <code>String</code>
that have been divided by a given separator.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func cStringUsingEncoding(encoding: NSStringEncoding) -> [CChar]?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a representation of the <code>String</code> as a C string
using a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func dataUsingEncoding(encoding: NSStringEncoding, allowLossyConversion: Bool = default) -> NSData?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an <code>NSData</code> object containing a representation of
the <code>String</code> encoded using a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func enumerateLines(body: (line: String, inout stop: Bool) -&gt; ())</code>
<div class="comment">
    <p><em>[Foundation]</em> Enumerates all the lines in a string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func enumerateLinguisticTagsInRange(range: Range&lt;String.Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions, orthography: NSOrthography?, _ body: (String, Range&lt;String.Index&gt;, Range&lt;String.Index&gt;, inout Bool) -&gt; ())</code>
<div class="comment">
    <p><em>[Foundation]</em> Performs linguistic analysis on the specified string by
enumerating the specific range of the string, providing the
Block with the located tags.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func enumerateSubstringsInRange(range: Range&lt;String.Index&gt;, options opts: NSStringEnumerationOptions, _ body: (substring: String, substringRange: Range&lt;String.Index&gt;, enclosingRange: Range&lt;String.Index&gt;, inout Bool) -&gt; ())</code>
<div class="comment">
    <p><em>[Foundation]</em> Enumerates the substrings of the specified type in the
specified range of the string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func fileSystemRepresentation() -> [CChar]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a file system-specific representation of the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getBytes(inout buffer: [UInt8], maxLength: Int, usedLength: UnsafeMutablePointer&lt;Int&gt;, encoding: NSStringEncoding, options: NSStringEncodingConversionOptions, range: Range&lt;String.Index&gt;, remainingRange: UnsafeMutablePointer&lt;Range&lt;String.Index&gt;&gt;) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Gets a given range of characters as bytes in a specified encoding.
Note: will get a maximum of <code>min(buffer.count, maxLength)</code> bytes.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getCString(inout buffer: [CChar], maxLength: Int, encoding: NSStringEncoding) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Converts the <code>String</code>’s content to a given encoding and</p>

<p>stores them in a buffer. Note: will store a maximum of
<code>min(buffer.count, maxLength)</code> bytes.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getFileSystemRepresentation(inout buffer: [CChar], maxLength: Int) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Interprets the <code>String</code> as a system-independent path and
fills a buffer with a C-string in a format and encoding suitable
for use with file-system calls. Note: will store a maximum of
<code>min(buffer.count, maxLength)</code> bytes.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getLineStart(start: UnsafeMutablePointer&lt;String.Index&gt;, end: UnsafeMutablePointer&lt;String.Index&gt;, contentsEnd: UnsafeMutablePointer&lt;String.Index&gt;, forRange: Range&lt;String.Index&gt;)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns by reference the beginning of the first line and
the end of the last line touched by the given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func getParagraphStart(start: UnsafeMutablePointer&lt;String.Index&gt;, end: UnsafeMutablePointer&lt;String.Index&gt;, contentsEnd: UnsafeMutablePointer&lt;String.Index&gt;, forRange: Range&lt;String.Index&gt;)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns by reference the beginning of the first paragraph
and the end of the last paragraph touched by the given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func lengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the number of bytes required to store the
<code>String</code> in a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func lineRangeForRange(aRange: Range&lt;String.Index&gt;) -> Range&lt;String.Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range of characters representing the line or lines
containing a given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func linguisticTagsInRange(range: Range&lt;String.Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions = default, orthography: NSOrthography? = default, tokenRanges: UnsafeMutablePointer&lt;[Range&lt;String.Index&gt;]&gt; = default) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array of linguistic tags for the specified
range and requested tags within the receiving string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func localizedCaseInsensitiveCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string and a given string using a
case-insensitive, localized, comparison.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func localizedCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string and a given string using a localized
comparison.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func localizedStandardCompare(string: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares strings as sorted by the Finder.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func lowercaseStringWithLocale(locale: NSLocale) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a version of the string with all letters
converted to lowercase, taking into account the specified
locale.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func maximumLengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the maximum number of bytes needed to store the
<code>String</code> in a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func paragraphRangeForRange(aRange: Range&lt;String.Index&gt;) -> Range&lt;String.Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range of characters representing the
paragraph or paragraphs containing a given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func propertyList() -> AnyObject</code>
<div class="comment">
    <p><em>[Foundation]</em> Parses the <code>String</code> as a text representation of a
property list, returning an NSString, NSData, NSArray, or
NSDictionary object, according to the topmost element.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func propertyListFromStringsFileFormat() -> [String : String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a dictionary object initialized with the keys and
values found in the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func rangeOfCharacterFromSet(aSet: NSCharacterSet, options mask: NSStringCompareOptions = default, range aRange: Range&lt;String.Index&gt;? = default) -> Range&lt;String.Index&gt;?</code>
<div class="comment">
    <p><em>[Foundation]</em> Finds and returns the range in the <code>String</code> of the first
character from a given character set found in a given range with
given options.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func rangeOfComposedCharacterSequenceAtIndex(anIndex: String.Index) -> Range&lt;String.Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range in the <code>String</code> of the composed
character sequence located at a given index.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func rangeOfComposedCharacterSequencesForRange(range: Range&lt;String.Index&gt;) -> Range&lt;String.Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range in the string of the composed character
sequences for a given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func rangeOfString(aString: String, options mask: NSStringCompareOptions = default, range searchRange: Range&lt;String.Index&gt;? = default, locale: NSLocale? = default) -> Range&lt;String.Index&gt;?</code>
<div class="comment">
    <p><em>[Foundation]</em> Finds and returns the range of the first occurrence of a
given string within a given range of the <code>String</code>, subject to
given options, using the specified locale, if any.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made from the <code>String</code> by replacing
all characters not in the specified set with percent encoded
characters.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAddingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a representation of the <code>String</code> using a given
encoding to determine the percent escapes necessary to convert
the <code>String</code> into a legal URL string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAppendingFormat(format: String, _ arguments: CVarArgType...) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by appending to the <code>String</code> a
string constructed from a given format string and the following
arguments.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAppendingPathComponent(aString: String) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by appending to the <code>String</code> a given string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAppendingPathExtension(ext: String) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by appending to the <code>String</code> an
extension separator followed by a given extension.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByAppendingString(aString: String) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by appending a given string to
the <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByFoldingWithOptions(options: NSStringCompareOptions, locale: NSLocale) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string with the given character folding options
applied.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByPaddingToLength(newLength: Int, withString padString: String, startingAtIndex padIndex: Int) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string formed from the <code>String</code> by either
removing characters from the end, or by appending as many
occurrences as necessary of a given pad string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByReplacingCharactersInRange(range: Range&lt;String.Index&gt;, withString replacement: String) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string in which the characters in a
specified range of the <code>String</code> are replaced by a given string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByReplacingOccurrencesOfString(target: String, withString replacement: String, options: NSStringCompareOptions = default, range searchRange: Range&lt;String.Index&gt;? = default) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string in which all occurrences of a target
string in a specified range of the <code>String</code> are replaced by
another given string.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByReplacingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by replacing in the <code>String</code>
all percent escapes with the matching characters as determined
by a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringByTrimmingCharactersInSet(set: NSCharacterSet) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by removing from both ends of
the <code>String</code> characters contained in a given character set.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func stringsByAppendingPaths(paths: [String]) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array of strings made by separately appending
to the <code>String</code> each string in in a given array.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func substringFromIndex(index: String.Index) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string containing the characters of the
<code>String</code> from the one at a given index to the end.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func substringToIndex(index: String.Index) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string containing the characters of the
<code>String</code> up to, but not including, the one at a given index.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func substringWithRange(aRange: Range&lt;String.Index&gt;) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string object containing the characters of the
<code>String</code> that lie within a given range.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func uppercaseStringWithLocale(locale: NSLocale) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a version of the string with all letters
converted to uppercase, taking into account the specified
locale.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func writeToFile(path: String, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding, error: NSErrorPointer = default) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Writes the contents of the <code>String</code> to a file at a given
path using a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">func writeToURL(url: NSURL, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding, error: NSErrorPointer = default) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Writes the contents of the <code>String</code> to the URL specified
by url using the specified encoding.</p>
</div>
</div>

<h3>Subscripts</h3>
<div class="declaration">
<code class="language-swift">subscript(i: String.Index) -> Character { get }</code>
</div>
<div class="declaration">
<code class="language-swift">subscript(subRange: Range&lt;String.Index&gt;) -> String { get }</code>
</div>


